<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>ggmath API documentation</title>
    <meta name="description" content="" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#ggmath.pi">pi</a></li>
  </ul>

    </li>


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#ggmath.Bunny">Bunny</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggmath.Bunny.__init__">__init__</a></li>
    <li class="mono"><a href="#ggmath.Bunny.Color">Color</a></li>
    <li class="mono"><a href="#ggmath.Bunny.GoTo">GoTo</a></li>
    <li class="mono"><a href="#ggmath.Bunny.Left">Left</a></li>
    <li class="mono"><a href="#ggmath.Bunny.Move">Move</a></li>
    <li class="mono"><a href="#ggmath.Bunny.PenDown">PenDown</a></li>
    <li class="mono"><a href="#ggmath.Bunny.PenUp">PenUp</a></li>
    <li class="mono"><a href="#ggmath.Bunny.Right">Right</a></li>
    <li class="mono"><a href="#ggmath.Bunny.SetAngle">SetAngle</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggmath.Circle">Circle</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggmath.Circle.__init__">__init__</a></li>
    <li class="mono"><a href="#ggmath.Circle.Eval">Eval</a></li>
    <li class="mono"><a href="#ggmath.Circle.canstroke">canstroke</a></li>
    <li class="mono"><a href="#ggmath.Circle.circularCollisionModel">circularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.Circle.collidingPolyWithPoly">collidingPolyWithPoly</a></li>
    <li class="mono"><a href="#ggmath.Circle.collidingWith">collidingWith</a></li>
    <li class="mono"><a href="#ggmath.Circle.collidingWithSprites">collidingWithSprites</a></li>
    <li class="mono"><a href="#ggmath.Circle.destroy">destroy</a></li>
    <li class="mono"><a href="#ggmath.Circle.firstImage">firstImage</a></li>
    <li class="mono"><a href="#ggmath.Circle.lastImage">lastImage</a></li>
    <li class="mono"><a href="#ggmath.Circle.mousedown">mousedown</a></li>
    <li class="mono"><a href="#ggmath.Circle.mouseup">mouseup</a></li>
    <li class="mono"><a href="#ggmath.Circle.nextImage">nextImage</a></li>
    <li class="mono"><a href="#ggmath.Circle.physicalPointTouching">physicalPointTouching</a></li>
    <li class="mono"><a href="#ggmath.Circle.prevImage">prevImage</a></li>
    <li class="mono"><a href="#ggmath.Circle.processEvent">processEvent</a></li>
    <li class="mono"><a href="#ggmath.Circle.rectangularCollisionModel">rectangularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.Circle.select">select</a></li>
    <li class="mono"><a href="#ggmath.Circle.setImage">setImage</a></li>
    <li class="mono"><a href="#ggmath.Circle.step">step</a></li>
    <li class="mono"><a href="#ggmath.Circle.stroke">stroke</a></li>
    <li class="mono"><a href="#ggmath.Circle.translate">translate</a></li>
    <li class="mono"><a href="#ggmath.Circle.unselect">unselect</a></li>
    <li class="mono"><a href="#ggmath.Circle.collidingCircleWithPoly">collidingCircleWithPoly</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggmath.GlassButton">GlassButton</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggmath.GlassButton.__init__">__init__</a></li>
    <li class="mono"><a href="#ggmath.GlassButton.Eval">Eval</a></li>
    <li class="mono"><a href="#ggmath.GlassButton.canstroke">canstroke</a></li>
    <li class="mono"><a href="#ggmath.GlassButton.circularCollisionModel">circularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.GlassButton.collidingPolyWithPoly">collidingPolyWithPoly</a></li>
    <li class="mono"><a href="#ggmath.GlassButton.collidingWith">collidingWith</a></li>
    <li class="mono"><a href="#ggmath.GlassButton.collidingWithSprites">collidingWithSprites</a></li>
    <li class="mono"><a href="#ggmath.GlassButton.destroy">destroy</a></li>
    <li class="mono"><a href="#ggmath.GlassButton.distanceTo">distanceTo</a></li>
    <li class="mono"><a href="#ggmath.GlassButton.firstImage">firstImage</a></li>
    <li class="mono"><a href="#ggmath.GlassButton.lastImage">lastImage</a></li>
    <li class="mono"><a href="#ggmath.GlassButton.mousedown">mousedown</a></li>
    <li class="mono"><a href="#ggmath.GlassButton.mouseup">mouseup</a></li>
    <li class="mono"><a href="#ggmath.GlassButton.nextImage">nextImage</a></li>
    <li class="mono"><a href="#ggmath.GlassButton.physicalPointTouching">physicalPointTouching</a></li>
    <li class="mono"><a href="#ggmath.GlassButton.prevImage">prevImage</a></li>
    <li class="mono"><a href="#ggmath.GlassButton.processEvent">processEvent</a></li>
    <li class="mono"><a href="#ggmath.GlassButton.rectangularCollisionModel">rectangularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.GlassButton.select">select</a></li>
    <li class="mono"><a href="#ggmath.GlassButton.setImage">setImage</a></li>
    <li class="mono"><a href="#ggmath.GlassButton.step">step</a></li>
    <li class="mono"><a href="#ggmath.GlassButton.stroke">stroke</a></li>
    <li class="mono"><a href="#ggmath.GlassButton.translate">translate</a></li>
    <li class="mono"><a href="#ggmath.GlassButton.unselect">unselect</a></li>
    <li class="mono"><a href="#ggmath.GlassButton.collidingCircleWithPoly">collidingCircleWithPoly</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggmath.ImageIndicator">ImageIndicator</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggmath.ImageIndicator.__init__">__init__</a></li>
    <li class="mono"><a href="#ggmath.ImageIndicator.Eval">Eval</a></li>
    <li class="mono"><a href="#ggmath.ImageIndicator.canstroke">canstroke</a></li>
    <li class="mono"><a href="#ggmath.ImageIndicator.circularCollisionModel">circularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.ImageIndicator.collidingPolyWithPoly">collidingPolyWithPoly</a></li>
    <li class="mono"><a href="#ggmath.ImageIndicator.collidingWith">collidingWith</a></li>
    <li class="mono"><a href="#ggmath.ImageIndicator.collidingWithSprites">collidingWithSprites</a></li>
    <li class="mono"><a href="#ggmath.ImageIndicator.destroy">destroy</a></li>
    <li class="mono"><a href="#ggmath.ImageIndicator.firstImage">firstImage</a></li>
    <li class="mono"><a href="#ggmath.ImageIndicator.lastImage">lastImage</a></li>
    <li class="mono"><a href="#ggmath.ImageIndicator.mousedown">mousedown</a></li>
    <li class="mono"><a href="#ggmath.ImageIndicator.mouseup">mouseup</a></li>
    <li class="mono"><a href="#ggmath.ImageIndicator.nextImage">nextImage</a></li>
    <li class="mono"><a href="#ggmath.ImageIndicator.physicalPointTouching">physicalPointTouching</a></li>
    <li class="mono"><a href="#ggmath.ImageIndicator.prevImage">prevImage</a></li>
    <li class="mono"><a href="#ggmath.ImageIndicator.processEvent">processEvent</a></li>
    <li class="mono"><a href="#ggmath.ImageIndicator.rectangularCollisionModel">rectangularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.ImageIndicator.select">select</a></li>
    <li class="mono"><a href="#ggmath.ImageIndicator.setImage">setImage</a></li>
    <li class="mono"><a href="#ggmath.ImageIndicator.step">step</a></li>
    <li class="mono"><a href="#ggmath.ImageIndicator.stroke">stroke</a></li>
    <li class="mono"><a href="#ggmath.ImageIndicator.translate">translate</a></li>
    <li class="mono"><a href="#ggmath.ImageIndicator.unselect">unselect</a></li>
    <li class="mono"><a href="#ggmath.ImageIndicator.collidingCircleWithPoly">collidingCircleWithPoly</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggmath.ImagePoint">ImagePoint</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggmath.ImagePoint.__init__">__init__</a></li>
    <li class="mono"><a href="#ggmath.ImagePoint.Eval">Eval</a></li>
    <li class="mono"><a href="#ggmath.ImagePoint.canstroke">canstroke</a></li>
    <li class="mono"><a href="#ggmath.ImagePoint.circularCollisionModel">circularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.ImagePoint.collidingPolyWithPoly">collidingPolyWithPoly</a></li>
    <li class="mono"><a href="#ggmath.ImagePoint.collidingWith">collidingWith</a></li>
    <li class="mono"><a href="#ggmath.ImagePoint.collidingWithSprites">collidingWithSprites</a></li>
    <li class="mono"><a href="#ggmath.ImagePoint.destroy">destroy</a></li>
    <li class="mono"><a href="#ggmath.ImagePoint.distanceTo">distanceTo</a></li>
    <li class="mono"><a href="#ggmath.ImagePoint.firstImage">firstImage</a></li>
    <li class="mono"><a href="#ggmath.ImagePoint.lastImage">lastImage</a></li>
    <li class="mono"><a href="#ggmath.ImagePoint.mousedown">mousedown</a></li>
    <li class="mono"><a href="#ggmath.ImagePoint.mouseup">mouseup</a></li>
    <li class="mono"><a href="#ggmath.ImagePoint.nextImage">nextImage</a></li>
    <li class="mono"><a href="#ggmath.ImagePoint.physicalPointTouching">physicalPointTouching</a></li>
    <li class="mono"><a href="#ggmath.ImagePoint.prevImage">prevImage</a></li>
    <li class="mono"><a href="#ggmath.ImagePoint.processEvent">processEvent</a></li>
    <li class="mono"><a href="#ggmath.ImagePoint.rectangularCollisionModel">rectangularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.ImagePoint.select">select</a></li>
    <li class="mono"><a href="#ggmath.ImagePoint.setImage">setImage</a></li>
    <li class="mono"><a href="#ggmath.ImagePoint.step">step</a></li>
    <li class="mono"><a href="#ggmath.ImagePoint.stroke">stroke</a></li>
    <li class="mono"><a href="#ggmath.ImagePoint.translate">translate</a></li>
    <li class="mono"><a href="#ggmath.ImagePoint.unselect">unselect</a></li>
    <li class="mono"><a href="#ggmath.ImagePoint.collidingCircleWithPoly">collidingCircleWithPoly</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggmath.InputButton">InputButton</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggmath.InputButton.__init__">__init__</a></li>
    <li class="mono"><a href="#ggmath.InputButton.Eval">Eval</a></li>
    <li class="mono"><a href="#ggmath.InputButton.canstroke">canstroke</a></li>
    <li class="mono"><a href="#ggmath.InputButton.circularCollisionModel">circularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.InputButton.collidingPolyWithPoly">collidingPolyWithPoly</a></li>
    <li class="mono"><a href="#ggmath.InputButton.collidingWith">collidingWith</a></li>
    <li class="mono"><a href="#ggmath.InputButton.collidingWithSprites">collidingWithSprites</a></li>
    <li class="mono"><a href="#ggmath.InputButton.destroy">destroy</a></li>
    <li class="mono"><a href="#ggmath.InputButton.firstImage">firstImage</a></li>
    <li class="mono"><a href="#ggmath.InputButton.lastImage">lastImage</a></li>
    <li class="mono"><a href="#ggmath.InputButton.mousedown">mousedown</a></li>
    <li class="mono"><a href="#ggmath.InputButton.mouseup">mouseup</a></li>
    <li class="mono"><a href="#ggmath.InputButton.nextImage">nextImage</a></li>
    <li class="mono"><a href="#ggmath.InputButton.physicalPointTouching">physicalPointTouching</a></li>
    <li class="mono"><a href="#ggmath.InputButton.prevImage">prevImage</a></li>
    <li class="mono"><a href="#ggmath.InputButton.processEvent">processEvent</a></li>
    <li class="mono"><a href="#ggmath.InputButton.rectangularCollisionModel">rectangularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.InputButton.select">select</a></li>
    <li class="mono"><a href="#ggmath.InputButton.setImage">setImage</a></li>
    <li class="mono"><a href="#ggmath.InputButton.step">step</a></li>
    <li class="mono"><a href="#ggmath.InputButton.stroke">stroke</a></li>
    <li class="mono"><a href="#ggmath.InputButton.translate">translate</a></li>
    <li class="mono"><a href="#ggmath.InputButton.unselect">unselect</a></li>
    <li class="mono"><a href="#ggmath.InputButton.collidingCircleWithPoly">collidingCircleWithPoly</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggmath.InputImageButton">InputImageButton</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggmath.InputImageButton.__init__">__init__</a></li>
    <li class="mono"><a href="#ggmath.InputImageButton.Eval">Eval</a></li>
    <li class="mono"><a href="#ggmath.InputImageButton.canstroke">canstroke</a></li>
    <li class="mono"><a href="#ggmath.InputImageButton.circularCollisionModel">circularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.InputImageButton.collidingPolyWithPoly">collidingPolyWithPoly</a></li>
    <li class="mono"><a href="#ggmath.InputImageButton.collidingWith">collidingWith</a></li>
    <li class="mono"><a href="#ggmath.InputImageButton.collidingWithSprites">collidingWithSprites</a></li>
    <li class="mono"><a href="#ggmath.InputImageButton.destroy">destroy</a></li>
    <li class="mono"><a href="#ggmath.InputImageButton.distanceTo">distanceTo</a></li>
    <li class="mono"><a href="#ggmath.InputImageButton.firstImage">firstImage</a></li>
    <li class="mono"><a href="#ggmath.InputImageButton.lastImage">lastImage</a></li>
    <li class="mono"><a href="#ggmath.InputImageButton.mousedown">mousedown</a></li>
    <li class="mono"><a href="#ggmath.InputImageButton.mouseup">mouseup</a></li>
    <li class="mono"><a href="#ggmath.InputImageButton.nextImage">nextImage</a></li>
    <li class="mono"><a href="#ggmath.InputImageButton.physicalPointTouching">physicalPointTouching</a></li>
    <li class="mono"><a href="#ggmath.InputImageButton.prevImage">prevImage</a></li>
    <li class="mono"><a href="#ggmath.InputImageButton.processEvent">processEvent</a></li>
    <li class="mono"><a href="#ggmath.InputImageButton.rectangularCollisionModel">rectangularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.InputImageButton.select">select</a></li>
    <li class="mono"><a href="#ggmath.InputImageButton.setImage">setImage</a></li>
    <li class="mono"><a href="#ggmath.InputImageButton.step">step</a></li>
    <li class="mono"><a href="#ggmath.InputImageButton.stroke">stroke</a></li>
    <li class="mono"><a href="#ggmath.InputImageButton.translate">translate</a></li>
    <li class="mono"><a href="#ggmath.InputImageButton.unselect">unselect</a></li>
    <li class="mono"><a href="#ggmath.InputImageButton.collidingCircleWithPoly">collidingCircleWithPoly</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggmath.InputImageToggle">InputImageToggle</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggmath.InputImageToggle.__init__">__init__</a></li>
    <li class="mono"><a href="#ggmath.InputImageToggle.Eval">Eval</a></li>
    <li class="mono"><a href="#ggmath.InputImageToggle.canstroke">canstroke</a></li>
    <li class="mono"><a href="#ggmath.InputImageToggle.circularCollisionModel">circularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.InputImageToggle.collidingPolyWithPoly">collidingPolyWithPoly</a></li>
    <li class="mono"><a href="#ggmath.InputImageToggle.collidingWith">collidingWith</a></li>
    <li class="mono"><a href="#ggmath.InputImageToggle.collidingWithSprites">collidingWithSprites</a></li>
    <li class="mono"><a href="#ggmath.InputImageToggle.destroy">destroy</a></li>
    <li class="mono"><a href="#ggmath.InputImageToggle.distanceTo">distanceTo</a></li>
    <li class="mono"><a href="#ggmath.InputImageToggle.firstImage">firstImage</a></li>
    <li class="mono"><a href="#ggmath.InputImageToggle.lastImage">lastImage</a></li>
    <li class="mono"><a href="#ggmath.InputImageToggle.mousedown">mousedown</a></li>
    <li class="mono"><a href="#ggmath.InputImageToggle.mouseup">mouseup</a></li>
    <li class="mono"><a href="#ggmath.InputImageToggle.nextImage">nextImage</a></li>
    <li class="mono"><a href="#ggmath.InputImageToggle.physicalPointTouching">physicalPointTouching</a></li>
    <li class="mono"><a href="#ggmath.InputImageToggle.prevImage">prevImage</a></li>
    <li class="mono"><a href="#ggmath.InputImageToggle.processEvent">processEvent</a></li>
    <li class="mono"><a href="#ggmath.InputImageToggle.rectangularCollisionModel">rectangularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.InputImageToggle.select">select</a></li>
    <li class="mono"><a href="#ggmath.InputImageToggle.setImage">setImage</a></li>
    <li class="mono"><a href="#ggmath.InputImageToggle.step">step</a></li>
    <li class="mono"><a href="#ggmath.InputImageToggle.stroke">stroke</a></li>
    <li class="mono"><a href="#ggmath.InputImageToggle.translate">translate</a></li>
    <li class="mono"><a href="#ggmath.InputImageToggle.unselect">unselect</a></li>
    <li class="mono"><a href="#ggmath.InputImageToggle.collidingCircleWithPoly">collidingCircleWithPoly</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggmath.InputNumeric">InputNumeric</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggmath.InputNumeric.__init__">__init__</a></li>
    <li class="mono"><a href="#ggmath.InputNumeric.Eval">Eval</a></li>
    <li class="mono"><a href="#ggmath.InputNumeric.canstroke">canstroke</a></li>
    <li class="mono"><a href="#ggmath.InputNumeric.circularCollisionModel">circularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.InputNumeric.collidingPolyWithPoly">collidingPolyWithPoly</a></li>
    <li class="mono"><a href="#ggmath.InputNumeric.collidingWith">collidingWith</a></li>
    <li class="mono"><a href="#ggmath.InputNumeric.collidingWithSprites">collidingWithSprites</a></li>
    <li class="mono"><a href="#ggmath.InputNumeric.destroy">destroy</a></li>
    <li class="mono"><a href="#ggmath.InputNumeric.firstImage">firstImage</a></li>
    <li class="mono"><a href="#ggmath.InputNumeric.lastImage">lastImage</a></li>
    <li class="mono"><a href="#ggmath.InputNumeric.mousedown">mousedown</a></li>
    <li class="mono"><a href="#ggmath.InputNumeric.mouseup">mouseup</a></li>
    <li class="mono"><a href="#ggmath.InputNumeric.nextImage">nextImage</a></li>
    <li class="mono"><a href="#ggmath.InputNumeric.physicalPointTouching">physicalPointTouching</a></li>
    <li class="mono"><a href="#ggmath.InputNumeric.prevImage">prevImage</a></li>
    <li class="mono"><a href="#ggmath.InputNumeric.processEvent">processEvent</a></li>
    <li class="mono"><a href="#ggmath.InputNumeric.rectangularCollisionModel">rectangularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.InputNumeric.select">select</a></li>
    <li class="mono"><a href="#ggmath.InputNumeric.setImage">setImage</a></li>
    <li class="mono"><a href="#ggmath.InputNumeric.step">step</a></li>
    <li class="mono"><a href="#ggmath.InputNumeric.stroke">stroke</a></li>
    <li class="mono"><a href="#ggmath.InputNumeric.translate">translate</a></li>
    <li class="mono"><a href="#ggmath.InputNumeric.unselect">unselect</a></li>
    <li class="mono"><a href="#ggmath.InputNumeric.collidingCircleWithPoly">collidingCircleWithPoly</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggmath.LEDIndicator">LEDIndicator</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggmath.LEDIndicator.__init__">__init__</a></li>
    <li class="mono"><a href="#ggmath.LEDIndicator.Eval">Eval</a></li>
    <li class="mono"><a href="#ggmath.LEDIndicator.canstroke">canstroke</a></li>
    <li class="mono"><a href="#ggmath.LEDIndicator.circularCollisionModel">circularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.LEDIndicator.collidingPolyWithPoly">collidingPolyWithPoly</a></li>
    <li class="mono"><a href="#ggmath.LEDIndicator.collidingWith">collidingWith</a></li>
    <li class="mono"><a href="#ggmath.LEDIndicator.collidingWithSprites">collidingWithSprites</a></li>
    <li class="mono"><a href="#ggmath.LEDIndicator.destroy">destroy</a></li>
    <li class="mono"><a href="#ggmath.LEDIndicator.firstImage">firstImage</a></li>
    <li class="mono"><a href="#ggmath.LEDIndicator.lastImage">lastImage</a></li>
    <li class="mono"><a href="#ggmath.LEDIndicator.mousedown">mousedown</a></li>
    <li class="mono"><a href="#ggmath.LEDIndicator.mouseup">mouseup</a></li>
    <li class="mono"><a href="#ggmath.LEDIndicator.nextImage">nextImage</a></li>
    <li class="mono"><a href="#ggmath.LEDIndicator.physicalPointTouching">physicalPointTouching</a></li>
    <li class="mono"><a href="#ggmath.LEDIndicator.prevImage">prevImage</a></li>
    <li class="mono"><a href="#ggmath.LEDIndicator.processEvent">processEvent</a></li>
    <li class="mono"><a href="#ggmath.LEDIndicator.rectangularCollisionModel">rectangularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.LEDIndicator.select">select</a></li>
    <li class="mono"><a href="#ggmath.LEDIndicator.setImage">setImage</a></li>
    <li class="mono"><a href="#ggmath.LEDIndicator.step">step</a></li>
    <li class="mono"><a href="#ggmath.LEDIndicator.stroke">stroke</a></li>
    <li class="mono"><a href="#ggmath.LEDIndicator.translate">translate</a></li>
    <li class="mono"><a href="#ggmath.LEDIndicator.unselect">unselect</a></li>
    <li class="mono"><a href="#ggmath.LEDIndicator.collidingCircleWithPoly">collidingCircleWithPoly</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggmath.Label">Label</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggmath.Label.__init__">__init__</a></li>
    <li class="mono"><a href="#ggmath.Label.Eval">Eval</a></li>
    <li class="mono"><a href="#ggmath.Label.canstroke">canstroke</a></li>
    <li class="mono"><a href="#ggmath.Label.circularCollisionModel">circularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.Label.collidingPolyWithPoly">collidingPolyWithPoly</a></li>
    <li class="mono"><a href="#ggmath.Label.collidingWith">collidingWith</a></li>
    <li class="mono"><a href="#ggmath.Label.collidingWithSprites">collidingWithSprites</a></li>
    <li class="mono"><a href="#ggmath.Label.destroy">destroy</a></li>
    <li class="mono"><a href="#ggmath.Label.firstImage">firstImage</a></li>
    <li class="mono"><a href="#ggmath.Label.lastImage">lastImage</a></li>
    <li class="mono"><a href="#ggmath.Label.mousedown">mousedown</a></li>
    <li class="mono"><a href="#ggmath.Label.mouseup">mouseup</a></li>
    <li class="mono"><a href="#ggmath.Label.nextImage">nextImage</a></li>
    <li class="mono"><a href="#ggmath.Label.physicalPointTouching">physicalPointTouching</a></li>
    <li class="mono"><a href="#ggmath.Label.prevImage">prevImage</a></li>
    <li class="mono"><a href="#ggmath.Label.processEvent">processEvent</a></li>
    <li class="mono"><a href="#ggmath.Label.rectangularCollisionModel">rectangularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.Label.select">select</a></li>
    <li class="mono"><a href="#ggmath.Label.setImage">setImage</a></li>
    <li class="mono"><a href="#ggmath.Label.step">step</a></li>
    <li class="mono"><a href="#ggmath.Label.stroke">stroke</a></li>
    <li class="mono"><a href="#ggmath.Label.translate">translate</a></li>
    <li class="mono"><a href="#ggmath.Label.unselect">unselect</a></li>
    <li class="mono"><a href="#ggmath.Label.collidingCircleWithPoly">collidingCircleWithPoly</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggmath.LineSegment">LineSegment</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggmath.LineSegment.__init__">__init__</a></li>
    <li class="mono"><a href="#ggmath.LineSegment.Eval">Eval</a></li>
    <li class="mono"><a href="#ggmath.LineSegment.canstroke">canstroke</a></li>
    <li class="mono"><a href="#ggmath.LineSegment.circularCollisionModel">circularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.LineSegment.collidingPolyWithPoly">collidingPolyWithPoly</a></li>
    <li class="mono"><a href="#ggmath.LineSegment.collidingWith">collidingWith</a></li>
    <li class="mono"><a href="#ggmath.LineSegment.collidingWithSprites">collidingWithSprites</a></li>
    <li class="mono"><a href="#ggmath.LineSegment.destroy">destroy</a></li>
    <li class="mono"><a href="#ggmath.LineSegment.firstImage">firstImage</a></li>
    <li class="mono"><a href="#ggmath.LineSegment.lastImage">lastImage</a></li>
    <li class="mono"><a href="#ggmath.LineSegment.mousedown">mousedown</a></li>
    <li class="mono"><a href="#ggmath.LineSegment.mouseup">mouseup</a></li>
    <li class="mono"><a href="#ggmath.LineSegment.nextImage">nextImage</a></li>
    <li class="mono"><a href="#ggmath.LineSegment.physicalPointTouching">physicalPointTouching</a></li>
    <li class="mono"><a href="#ggmath.LineSegment.prevImage">prevImage</a></li>
    <li class="mono"><a href="#ggmath.LineSegment.processEvent">processEvent</a></li>
    <li class="mono"><a href="#ggmath.LineSegment.rectangularCollisionModel">rectangularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.LineSegment.select">select</a></li>
    <li class="mono"><a href="#ggmath.LineSegment.setImage">setImage</a></li>
    <li class="mono"><a href="#ggmath.LineSegment.step">step</a></li>
    <li class="mono"><a href="#ggmath.LineSegment.stroke">stroke</a></li>
    <li class="mono"><a href="#ggmath.LineSegment.translate">translate</a></li>
    <li class="mono"><a href="#ggmath.LineSegment.unselect">unselect</a></li>
    <li class="mono"><a href="#ggmath.LineSegment.collidingCircleWithPoly">collidingCircleWithPoly</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggmath.MathApp">MathApp</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggmath.MathApp.__init__">__init__</a></li>
    <li class="mono"><a href="#ggmath.MathApp.handleMouseClick">handleMouseClick</a></li>
    <li class="mono"><a href="#ggmath.MathApp.handleMouseDown">handleMouseDown</a></li>
    <li class="mono"><a href="#ggmath.MathApp.handleMouseMove">handleMouseMove</a></li>
    <li class="mono"><a href="#ggmath.MathApp.handleMouseUp">handleMouseUp</a></li>
    <li class="mono"><a href="#ggmath.MathApp.handleMouseWheel">handleMouseWheel</a></li>
    <li class="mono"><a href="#ggmath.MathApp.run">run</a></li>
    <li class="mono"><a href="#ggmath.MathApp.step">step</a></li>
    <li class="mono"><a href="#ggmath.MathApp.addViewNotification">addViewNotification</a></li>
    <li class="mono"><a href="#ggmath.MathApp.distance">distance</a></li>
    <li class="mono"><a href="#ggmath.MathApp.getSpritesbyClass">getSpritesbyClass</a></li>
    <li class="mono"><a href="#ggmath.MathApp.listenKeyEvent">listenKeyEvent</a></li>
    <li class="mono"><a href="#ggmath.MathApp.listenMouseEvent">listenMouseEvent</a></li>
    <li class="mono"><a href="#ggmath.MathApp.logicalToPhysical">logicalToPhysical</a></li>
    <li class="mono"><a href="#ggmath.MathApp.physicalToLogical">physicalToLogical</a></li>
    <li class="mono"><a href="#ggmath.MathApp.removeViewNotification">removeViewNotification</a></li>
    <li class="mono"><a href="#ggmath.MathApp.translateLogicalToPhysical">translateLogicalToPhysical</a></li>
    <li class="mono"><a href="#ggmath.MathApp.translatePhysicalToLogical">translatePhysicalToLogical</a></li>
    <li class="mono"><a href="#ggmath.MathApp.unlistenKeyEvent">unlistenKeyEvent</a></li>
    <li class="mono"><a href="#ggmath.MathApp.unlistenMouseEvent">unlistenMouseEvent</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggmath.MetalToggle">MetalToggle</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggmath.MetalToggle.__init__">__init__</a></li>
    <li class="mono"><a href="#ggmath.MetalToggle.Eval">Eval</a></li>
    <li class="mono"><a href="#ggmath.MetalToggle.canstroke">canstroke</a></li>
    <li class="mono"><a href="#ggmath.MetalToggle.circularCollisionModel">circularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.MetalToggle.collidingPolyWithPoly">collidingPolyWithPoly</a></li>
    <li class="mono"><a href="#ggmath.MetalToggle.collidingWith">collidingWith</a></li>
    <li class="mono"><a href="#ggmath.MetalToggle.collidingWithSprites">collidingWithSprites</a></li>
    <li class="mono"><a href="#ggmath.MetalToggle.destroy">destroy</a></li>
    <li class="mono"><a href="#ggmath.MetalToggle.distanceTo">distanceTo</a></li>
    <li class="mono"><a href="#ggmath.MetalToggle.firstImage">firstImage</a></li>
    <li class="mono"><a href="#ggmath.MetalToggle.lastImage">lastImage</a></li>
    <li class="mono"><a href="#ggmath.MetalToggle.mousedown">mousedown</a></li>
    <li class="mono"><a href="#ggmath.MetalToggle.mouseup">mouseup</a></li>
    <li class="mono"><a href="#ggmath.MetalToggle.nextImage">nextImage</a></li>
    <li class="mono"><a href="#ggmath.MetalToggle.physicalPointTouching">physicalPointTouching</a></li>
    <li class="mono"><a href="#ggmath.MetalToggle.prevImage">prevImage</a></li>
    <li class="mono"><a href="#ggmath.MetalToggle.processEvent">processEvent</a></li>
    <li class="mono"><a href="#ggmath.MetalToggle.rectangularCollisionModel">rectangularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.MetalToggle.select">select</a></li>
    <li class="mono"><a href="#ggmath.MetalToggle.setImage">setImage</a></li>
    <li class="mono"><a href="#ggmath.MetalToggle.step">step</a></li>
    <li class="mono"><a href="#ggmath.MetalToggle.stroke">stroke</a></li>
    <li class="mono"><a href="#ggmath.MetalToggle.translate">translate</a></li>
    <li class="mono"><a href="#ggmath.MetalToggle.unselect">unselect</a></li>
    <li class="mono"><a href="#ggmath.MetalToggle.collidingCircleWithPoly">collidingCircleWithPoly</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggmath.Point">Point</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggmath.Point.__init__">__init__</a></li>
    <li class="mono"><a href="#ggmath.Point.Eval">Eval</a></li>
    <li class="mono"><a href="#ggmath.Point.canstroke">canstroke</a></li>
    <li class="mono"><a href="#ggmath.Point.circularCollisionModel">circularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.Point.collidingPolyWithPoly">collidingPolyWithPoly</a></li>
    <li class="mono"><a href="#ggmath.Point.collidingWith">collidingWith</a></li>
    <li class="mono"><a href="#ggmath.Point.collidingWithSprites">collidingWithSprites</a></li>
    <li class="mono"><a href="#ggmath.Point.destroy">destroy</a></li>
    <li class="mono"><a href="#ggmath.Point.distanceTo">distanceTo</a></li>
    <li class="mono"><a href="#ggmath.Point.firstImage">firstImage</a></li>
    <li class="mono"><a href="#ggmath.Point.lastImage">lastImage</a></li>
    <li class="mono"><a href="#ggmath.Point.mousedown">mousedown</a></li>
    <li class="mono"><a href="#ggmath.Point.mouseup">mouseup</a></li>
    <li class="mono"><a href="#ggmath.Point.nextImage">nextImage</a></li>
    <li class="mono"><a href="#ggmath.Point.physicalPointTouching">physicalPointTouching</a></li>
    <li class="mono"><a href="#ggmath.Point.prevImage">prevImage</a></li>
    <li class="mono"><a href="#ggmath.Point.processEvent">processEvent</a></li>
    <li class="mono"><a href="#ggmath.Point.rectangularCollisionModel">rectangularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.Point.select">select</a></li>
    <li class="mono"><a href="#ggmath.Point.setImage">setImage</a></li>
    <li class="mono"><a href="#ggmath.Point.step">step</a></li>
    <li class="mono"><a href="#ggmath.Point.stroke">stroke</a></li>
    <li class="mono"><a href="#ggmath.Point.translate">translate</a></li>
    <li class="mono"><a href="#ggmath.Point.unselect">unselect</a></li>
    <li class="mono"><a href="#ggmath.Point.collidingCircleWithPoly">collidingCircleWithPoly</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggmath.Slider">Slider</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggmath.Slider.__init__">__init__</a></li>
    <li class="mono"><a href="#ggmath.Slider.Eval">Eval</a></li>
    <li class="mono"><a href="#ggmath.Slider.canstroke">canstroke</a></li>
    <li class="mono"><a href="#ggmath.Slider.circularCollisionModel">circularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.Slider.collidingPolyWithPoly">collidingPolyWithPoly</a></li>
    <li class="mono"><a href="#ggmath.Slider.collidingWith">collidingWith</a></li>
    <li class="mono"><a href="#ggmath.Slider.collidingWithSprites">collidingWithSprites</a></li>
    <li class="mono"><a href="#ggmath.Slider.destroy">destroy</a></li>
    <li class="mono"><a href="#ggmath.Slider.firstImage">firstImage</a></li>
    <li class="mono"><a href="#ggmath.Slider.increment">increment</a></li>
    <li class="mono"><a href="#ggmath.Slider.lastImage">lastImage</a></li>
    <li class="mono"><a href="#ggmath.Slider.mouseClick">mouseClick</a></li>
    <li class="mono"><a href="#ggmath.Slider.mousedown">mousedown</a></li>
    <li class="mono"><a href="#ggmath.Slider.mouseup">mouseup</a></li>
    <li class="mono"><a href="#ggmath.Slider.moveCenter">moveCenter</a></li>
    <li class="mono"><a href="#ggmath.Slider.moveLeft">moveLeft</a></li>
    <li class="mono"><a href="#ggmath.Slider.moveRight">moveRight</a></li>
    <li class="mono"><a href="#ggmath.Slider.nextImage">nextImage</a></li>
    <li class="mono"><a href="#ggmath.Slider.physicalPointTouching">physicalPointTouching</a></li>
    <li class="mono"><a href="#ggmath.Slider.physicalPointTouchingThumb">physicalPointTouchingThumb</a></li>
    <li class="mono"><a href="#ggmath.Slider.prevImage">prevImage</a></li>
    <li class="mono"><a href="#ggmath.Slider.processEvent">processEvent</a></li>
    <li class="mono"><a href="#ggmath.Slider.rectangularCollisionModel">rectangularCollisionModel</a></li>
    <li class="mono"><a href="#ggmath.Slider.select">select</a></li>
    <li class="mono"><a href="#ggmath.Slider.setImage">setImage</a></li>
    <li class="mono"><a href="#ggmath.Slider.setThumb">setThumb</a></li>
    <li class="mono"><a href="#ggmath.Slider.step">step</a></li>
    <li class="mono"><a href="#ggmath.Slider.stroke">stroke</a></li>
    <li class="mono"><a href="#ggmath.Slider.thumbXY">thumbXY</a></li>
    <li class="mono"><a href="#ggmath.Slider.translate">translate</a></li>
    <li class="mono"><a href="#ggmath.Slider.unselect">unselect</a></li>
    <li class="mono"><a href="#ggmath.Slider.collidingCircleWithPoly">collidingCircleWithPoly</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggmath.Timer">Timer</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggmath.Timer.__init__">__init__</a></li>
    <li class="mono"><a href="#ggmath.Timer.Eval">Eval</a></li>
    <li class="mono"><a href="#ggmath.Timer.callAfter">callAfter</a></li>
    <li class="mono"><a href="#ggmath.Timer.callAt">callAt</a></li>
    <li class="mono"><a href="#ggmath.Timer.callEvery">callEvery</a></li>
    <li class="mono"><a href="#ggmath.Timer.destroy">destroy</a></li>
    <li class="mono"><a href="#ggmath.Timer.reset">reset</a></li>
    <li class="mono"><a href="#ggmath.Timer.step">step</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">ggmath</span> module</h1>
  
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath', this);">Show source &equiv;</a></p>
  <div id="source-ggmath" class="source">
    <pre><code># ggmath - ggame extensions for geometry and mathematics in the browser

from ggame import Frame, Color, LineStyle, LineAsset, CircleAsset, Sprite, App
from ggame import TextAsset, ImageAsset, PolygonAsset, RectangleAsset
from abc import ABCMeta, abstractmethod
from operator import add
from collections import namedtuple

from math import sin, cos, sqrt, pi
from time import time



class _MathDynamic(metaclass=ABCMeta):
    
    def __init__(self):
        self._dynamic = False  # not switched on, by default!
    
    def destroy(self):
        MathApp._removeDynamic(self)

    def step(self):
        pass
    
    def Eval(self, val):
        if callable(val):
            self._setDynamic() # dynamically defined .. must step
            return val
        else:
            return lambda : val  
            
    def _setDynamic(self):
        MathApp._addDynamic(self)
        self._dynamic = True
            

class _MathVisual(Sprite, _MathDynamic, metaclass=ABCMeta):
    
    posinputsdef = []  # a list of names (string) of required positional inputs
    nonposinputsdef = []  # a list of names (string) of required non positional inputs
    defaultsize = 15
    defaultwidth = 200
    defaultcolor = Color(0, 1)
    defaultstyle = LineStyle(1, Color(0, 1))
    
    
    def __init__(self, asset, *args, **kwargs):
        """
        Required inputs
        
        * **asset** a ggame asset
        * **args** the list of required positional and nonpositional arguments,
          as named in the posinputsdef and nonposinputsdef lists
        * **kwargs** all other optional keyword arguments:
          positioning - logical (default) or physical, size, width, color, style
          movable
        
        """
        
        MathApp._addVisual(self)
        #Sprite.__init__(self, asset, args[0])
        _MathDynamic.__init__(self)
        self._movable = False
        self._selectable = False
        self._strokable = False
        self.selected = False
        self.mouseisdown = False
        # 
        self.positioning = kwargs.get('positioning', 'logical')
        # positional inputs
        self.PI = namedtuple('PI', self.posinputsdef)
        # nonpositional inputs
        self.NPI = namedtuple('NPI', self.nonposinputsdef)
        # standard inputs (not positional)
        standardargs = ['size','width','color','style']
        self.SI = namedtuple('SI', standardargs)
        # correct number of args?
        if len(args) != len(self.posinputsdef) + len(self.nonposinputsdef):
            raise TypeError("Incorrect number of parameters provided")
        self.args = args
        # generated named tuple of functions from positional inputs
        self.posinputs = self.PI(*[self.Eval(p) for p in args][:len(self.posinputsdef)])
        self._getPhysicalInputs()
        # first positional argument must be a sprite position!
        Sprite.__init__(self, asset, self.pposinputs[0])
        # generated named tuple of functions from nonpositional inputs
        if len(self.nonposinputsdef) > 0:
            self.nposinputs = self.NPI(*[self.Eval(p) for p in args][(-1*len(self.nonposinputsdef)):])
        else:
            self.nposinputs = []
        self.stdinputs = self.SI(self.Eval(kwargs.get('size', self.defaultsize)),
                                    self.Eval(kwargs.get('width', self.defaultwidth)),
                                    self.Eval(kwargs.get('color', self.defaultcolor)),
                                    self.Eval(kwargs.get('style', self.defaultstyle)))
        self.sposinputs = self.PI(*[0]*len(self.posinputs))
        self.spposinputs = self.PI(*self.pposinputs)
        self.snposinputs = self.NPI(*[0]*len(self.nposinputs))
        self.sstdinputs = self.SI(*[0]*len(self.stdinputs))

    def step(self):
        self._touchAsset()
        
    def _saveInputs(self, inputs):
        self.sposinputs, self.spposinputs, self.snposinputs, self.sstdinputs = inputs
        
    def _getInputs(self):
        self._getPhysicalInputs()
        return (self.PI(*[p() for p in self.posinputs]),
            self.PI(*self.pposinputs),
            self.NPI(*[p() for p in self.nposinputs]),
            self.SI(*[p() for p in self.stdinputs]))

    
    def _getPhysicalInputs(self):
        """
        Translate all positional inputs to physical
        """
        pplist = []
        if self.positioning == 'logical':
            for p in self.posinputs:
                pval = p()
                try:
                    pp = MathApp.logicalToPhysical(pval)
                except AttributeError:
                    pp = MathApp._scale * pval
                pplist.append(pp)
        else:
            # already physical
            pplist = [p() for p in self.posinputs]
        self.pposinputs = self.PI(*pplist)
    
    def _inputsChanged(self, saved):
        return self.spposinputs != saved[1] or self.snposinputs != saved[2] or self.sstdinputs != saved[3]

    
    def destroy(self):
        MathApp._removeVisual(self)
        MathApp._removeMovable(self)
        MathApp._removeStrokable(self)
        _MathDynamic.destroy(self)
        Sprite.destroy(self)

    def _updateAsset(self, asset):
        if type(asset) != ImageAsset:
            visible = self.GFX.visible
            if App._win != None:
                App._win.remove(self.GFX)
                self.GFX.destroy()
            self.asset = asset
            self.GFX = self.asset.GFX
            self.GFX.visible = visible        
            if App._win != None:
                App._win.add(self.GFX)
        self.position = self.pposinputs.pos
            
    @property
    def movable(self):
        return self._movable
        
    @movable.setter
    def movable(self, val):
        if not self._dynamic:
            self._movable = val
            if val:
                MathApp._addMovable(self)
            else:
                MathApp._removeMovable(self)

    @property
    def selectable(self):
        return self._selectable
        
    @selectable.setter
    def selectable(self, val):
        self._selectable = val
        if val:
            MathApp._addSelectable(self)
        else:
            MathApp._removeSelectable(self)

    @property
    def strokable(self):
        return self._strokable
        
    @strokable.setter
    def strokable(self, val):
        self._strokable = val
        if val:
            MathApp._addStrokable(self)
        else:
            MathApp._removeStrokable(self)

    def select(self):
        self.selected = True


    def unselect(self):
        self.selected = False
        
    def mousedown(self):
        self.mouseisdown = True
        
    def mouseup(self):
        self.mouseisdown = False

    def processEvent(self, event):
        pass

    # define how your class responds to mouse clicks - returns True/False
    @abstractmethod
    def physicalPointTouching(self, ppos):
        pass
    
    # define how your class responds to being moved (physical units)
    @abstractmethod
    def translate(self, pdisp):
        pass
    
    # define how your class responds to being stroked (physical units)
    def stroke(self, ppos, pdisp):
        pass
    
    # is the mousedown in a place that will result in a stroke?
    def canstroke(self, ppos):
        return False
    
    def _touchAsset(self, force = False):
        inputs = self._getInputs()
        changed = self._inputsChanged(inputs)
        if changed:
            self._saveInputs(inputs)
        if changed or force:
            self._updateAsset(self._buildAsset())

    
    @abstractmethod
    def _buildAsset(self):
        pass
    

class Label(_MathVisual):
    
    posinputsdef = ['pos']
    nonposinputsdef = ['text']
    
    def __init__(self, *args, **kwargs):
        """
        Required Inputs
        
        * **pos** position of label
        * **text** text contents of label
        """
        super().__init__(TextAsset(""), *args, **kwargs)
        self._touchAsset()

    def _buildAsset(self):
        return TextAsset(self.nposinputs.text(), 
                            style="{0}px Courier".format(self.stdinputs.size()),
                            width=self.stdinputs.width(),
                            fill=self.stdinputs.color())

    def __call__(self):
        return self.nposinputs.text()

    def physicalPointTouching(self, ppos):
        _ppos = self.spposinputs.pos
        return (ppos[0] >= _ppos[0] and 
            ppos[0] <= _ppos[0] + self.sstdinputs.width and
            ppos[1] >= _ppos[1] and 
            ppos[1] <= _ppos[1] + self.sstdinputs.size)

    def translate(self, pdisp):
        pass


class InputNumeric(Label):
    
    def __init__(self, pos, val, **kwargs):
        """
        Required Inputs
        
        * **pos** position of button
        * **val** initial value of input
        
        Optional Keyword Input
        * **fmt** a Python format string (default is {0.2})
        """
        self._fmt = kwargs.get('fmt', '{0.2}')
        self._val = self.Eval(val)()  # initialize to simple numeric
        self._savedval = self._val
        self._updateText()
        super().__init__(pos, self._textValue, **kwargs)
        self.selectable = True
        
    def _textValue(self):
        return self._text()

    def _updateText(self):
        self._text = self.Eval(self._fmt.format(self._val))

    def processEvent(self, event):
        if event.key in "0123456789insertdelete":
            key = event.key
            if event.key == 'insert':
                key = '-'
            elif event.key == 'delete':
                key = '.'
            if self._text() == "0":
                self._text = self.Eval("")
            self._text = self.Eval(self._text() + key)
            self._touchAsset()
        elif event.key in ['enter','escape']:
            if event.key == 'enter':
                try:
                    self._val = float(self._text())
                except ValueError:
                    self._val = self._savedval
                self._savedval = self._val
            self.unselect()
            

    def select(self):
        super().select()
        self._savedval = self._val
        self._val = 0
        self._updateText()
        self._touchAsset()
        MathApp.listenKeyEvent("keypress", "*", self.processEvent)

    def unselect(self):
        super().unselect()
        self._val = self._savedval
        self._updateText()
        self._touchAsset()
        try:
            MathApp.unlistenKeyEvent("keypress", "*", self.processEvent)
        except ValueError:
            pass

    def __call__(self):
        return self._val


class InputButton(Label):
    
    def __init__(self, callback, *args,  **kwargs):
        """
        Required Inputs
        
        * **pos** position of button
        * **text** text of button
        * **callback** reference of a function to execute, passing this button object
        """
        super().__init__(*args, **kwargs)
        self._touchAsset()
        self._callback = callback
        self.selectable = True

    def _buildAsset(self):
        return TextAsset(self.nposinputs.text(), 
                            style="bold {0}px Courier".format(self.stdinputs.size()),
                            width=self.stdinputs.width(),
                            fill=self.stdinputs.color())

    def select(self):
        super().select()
        if self._callback: self._callback(self)
        self.unselect()

    def unselect(self):
        super().unselect()


        
class _Point(_MathVisual, metaclass=ABCMeta):

    posinputsdef = ['pos']
    nonposinputsdef = []

    def __init__(self, asset, *args, **kwargs):
        """
        Required Inputs
        
        * **asset** asset object to use
        * **pos** position of point
        """
        super().__init__(asset, *args, **kwargs)
        self._touchAsset()
        self.center = (0.5, 0.5)

    def __call__(self):
        return self.posinputs.pos()

    def step(self):
        pass  # FIXME
        self._touchAsset()

    def physicalPointTouching(self, ppos):
        return MathApp.distance(ppos, self.pposinputs.pos) < self.sstdinputs.size
        
    def translate(self, pdisp):
        ldisp = MathApp.translatePhysicalToLogical(pdisp)
        pos = self.posinputs.pos()
        self.posinputs = self.posinputs._replace(pos=self.Eval((pos[0] + ldisp[0], pos[1] + ldisp[1])))
        self._touchAsset()
        
    def distanceTo(self, otherpoint):
        try:
            pos = self.posinputs.pos
            opos = otherpoint.posinputs.pos
            return MathApp.distance(pos, opos())
        except AttributeError:
            return otherpoint  # presumably a scalar - use this distance




class Point(_Point):


    defaultsize = 5
    defaultstyle = LineStyle(0, Color(0, 1))


    def __init__(self, *args, **kwargs):
        """
        Required Inputs
        
        * **pos** position of point
        """
        super().__init__(CircleAsset(self.defaultsize, 
            self.defaultstyle, self.defaultcolor), *args, **kwargs)


    def _buildAsset(self):
        return CircleAsset(self.stdinputs.size(),
                            self.stdinputs.style(),
                            self.stdinputs.color())



class ImagePoint(_Point):


    def __init__(self, url, *args, **kwargs):
        """
        Required Inputs
        
        * **url** location of image file
        * **pos** position of point
        
        Optional Inputs
        * **frame** sub-frame location of image within file
        * **qty** number of sub-frames, when used as sprite sheet
        * **direction** one of 'horizontal' (default) or 'vertical'
        * **margin** pixels between sub-frames if sprite sheet
        """
        frame = kwargs.get('frame', None)
        qty = kwargs.get('qty', 1)
        direction = kwargs.get('direction', 'horizontal')
        margin = kwargs.get('margin', 0)
        self._imageasset = ImageAsset(url, frame, qty, direction, margin)
        super().__init__(self._imageasset, *args, **kwargs)


    def _buildAsset(self):
        return self._imageasset

    def physicalPointTouching(self, ppos):
        self._setExtents()  # ensure xmin, xmax are correct
        x, y = ppos
        return x >= self.xmin and x < self.xmax and y >= self.ymin and y <= self.ymax


class InputImageButton(ImagePoint):
    
    def __init__(self, url, callback, *args, **kwargs):
        """
        Required Inputs
        
        * **url** location of image file
        * **callback** reference of a function to execute, passing this button object
        * **pos** position of point
        
        Optional Inputs
        * **frame** sub-frame location of image within file
        * **qty** number of sub-frames, when used as sprite sheet
        * **direction** one of 'horizontal' (default) or 'vertical'
        * **margin** pixels between sub-frames if sprite sheet
        """
        super().__init__(url, *args, **kwargs)
        self.center = (0,0)
        self._callback = callback
        self.selectable = True
        self.firstImage()
        self.mousewasdown = self.mouseisdown

    def select(self):
        super().select()
        if self._callback: self._callback(self)
        self.unselect()

    def unselect(self):
        super().unselect()

    def __call__(self):
        # code for controlling the button image state only works if the
        # button state is being monitored!
        if self.mouseisdown != self.mousewasdown:
            if self.mouseisdown:
                self.nextImage()
            else:
                self.firstImage()
            self.mousewasdown = self.mouseisdown
        return self.mouseisdown
        

class InputImageToggle(ImagePoint):

    def __init__(self, url, statelist, initindex, *args, **kwargs):
        """
        Required Inputs
        
        * **url** location of image file
        * **statelist** list of values to correspond with toggle states
        * **initindex** index to initial toggle state
        * **pos** position of point
        
        Optional Inputs
        * **frame** sub-frame location of image within file
        * **direction** for sprite sheet one of 'horizontal' (default) or 'vertical'
        * **margin** pixels between sub-frames if sprite sheet
        * Note the qty of images is equal to length of the statelist
        """
        self.statelist = statelist
        kwargs.setdefault('qty', len(statelist))
        super().__init__(url, *args, **kwargs)
        self.center = (0,0)
        self.selectable = True
        self.togglestate = initindex
        self.setImage(self.togglestate)

    def select(self):
        super().select()
        self.togglestate += 1
        if self.togglestate == len(self.statelist):
            self.togglestate = 0
        self.setImage(self.togglestate)
        self.unselect()

    def __call__(self):
        return self.statelist[self.togglestate]
    
    
class MetalToggle(InputImageToggle):
    def __init__(self, initindex, *args, **kwargs):
        """
        Required Inputs
        
        * **initindex** index to initial toggle state
        * **pos** position of toggle
        """
        kwargs.setdefault('frame', Frame(0,0,110,150))
        super().__init__("toggle-up-down.png", [True, False], initindex, *args, **kwargs)
        self.scale = 0.4
        


class GlassButton(InputImageButton):
    
    def __init__(self, callback, *args, **kwargs):
        """
        Required Inputs
        
        * **callback** reference of a function to execute, passing this button object
        * **pos** position of point
        """        
        kwargs.setdefault('frame', Frame(0,0,100,100))
        kwargs.setdefault('qty', 2)
        super().__init__("button-round.png", callback, *args, **kwargs)
        self.scale = 0.3
        
        


class ImageIndicator(_MathVisual):

    posinputsdef = ['pos']
    nonposinputsdef = ['value']

    def __init__(self, url, *args, **kwargs):
        """
        Required Inputs
        
        * **url** location of image file consisting of two image sprite sheet
        * **pos** position of point
        * **value** state of the indicator (True/False or integer)

        Optional Inputs
        * **frame** sub-frame location of image within file
        * **qty** number of sub-frames, when used as sprite sheet
        * **direction** one of 'horizontal' (default) or 'vertical'
        * **margin** pixels between sub-frames if sprite sheet
        """
        kwargs.setdefault('frame', None)
        kwargs.setdefault('qty', 1)
        kwargs.setdefault('direction', 'horizontal')
        kwargs.setdefault('margin', 0)
        super().__init__(
            ImageAsset(url, 
                kwargs['frame'], 
                kwargs['qty'], 
                kwargs['direction'], 
                kwargs['margin']), 
            *args, **kwargs)
        self.center = (0,0)

    def _buildAsset(self):
        inval = self.nposinputs.value()
        if inval == True:
            self.setImage(1)
        elif inval == False:
            self.setImage(0)
        else:
            self.setImage(inval)
        return self.asset

    def physicalPointTouching(self, ppos):
        self._setExtents()  # ensure xmin, xmax are correct
        x, y = ppos
        return x >= self.xmin and x < self.xmax and y >= self.ymin and y <= self.ymax

    def translate(self, pdisp):
        pass


class LEDIndicator(ImageIndicator):
    
    def __init__(self, *args, **kwargs):
        """
        Required Inputs
        
        * **pos** position of point
        * **value** state of the indicator (True/False or integer)

        """
        kwargs.setdefault('frame', Frame(0,0,600,600))
        kwargs.setdefault('qty', 2)
        super().__init__("red-led-off-on.png", *args, **kwargs)
        self.scale = 0.05


class LineSegment(_MathVisual):
    
    posinputsdef = ['pos','end']
    
    def __init__(self, *args, **kwargs):
        """
        Required Inputs
        
        * **pos** start position of segment
        * **end** end position of segment
        
        Optional Inputs
        
        * **style** line style (thickness, color)
        """
        super().__init__(LineAsset(0,0, self.defaultstyle), *args, **kwargs)
        self._touchAsset()
        
    def _buildAsset(self):
        start = self.pposinputs.pos
        end = self.pposinputs.end
        self.position = start
        return LineAsset(end[0]-start[0],
                            end[1]-start[1],
                            self.stdinputs.style())

    def physicalPointTouching(self, ppos):
        return False

    def translate(self, pdisp):
        pass



class Circle(_MathVisual):
    
    posinputsdef = ['pos']
    nonposinputsdef = ['radius']
    defaultcolor = Color(0,0)
    
    def __init__(self, *args, **kwargs):
        """
        Required Inputs
        
        * **pos** center of circle
        * **radius** radius of circle (logical) or point on circle
        
        Optional Inputs
        
        * **style** border line style (thickness, color)
        * **color** fill color
        """
        """
        Radius may be scalar or point
        """
        super().__init__(CircleAsset(0, self.defaultstyle, self.defaultcolor), *args, **kwargs)
        self._touchAsset()
        self.fxcenter = self.fycenter = 0.5


    def _buildAsset(self):
        pcenter = self.spposinputs.pos
        try: 
            pradius = MathApp.distance(self.posinputs.pos(), self.nposinputs.radius()) * MathApp._scale
        except (AttributeError, TypeError):
            pradius = self.nposinputs.radius() * MathApp._scale
        style = self.stdinputs.style()
        fill = self.stdinputs.color()
        ymax = pcenter[1]+pradius
        ymin = pcenter[1]-pradius
        xmax = pcenter[0]+pradius
        xmin = pcenter[0]-pradius
        try:
            if ymin > MathApp.height or ymax < 0 or xmax < 0 or xmin > MathApp.width:
                return CircleAsset(pradius, style, fill)
            elif pradius > 2*MathApp.width:
                # here begins unpleasant hack to overcome crappy circles
                poly = self._buildPolygon(pcenter, pradius)
                if len(poly):
                    passet = PolygonAsset(poly, style, fill)
                    return passet
        except AttributeError:
            return CircleAsset(pradius, style, fill)
        return CircleAsset(pradius, style, fill)

    def _buildPolygon(self, pcenter, pradius):
        """
        pcenter is in screen relative coordinates.
        returns a coordinate list in circle relative coordinates
        """
        xcepts = [self._findIntercepts(pcenter, pradius, 0,0,0,MathApp.height),
            self._findIntercepts(pcenter, pradius, 0,0,MathApp.width,0),
            self._findIntercepts(pcenter, pradius, MathApp.width,0,MathApp.width,MathApp.height),
            self._findIntercepts(pcenter, pradius, 0,MathApp.height, MathApp.width, MathApp.height)]
        ilist = []
        for x in xcepts:
            if x and len(x) < 2:
                ilist.extend(x)
        #ilist is a list of boundary intercepts that are screen-relative
        if len(ilist) > 1:
            xrange = ilist[-1][0] - ilist[0][0]
            yrange = ilist[-1][1] - ilist[0][1]
            numpoints = 20
            inx = 0
            for i in range(numpoints):
                icepts =  self._findIntercepts(pcenter, pradius, 
                    pcenter[0], pcenter[1], 
                    ilist[0][0] + xrange*(i+1)/(numpoints+1),
                    ilist[0][1] + yrange*(i+1)/(numpoints+1))
                if len(icepts):
                    ilist.insert(inx+1, icepts[0])
                    inx = inx + 1
            self._addBoundaryVertices(ilist, pcenter, pradius)
            ilist.append(ilist[0])
            ilist = [(i[0] - pcenter[0], i[1] - pcenter[1]) for i in ilist]
        return ilist
        
    def _addBoundaryVertices(self, plist, pcenter, pradius):
        """
        Sides 0=top, 1=right, 2=bottom, 3=left
        """
        #figure out rotation in point sequence
        cw = 0
        try:
            rtst = plist[0:3]+[plist[0]]
            for p in range(3):
                cw = cw + (rtst[p+1][0]-rtst[p][0])*(rtst[p+1][1]+rtst[p][1])
        except IndexError:
            #print(plist)
            return
        cw = self._sgn(cw)
        cw = 1 if cw < 0 else 0
        vertices = ((-100,-100),
            (MathApp.width+100,-100),
            (MathApp.width+100,MathApp.height+100),
            (-100,MathApp.height+100))
        nextvertex = [(vertices[0],vertices[1]),
                        (vertices[1],vertices[2]),
                        (vertices[2],vertices[3]),
                        (vertices[3],vertices[0])]
        nextsides = [(3,1),(0,2),(1,3),(2,0)]
        edges = ((None,0),(MathApp.width,None),(None,MathApp.height),(0,None))
        endside = startside = None
        for side in range(4):
            if endside is None and (edges[side][0] == round(plist[-1][0]) or edges[side][1] == round(plist[-1][1])):
                endside = side
            if startside is None and (edges[side][0] == round(plist[0][0]) or edges[side][1] == round(plist[0][1])):
                startside = side
        iterations = 0
        while startside != endside:
            iterations = iterations + 1
            if iterations > 20:
                break
            if endside != None and startside != None:   #  and endside != startside
                plist.append(nextvertex[endside][cw])
                endside = nextsides[endside][cw]

    def _sgn(self, x):
        return 1 if x >= 0 else -1

    def _findIntercepts(self, c, r, x1, y1, x2, y2):
        """
        c (center) and x and y values are physical, screen relative.
        function returns coordinates in screen relative format
        """
        x1n = x1 - c[0]
        x2n = x2 - c[0]
        y1n = y1 - c[1]
        y2n = y2 - c[1]
        dx = x2n-x1n
        dy = y2n-y1n
        dr = sqrt(dx*dx + dy*dy)
        D = x1n*y2n - x2n*y1n
        disc = r*r*dr*dr - D*D
        dr2 = dr*dr
        if disc <= 0:  # less than two solutions
            return []
        sdisc = sqrt(disc)
        x = [(D*dy + self._sgn(dy)*dx*sdisc)/dr2 + c[0],  (D*dy - self._sgn(dy)*dx*sdisc)/dr2 + c[0]]
        y = [(-D*dx + abs(dy)*sdisc)/dr2 + c[1], (-D*dx - abs(dy)*sdisc)/dr2 + c[1]]
        getcoords = lambda x, y, c: [(x,y)] if x>=0 and x<=MathApp.width and y>=0 and y<=MathApp.height else []
        res = getcoords(x[0], y[0], c)
        res.extend(getcoords(x[1], y[1], c))
        return res


    @property
    def center(self):
        return self._center()

    @center.setter
    def center(self, val):
        newval = self.Eval(val)
        if newval != self._center:
            self._center = newval
            self._touchAsset()

    @property
    def radius(self):
        return self._radius()

    @radius.setter
    def radius(self, val):
        newval = self.Eval(val)
        if newval != self._radius:
            self._radius = newval
            self._touchAsset()
        
    def step(self):
        self._touchAsset()

    def physicalPointTouching(self, ppos):
        r = MathApp.distance(self._pcenter, ppos)
        inner = self._pradius - self.style.width/2
        outer = self._pradius + self.style.width/2
        return r <= outer and r >= inner

    def translate(self, pdisp):
        pass





class Slider(_MathVisual):
    
    posinputsdef = ['pos']
    nonposinputsdef = ['minval','maxval','initial']

    def __init__(self, *args, **kwargs):
        super().__init__(
            RectangleAsset(1, 1), *args, **kwargs)
        self._val = self.nposinputs.initial()
        self._steps = kwargs.get('steps', 50)
        self._step = (self.nposinputs.maxval()-self.nposinputs.minval())/self._steps
        self._leftctrl = kwargs.get('leftkey', None)
        self._rightctrl = kwargs.get('rightkey', None)
        self._centerctrl = kwargs.get('centerkey', None)
        self.selectable = True  # must be after super init!
        self.strokable = True  # this enables grabbing/slideing the thumb
        self.thumbcaptured = False
        self._thumbwidth = max(self.stdinputs.width()/40, 1)
        self.thumb = Sprite(RectangleAsset(self._thumbwidth, 
            self.stdinputs.size()-2, LineStyle(1, self.stdinputs.color()), self.stdinputs.color()), 
            self.thumbXY())
        self._touchAsset()
        if self._leftctrl:
            MathApp.listenKeyEvent("keydown", self._leftctrl, self.moveLeft)
        if self._rightctrl:
            MathApp.listenKeyEvent("keydown", self._rightctrl, self.moveRight)
        if self._centerctrl:
            MathApp.listenKeyEvent("keydown", self._centerctrl, self.moveCenter)

    def thumbXY(self):
        minval = self.nposinputs.minval()
        maxval = self.nposinputs.maxval()
        return (self.spposinputs.pos[0]+(self._val-minval)*
                (self.sstdinputs.width-self._thumbwidth)/(maxval-minval),
                self.spposinputs.pos[1]+1)
            
    def __call__(self):
        return self._val

    @property
    def value(self):
        return self._val
        
    @value.setter
    def value(self, val):
        self._setval(val)

    def _buildAsset(self):
        self.setThumb()
        return RectangleAsset(
            self.stdinputs.width(), self.stdinputs.size(), 
            line=self.stdinputs.style(), fill=Color(0,0))

    def setThumb(self):
        self.thumb.position = self.thumbXY()
                
    def step(self):
        pass
    
    def _setval(self, val):
        minval = self.nposinputs.minval()
        maxval = self.nposinputs.maxval()
        if val <= minval:
            self._val = minval
        elif val >= maxval:
            self._val = maxval
        else:
            self._val = round((val - minval)*self._steps/(maxval-minval))*self._step + minval
        self.setThumb()
        
    def increment(self, step):
        self._setval(self._val + step)
        
    def select(self):
        super().select()
        if not self._leftctrl:
            MathApp.listenKeyEvent("keydown", "left arrow", self.moveLeft)
        if not self._rightctrl:
            MathApp.listenKeyEvent("keydown", "right arrow", self.moveRight)
        MathApp.listenMouseEvent("click", self.mouseClick)

    def unselect(self):
        super().unselect()
        try:
            if not self._leftctrl:
                MathApp.unlistenKeyEvent("keydown", "left arrow", self.moveLeft)
            if not self._rightctrl:
                MathApp.unlistenKeyEvent("keydown", "right arrow", self.moveRight)
            MathApp.unlistenMouseEvent("click", self.mouseClick)
        except ValueError:
            pass

    def mouseClick(self, event):
        if self.physicalPointTouching((event.x, event.y)):
            if event.x > self.thumb.x + self._thumbwidth:
                self.moveRight(event)
            elif event.x < self.thumb.x:
                self.moveLeft(event)
                
    def moveLeft(self, event):
        self.increment(-self._step)

    def moveRight(self, event):
        self.increment(self._step)
        
    def moveCenter(self, event):
        self._val = (self.snposinputs.minval + self.snposinputs.maxval)/2
        self.setThumb()
        
    def canstroke(self, ppos):
        return self.physicalPointTouchingThumb(ppos)
        
    def stroke(self, ppos, pdisp):
        _ppos = self.spposinputs.pos
        minval = self.snposinputs.minval
        maxval = self.snposinputs.maxval
        xpos = ppos[0] + pdisp[0]
        self.value = (xpos - _ppos[0])*(maxval-minval)/self.sstdinputs.width + minval

    def physicalPointTouching(self, ppos):
        _ppos = self.spposinputs.pos
        return (ppos[0] >= _ppos[0] and 
            ppos[0] <= _ppos[0] + self.sstdinputs.width and
            ppos[1] >= _ppos[1] and 
            ppos[1] <= _ppos[1] + self.sstdinputs.size)

    def physicalPointTouchingThumb(self, ppos):
        thumbpos = self.thumbXY()
        return (ppos[0] >= thumbpos[0] and 
            ppos[0] <= thumbpos[0] + self._thumbwidth + 2 and
            ppos[1] >= thumbpos[1] and 
            ppos[1] <= thumbpos[1] + self.sstdinputs.size - 2)

    def translate(self, pdisp):
        pass

    
class Timer(_MathDynamic):
    
    def __init__(self):
        super().__init__()
        self.once = []
        self.callbacks = {}
        self.reset()
        self.step()
        self._start = self._reset  #first time
        self.next = None
        MathApp._addDynamic(self)  # always dynamically defined
        
    def reset(self):
        self._reset = MathApp.time
        
    def step(self):
        nexttimers = []
        calllist = []
        self.time = MathApp.time - self._reset
        while self.once and self.once[0][0] <= MathApp.time:
            tickinfo = self.once.pop(0)
            if tickinfo[1]:  # periodic?
                nexttimers.append((tickinfo[1], self.callbacks[tickinfo][0]))  # delay, callback
            calllist.append(self.callbacks[tickinfo].pop(0)) # remove callback and queue it
            if not self.callbacks[tickinfo]: # if the callback list is empty
                del self.callbacks[tickinfo] # remove the dictionary entry altogether
        for tickadd in nexttimers:
            self.callAfter(tickadd[0], tickadd[1], True)  # keep it going
        for call in calllist:
            call(self)

    def callAfter(self, delay, callback, periodic=False):
        key = (MathApp.time + delay, delay if periodic else 0)
        self.once.append(key)
        callbacklist = self.callbacks.get(key, [])
        callbacklist.append(callback)
        self.callbacks[key] = callbacklist
        self.once.sort()
        
    def callAt(self, time, callback):
        self.callAfter(time-self.time, callback)
        
    def callEvery(self, period, callback):
        self.callAfter(period, callback, True)

    def __call__(self):
        return self.time


class Bunny():
    
    """Bunny class is similar to turtle. Needs refinement.
    
    Example use:
    
        b = Bunny()
        b.PenDown()
        for i in range(100):
            b.Right(1.5)
            b.Move(i/25)

    """
    
    def __init__ (self):
        self.GoTo(0,0)
        self.Color(0)
        self.PenUp() 
        self.SetAngle(0)

    def PenUp(self):
        self.down = False

    def PenDown(self):
        self.down = True
        
    def Color(self, color):
        self.color = Color(color,1)
        
    def GoTo(self, x, y):
        self.pos = (x,y)
        
    def SetAngle(self, a):
        self.angle = a
        
    def Right(self, da):
        self.angle = self.angle - da
        
    def Left(self, da):
        self.angle = self.angle + da
        
    def Move(self, d):
        next = (self.pos[0] + d*cos(self.angle), self.pos[1] + d*sin(self.angle))
        LineSegment(Point(self.pos, 0), Point(next, 0), LineStyle(1, self.color))
        self.pos = next

    #def physicalPointTouching(self, ppos):
    #    return MathApp.distance(ppos, self._ppos) < self._size
        
    #def translate(self, pdisp):
    #    ldisp = MathApp.translatePhysicalToLogical(pdisp)
    #    pos = self._pos()
    #    self._pos = self.Eval((pos[0] + ldisp[0], pos[1] + ldisp[1]))
    #    self._touchAsset()


class MathApp(App):
    
    _scale = 200   # pixels per unit
    _xcenter = 0    # center of screen in units
    _ycenter = 0    
    _mathVisualList = [] #
    _mathDynamicList = []
    _mathMovableList = []
    _mathSelectableList = []
    _mathStrokableList = []
    _viewNotificationList = []
    time = time()
    
    def __init__(self, scale=_scale):
        super().__init__()
        MathApp.width = self.width
        MathApp.height = self.height
        MathApp._scale = scale   # pixels per unit
        # register event callbacks
        self.listenMouseEvent("click", self.handleMouseClick)
        self.listenMouseEvent("mousedown", self.handleMouseDown)
        self.listenMouseEvent("mouseup", self.handleMouseUp)
        self.listenMouseEvent("mousemove", self.handleMouseMove)
        self.listenMouseEvent("wheel", self.handleMouseWheel)
        self.mouseDown = False
        self.mouseCapturedObject = None
        self.mouseStrokedObject = None
        self.mouseDownObject = None
        self.mouseX = self.mouseY = None
        self._touchAllVisuals()
        self.selectedObj = None
        MathApp.time = time()

    def step(self):
        MathApp.time = time()
        for spr in self._mathDynamicList:
            spr.step()

    def _touchAllVisuals(self):
        # touch all visual object assets to use scaling
        for obj in self._mathVisualList:
            obj._touchAsset(True)


    @classmethod
    def logicalToPhysical(cls, lp):
        xxform = lambda xvalue, xscale, xcenter, physwidth: int((xvalue-xcenter)*xscale + physwidth/2)
        yxform = lambda yvalue, yscale, ycenter, physheight: int(physheight/2 - (yvalue-ycenter)*yscale)

        try:
            return (xxform(lp[0], cls._scale, cls._xcenter, cls._win.width),
                yxform(lp[1], cls._scale, cls._ycenter, cls._win.height))
        except AttributeError:
            return lp
            
    @classmethod
    def physicalToLogical(cls, pp):
        xxform = lambda xvalue, xscale, xcenter, physwidth: (xvalue - physwidth/2)/xscale + xcenter
        yxform = lambda yvalue, yscale, ycenter, physheight: (physheight/2 - yvalue)/yscale + ycenter

        try:
            return (xxform(pp[0], cls._scale, cls._xcenter, cls._win.width),
                yxform(pp[1], cls._scale, cls._ycenter, cls._win.height))
        except AttributeError:
            return pp
            
    @classmethod
    def translatePhysicalToLogical(cls, pp):
        xxform = lambda xvalue, xscale: xvalue/xscale
        yxform = lambda yvalue, yscale: -yvalue/yscale

        try:
            return (xxform(pp[0], cls._scale), yxform(pp[1], cls._scale))
        except AttributeError:
            return pp

    @classmethod
    def translateLogicalToPhysical(cls, pp):
        xxform = lambda xvalue, xscale: xvalue*xscale
        yxform = lambda yvalue, yscale: -yvalue*yscale

        try:
            return (xxform(pp[0], cls._scale), yxform(pp[1], cls._scale))
        except AttributeError:
            return pp

    def handleMouseClick(self, event):
        found = False
        for obj in self._mathSelectableList:
            if obj.physicalPointTouching((event.x, event.y)):
                found = True
                if not obj.selected: 
                    obj.select()
                    self.selectedObj = obj
        if not found and self.selectedObj:
            self.selectedObj.unselect()
            self.selectedObj = None

    def handleMouseDown(self, event):
        self.mouseDown = True
        self.mouseCapturedObject = None
        self.mouseStrokedObject = None
        for obj in self._mathSelectableList:
            if obj.physicalPointTouching((event.x, event.y)):
                obj.mousedown()
                self.mouseDownObject = obj
                break
        for obj in self._mathMovableList:
            if obj.physicalPointTouching((event.x, event.y)) and not (obj.strokable and obj.canstroke((event.x,event.y))):
                self.mouseCapturedObject = obj
                break
        if not self.mouseCapturedObject:
            for obj in self._mathStrokableList:
                if obj.canstroke((event.x, event.y)):
                    self.mouseStrokedObject = obj
                    break

    def handleMouseUp(self, event):
        if self.mouseDownObject:
            self.mouseDownObject.mouseup()
            self.mouseDownObject = None
        self.mouseDown = False
        self.mouseCapturedObject = None
        self.mouseStrokedObject = None

    def handleMouseMove(self, event):
        if not self.mouseX:
            self.mouseX = event.x
            self.mouseY = event.y
        dx = event.x - self.mouseX
        dy = event.y - self.mouseY
        self.mouseX = event.x
        self.mouseY = event.y
        if self.mouseDown:
            if self.mouseCapturedObject:
                self.mouseCapturedObject.translate((dx, dy))
            elif self.mouseStrokedObject:
                self.mouseStrokedObject.stroke((self.mouseX,self.mouseY), (dx,dy))
            else:
                lmove = self.translatePhysicalToLogical((dx, dy))
                MathApp._xcenter -= lmove[0]
                MathApp._ycenter -= lmove[1]
                self._touchAllVisuals()
                self._viewNotify("translate")
    
    @property
    def viewPosition(self):
        return (MathApp._xcenter, MathApp._ycenter)
        
    @viewPosition.setter
    def viewPosition(self, pos):
        MathApp._xcenter, MathApp._ycenter = pos
        self._touchAllVisuals()
        self._viewNotify("translate")
        
    def handleMouseWheel(self, event):
        zoomfactor = event.wheelDelta/100
        zoomfactor = 1+zoomfactor if zoomfactor > 0 else 1+zoomfactor
        if zoomfactor > 1.2:
            zoomfactor = 1.2
        elif zoomfactor < 0.8:
            zoomfactor = 0.8
        MathApp._scale *= zoomfactor
        self._touchAllVisuals()
        self._viewNotify("zoom")
        
    @classmethod   
    def addViewNotification(cls, handler):
        cls._viewNotificationList.append(handler)
        
    @classmethod   
    def removeViewNotification(cls, handler):
        cls._viewNotificationList.remove(handler)
    
    def _viewNotify(self, viewchange):
        for handler in self._viewNotificationList:
            handler(viewchange = viewchange, scale = self._scale, center = (self._xcenter, self._ycenter))
        
     
    @classmethod   
    def distance(cls, pos1, pos2):
        return sqrt((pos2[0]-pos1[0])**2 + (pos2[1]-pos1[1])**2)
        
    @property
    def scale(self):
        return self._scale
        
    @property
    def width(cls):
        return App._win.width
            
    @classmethod
    def _addVisual(cls, obj):
        """ FIX ME """
        if isinstance(obj, _MathVisual):
            cls._mathVisualList.append(obj)
            
    @classmethod
    def _removeVisual(cls, obj):
        if isinstance(obj, _MathVisual) and obj in cls._mathVisualList:
            cls._mathVisualList.remove(obj)

    @classmethod
    def _addDynamic(cls, obj):
        if isinstance(obj, _MathDynamic) and not obj in cls._mathDynamicList:
            cls._mathDynamicList.append(obj)
            
    @classmethod
    def _removeDynamic(cls, obj):
        if isinstance(obj, _MathDynamic) and obj in cls._mathDynamicList:
            cls._mathDynamicList.remove(obj)

    @classmethod
    def _addMovable(cls, obj):
        if isinstance(obj, _MathVisual) and not obj in cls._mathMovableList:
            cls._mathMovableList.append(obj)
            
    @classmethod
    def _removeMovable(cls, obj):
        if isinstance(obj, _MathVisual) and obj in cls._mathMovableList:
            cls._mathMovableList.remove(obj)

    @classmethod
    def _addSelectable(cls, obj):
        if isinstance(obj, _MathVisual) and not obj in cls._mathSelectableList:
            cls._mathSelectableList.append(obj)
            
    @classmethod
    def _removeSelectable(cls, obj):
       if isinstance(obj, _MathVisual)  and obj in cls._mathSelectableList:
            cls._mathSelectableList.remove(obj)

    @classmethod
    def _addStrokable(cls, obj):
        if isinstance(obj, _MathVisual) and not obj in cls._mathStrokableList:
            cls._mathStrokableList.append(obj)
            
    @classmethod
    def _removeStrokable(cls, obj):
        if isinstance(obj, _MathVisual) and obj in cls._mathStrokableList:
            cls._mathStrokableList.remove(obj)

    @classmethod
    def _destroy(cls, *args):
        """
        This will clean up any class level storage.
        """ 
        App._destroy(*args)  # hit the App class first
        MathApp._mathVisualList = [] 
        MathApp._mathDynamicList = []
        MathApp._mathMovableList = []
        MathApp._mathSelectableList = []
        MathApp._mathStrokableList = []
        MathApp._viewNotificationList = []
        



# test code here
if __name__ == "__main__":
    
    
    """
    
    index = 0
    coordlist = [(1,1), (2,1), (2,0), (1,2), (1,1)]
    
    def nextcoord():
        global index
        if index == len(coordlist):
            index = 0
        retval = coordlist[index]
        index = index + 1
        return retval
        
    def one(t):
        print("one")
        
    def two(t):
        print("two")
        
    def three(t):
        t.callAt(10, ten)
        print("three")
    
    def ten(t):
        print("ten")
        
    def tick(t):
        print("tick")
        
    #pm1 = PointMass((0.1,0))
    
    def rotate(timer):
        ip1.rotation += 0.01
    



    #p1 = Point((0,0))
    #p1.movable = True
    #c1 = Circle(p1, 1.5, LineStyle(3, Color(0x0000ff,1)), Color(0x0000ff,0.3))
    
    #s1 = Slider((200, 400), 0, 10, 2, positioning='physical',
    #    leftkey="a", rightkey="d", centerkey="s")
    
    #p2 = Point((2,0))
    #p2.movable = True
    #p3 = Point((3,0))

    #t = Timer()
    #p4 = Point(lambda :(3, (int(t.time*100) % 400)/100))
    
    #p5 = Point(lambda :nextcoord())

    #ip1 = ImagePoint((0.1,0), 'bunny.png')


    
    #LineSegment(p1,p4)

    #l1 = Label((-4,2), lambda: "Elapsed Time: {0:.0}".format(t.time), size=20, width=400, positioning="logical")
    #i1 = InputNumeric((200,300), 99.9, size=20, positioning="physical")
    #l2 = Label((-4,1), lambda: "{0}".format(i1()), size=20)
    #l3 = Label((-4,1), lambda: "{0:4.2f}".format(s1()), size=20)
    #b1 = InputButton((200,350), "RESET", lambda: t.reset(), size=20, positioning="physical")
    
    
    #t.callAfter(1, one)
    #t.callAfter(2, two)
    #t.callAfter(3, three)
    #t.callAt(10, ten)
    #t.callEvery(1, tick)
    #t.callEvery(0.1, rotate)

    def step(t):
        global vx, vy, x, y
        fx = 0
        fy = mass * g
        ax = thrust()*cos(sat.rotation)
        ay = fy / mass + thrust()*sin(sat.rotation)
        x = x + vx * tick + 0.5 * ax * tick**2
        y = y + vy * tick + 0.5 * ay * tick**2
        vx = vx + ax*tick
        vy = vy + ay*tick
        
        if y < 0:
            y = 0
            vy = 0
            
        vslider.value = vy
        

    def velocitytext():
        return "Velocity: ({0:2.4},{1:2.4})".format(vx,vy)

    def getposition():
        return (x,y)
    
            
    def turnleft(event):
        sat.rotation += 0.01
        
    def turnright(event):
        sat.rotation -= 0.01

    tick = 0.02
    x = 0
    y = 100
    vx = vy = 0
    mass = 1
    g = -9.81
    
    sat = Rocket(getposition)
    sat.rotation = pi/2
    sat.scale = 0.1
    MathApp.listenKeyEvent('keydown', 'left arrow', turnleft)
    MathApp.listenKeyEvent('keydown', 'right arrow', turnright)

    thrust = Slider((100, 100), -50, 50, 0, positioning='physical', steps=200,
        leftkey="down arrow", rightkey="up arrow", centerkey="space")
    vslider = Slider((100, 125), -50, 50, 0, positioning='physical')
    Label((100,150), velocitytext, size=15, positioning="physical")
    #westp = Point((-100000,0))
    #eastp = Point((100000,0))
    #ground = LineSegment(westp, eastp)


    
    #MathApp.addViewNotification(zoomCheck)
    """


    def step(timer):
        print(id(timer))

    def labelcoords():
        return (100 + vslider1(), 175)
        
    def buttoncoords():
        return (300 + vslider1(), 175)
        
    def labelcolor():
        colorval =   vslider1()
        return Color(colorval*256,1)

    def pressbutton(caller):
        print("button pressed: ", caller)

    vslider1 = Slider((100, 150), 0, 250, 125, positioning='physical', steps=10)

    def buttonstatus():
        return "True" if imgbutton() else "False"

    imgbutton = InputImageButton("button-round.png", pressbutton, (0,0), frame=Frame(0,0,100,100), qty=2)
    imgbutton.scale = 0.5

    label = Label(labelcoords, buttonstatus, size=15, positioning="physical", color=labelcolor)
    button = InputButton(pressbutton, buttoncoords, "Press Me", size=15, positioning="physical")
    numinput = InputNumeric((300, 275), 3.14, positioning="physical")

    ip = ImagePoint( 'bunny.png', (0,0))
    ip.movable = True

    p1 = Point((0,0), color=Color(0x008000, 1))
    p1.movable = True
    
    p2 = Point((0,-1))
    
    p3 = Point((1.2,0))
    

    LineSegment(p2,p3, style=LineStyle(3, Color(0,1)))
    LineSegment(p2,p1, style=LineStyle(3, Color(0,1)))
    
    c2 = Circle((-1,-1), p1)
    
    ii = ImageIndicator("red-led-off-on.png", (300,500), imgbutton, positioning="physical", frame=Frame(0,0,600,600), qty=2)
    ii.scale = 0.1
   
    glassbutton = GlassButton(None, (0,-0.5))
    toggle = MetalToggle(0, (0, -1))
    
   
    Li = LEDIndicator((300,450), glassbutton, positioning="physical")
    Lit = LEDIndicator((300,480), toggle, positioning="physical")
   
    def zoomCheck(**kwargs):
        viewtype = kwargs.get('viewchange')
        scale = kwargs.get('scale')
        print(ap.scale)
    
    #pcenter = Point((0, -5000000))
    # c1 = Circle((0,-5000000), 5000000, LineStyle(1, Color(0x008040,1)), Color(0x008400,0.5))


    ap = MathApp()

    #ap.addViewNotification(zoomCheck)
    ap.run()
    
    
    """
    """
    
</code></pre>
  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="ggmath.pi" class="name">var <span class="ident">pi</span></p>
      
  
  <div class="source_cont">
</div>

      </div>


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="ggmath.Bunny" class="name">class <span class="ident">Bunny</span></p>
      
  
    <div class="desc"><p>Bunny class is similar to turtle. Needs refinement.</p>
<p>Example use:</p>
<pre><code>b = Bunny()
b.PenDown()
for i in range(100):
    b.Right(1.5)
    b.Move(i/25)
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Bunny', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Bunny" class="source">
    <pre><code>class Bunny():
    
    """Bunny class is similar to turtle. Needs refinement.
    
    Example use:
    
        b = Bunny()
        b.PenDown()
        for i in range(100):
            b.Right(1.5)
            b.Move(i/25)

    """
    
    def __init__ (self):
        self.GoTo(0,0)
        self.Color(0)
        self.PenUp() 
        self.SetAngle(0)

    def PenUp(self):
        self.down = False

    def PenDown(self):
        self.down = True
        
    def Color(self, color):
        self.color = Color(color,1)
        
    def GoTo(self, x, y):
        self.pos = (x,y)
        
    def SetAngle(self, a):
        self.angle = a
        
    def Right(self, da):
        self.angle = self.angle - da
        
    def Left(self, da):
        self.angle = self.angle + da
        
    def Move(self, d):
        next = (self.pos[0] + d*cos(self.angle), self.pos[1] + d*sin(self.angle))
        LineSegment(Point(self.pos, 0), Point(next, 0), LineStyle(1, self.color))
        self.pos = next
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggmath.Bunny">Bunny</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.Bunny.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Bunny.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Bunny.__init__" class="source">
    <pre><code>def __init__ (self):
    self.GoTo(0,0)
    self.Color(0)
    self.PenUp() 
    self.SetAngle(0)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Bunny.Color">
    <p>def <span class="ident">Color</span>(</p><p>self, color)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Bunny.Color', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Bunny.Color" class="source">
    <pre><code>def Color(self, color):
    self.color = Color(color,1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Bunny.GoTo">
    <p>def <span class="ident">GoTo</span>(</p><p>self, x, y)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Bunny.GoTo', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Bunny.GoTo" class="source">
    <pre><code>def GoTo(self, x, y):
    self.pos = (x,y)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Bunny.Left">
    <p>def <span class="ident">Left</span>(</p><p>self, da)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Bunny.Left', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Bunny.Left" class="source">
    <pre><code>def Left(self, da):
    self.angle = self.angle + da
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Bunny.Move">
    <p>def <span class="ident">Move</span>(</p><p>self, d)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Bunny.Move', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Bunny.Move" class="source">
    <pre><code>def Move(self, d):
    next = (self.pos[0] + d*cos(self.angle), self.pos[1] + d*sin(self.angle))
    LineSegment(Point(self.pos, 0), Point(next, 0), LineStyle(1, self.color))
    self.pos = next
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Bunny.PenDown">
    <p>def <span class="ident">PenDown</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Bunny.PenDown', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Bunny.PenDown" class="source">
    <pre><code>def PenDown(self):
    self.down = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Bunny.PenUp">
    <p>def <span class="ident">PenUp</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Bunny.PenUp', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Bunny.PenUp" class="source">
    <pre><code>def PenUp(self):
    self.down = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Bunny.Right">
    <p>def <span class="ident">Right</span>(</p><p>self, da)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Bunny.Right', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Bunny.Right" class="source">
    <pre><code>def Right(self, da):
    self.angle = self.angle - da
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Bunny.SetAngle">
    <p>def <span class="ident">SetAngle</span>(</p><p>self, a)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Bunny.SetAngle', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Bunny.SetAngle" class="source">
    <pre><code>def SetAngle(self, a):
    self.angle = a
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ggmath.Circle" class="name">class <span class="ident">Circle</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Circle', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Circle" class="source">
    <pre><code>class Circle(_MathVisual):
    
    posinputsdef = ['pos']
    nonposinputsdef = ['radius']
    defaultcolor = Color(0,0)
    
    def __init__(self, *args, **kwargs):
        """
        Required Inputs
        
        * **pos** center of circle
        * **radius** radius of circle (logical) or point on circle
        
        Optional Inputs
        
        * **style** border line style (thickness, color)
        * **color** fill color
        """
        """
        Radius may be scalar or point
        """
        super().__init__(CircleAsset(0, self.defaultstyle, self.defaultcolor), *args, **kwargs)
        self._touchAsset()
        self.fxcenter = self.fycenter = 0.5


    def _buildAsset(self):
        pcenter = self.spposinputs.pos
        try: 
            pradius = MathApp.distance(self.posinputs.pos(), self.nposinputs.radius()) * MathApp._scale
        except (AttributeError, TypeError):
            pradius = self.nposinputs.radius() * MathApp._scale
        style = self.stdinputs.style()
        fill = self.stdinputs.color()
        ymax = pcenter[1]+pradius
        ymin = pcenter[1]-pradius
        xmax = pcenter[0]+pradius
        xmin = pcenter[0]-pradius
        try:
            if ymin > MathApp.height or ymax < 0 or xmax < 0 or xmin > MathApp.width:
                return CircleAsset(pradius, style, fill)
            elif pradius > 2*MathApp.width:
                # here begins unpleasant hack to overcome crappy circles
                poly = self._buildPolygon(pcenter, pradius)
                if len(poly):
                    passet = PolygonAsset(poly, style, fill)
                    return passet
        except AttributeError:
            return CircleAsset(pradius, style, fill)
        return CircleAsset(pradius, style, fill)

    def _buildPolygon(self, pcenter, pradius):
        """
        pcenter is in screen relative coordinates.
        returns a coordinate list in circle relative coordinates
        """
        xcepts = [self._findIntercepts(pcenter, pradius, 0,0,0,MathApp.height),
            self._findIntercepts(pcenter, pradius, 0,0,MathApp.width,0),
            self._findIntercepts(pcenter, pradius, MathApp.width,0,MathApp.width,MathApp.height),
            self._findIntercepts(pcenter, pradius, 0,MathApp.height, MathApp.width, MathApp.height)]
        ilist = []
        for x in xcepts:
            if x and len(x) < 2:
                ilist.extend(x)
        #ilist is a list of boundary intercepts that are screen-relative
        if len(ilist) > 1:
            xrange = ilist[-1][0] - ilist[0][0]
            yrange = ilist[-1][1] - ilist[0][1]
            numpoints = 20
            inx = 0
            for i in range(numpoints):
                icepts =  self._findIntercepts(pcenter, pradius, 
                    pcenter[0], pcenter[1], 
                    ilist[0][0] + xrange*(i+1)/(numpoints+1),
                    ilist[0][1] + yrange*(i+1)/(numpoints+1))
                if len(icepts):
                    ilist.insert(inx+1, icepts[0])
                    inx = inx + 1
            self._addBoundaryVertices(ilist, pcenter, pradius)
            ilist.append(ilist[0])
            ilist = [(i[0] - pcenter[0], i[1] - pcenter[1]) for i in ilist]
        return ilist
        
    def _addBoundaryVertices(self, plist, pcenter, pradius):
        """
        Sides 0=top, 1=right, 2=bottom, 3=left
        """
        #figure out rotation in point sequence
        cw = 0
        try:
            rtst = plist[0:3]+[plist[0]]
            for p in range(3):
                cw = cw + (rtst[p+1][0]-rtst[p][0])*(rtst[p+1][1]+rtst[p][1])
        except IndexError:
            #print(plist)
            return
        cw = self._sgn(cw)
        cw = 1 if cw < 0 else 0
        vertices = ((-100,-100),
            (MathApp.width+100,-100),
            (MathApp.width+100,MathApp.height+100),
            (-100,MathApp.height+100))
        nextvertex = [(vertices[0],vertices[1]),
                        (vertices[1],vertices[2]),
                        (vertices[2],vertices[3]),
                        (vertices[3],vertices[0])]
        nextsides = [(3,1),(0,2),(1,3),(2,0)]
        edges = ((None,0),(MathApp.width,None),(None,MathApp.height),(0,None))
        endside = startside = None
        for side in range(4):
            if endside is None and (edges[side][0] == round(plist[-1][0]) or edges[side][1] == round(plist[-1][1])):
                endside = side
            if startside is None and (edges[side][0] == round(plist[0][0]) or edges[side][1] == round(plist[0][1])):
                startside = side
        iterations = 0
        while startside != endside:
            iterations = iterations + 1
            if iterations > 20:
                break
            if endside != None and startside != None:   #  and endside != startside
                plist.append(nextvertex[endside][cw])
                endside = nextsides[endside][cw]

    def _sgn(self, x):
        return 1 if x >= 0 else -1

    def _findIntercepts(self, c, r, x1, y1, x2, y2):
        """
        c (center) and x and y values are physical, screen relative.
        function returns coordinates in screen relative format
        """
        x1n = x1 - c[0]
        x2n = x2 - c[0]
        y1n = y1 - c[1]
        y2n = y2 - c[1]
        dx = x2n-x1n
        dy = y2n-y1n
        dr = sqrt(dx*dx + dy*dy)
        D = x1n*y2n - x2n*y1n
        disc = r*r*dr*dr - D*D
        dr2 = dr*dr
        if disc <= 0:  # less than two solutions
            return []
        sdisc = sqrt(disc)
        x = [(D*dy + self._sgn(dy)*dx*sdisc)/dr2 + c[0],  (D*dy - self._sgn(dy)*dx*sdisc)/dr2 + c[0]]
        y = [(-D*dx + abs(dy)*sdisc)/dr2 + c[1], (-D*dx - abs(dy)*sdisc)/dr2 + c[1]]
        getcoords = lambda x, y, c: [(x,y)] if x>=0 and x<=MathApp.width and y>=0 and y<=MathApp.height else []
        res = getcoords(x[0], y[0], c)
        res.extend(getcoords(x[1], y[1], c))
        return res


    @property
    def center(self):
        return self._center()

    @center.setter
    def center(self, val):
        newval = self.Eval(val)
        if newval != self._center:
            self._center = newval
            self._touchAsset()

    @property
    def radius(self):
        return self._radius()

    @radius.setter
    def radius(self, val):
        newval = self.Eval(val)
        if newval != self._radius:
            self._radius = newval
            self._touchAsset()
        
    def step(self):
        self._touchAsset()

    def physicalPointTouching(self, ppos):
        r = MathApp.distance(self._pcenter, ppos)
        inner = self._pradius - self.style.width/2
        outer = self._pradius + self.style.width/2
        return r <= outer and r >= inner

    def translate(self, pdisp):
        pass
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggmath.Circle">Circle</a></li>
          <li>__pdoc_file_module__._MathVisual</li>
          <li>ggame.Sprite</li>
          <li>__pdoc_file_module__._MathDynamic</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="ggmath.Circle.defaultcolor" class="name">var <span class="ident">defaultcolor</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Circle.defaultsize" class="name">var <span class="ident">defaultsize</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Circle.defaultstyle" class="name">var <span class="ident">defaultstyle</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Circle.defaultwidth" class="name">var <span class="ident">defaultwidth</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Circle.nonposinputsdef" class="name">var <span class="ident">nonposinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Circle.posinputsdef" class="name">var <span class="ident">posinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.Circle.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Required Inputs</p>
<ul>
<li><strong>pos</strong> center of circle</li>
<li><strong>radius</strong> radius of circle (logical) or point on circle</li>
</ul>
<p>Optional Inputs</p>
<ul>
<li><strong>style</strong> border line style (thickness, color)</li>
<li><strong>color</strong> fill color</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Circle.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Circle.__init__" class="source">
    <pre><code>def __init__(self, *args, **kwargs):
    """
    Required Inputs
    
    * **pos** center of circle
    * **radius** radius of circle (logical) or point on circle
    
    Optional Inputs
    
    * **style** border line style (thickness, color)
    * **color** fill color
    """
    """
    Radius may be scalar or point
    """
    super().__init__(CircleAsset(0, self.defaultstyle, self.defaultcolor), *args, **kwargs)
    self._touchAsset()
    self.fxcenter = self.fycenter = 0.5
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Circle.Eval">
    <p>def <span class="ident">Eval</span>(</p><p>self, val)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Circle.Eval', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Circle.Eval" class="source">
    <pre><code>def Eval(self, val):
    if callable(val):
        self._setDynamic() # dynamically defined .. must step
        return val
    else:
        return lambda : val  
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Circle.canstroke">
    <p>def <span class="ident">canstroke</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Circle.canstroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Circle.canstroke" class="source">
    <pre><code>def canstroke(self, ppos):
    return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Circle.circularCollisionModel">
    <p>def <span class="ident">circularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Circle.circularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Circle.circularCollisionModel" class="source">
    <pre><code>def circularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Circle.collidingPolyWithPoly">
    <p>def <span class="ident">collidingPolyWithPoly</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Circle.collidingPolyWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Circle.collidingPolyWithPoly" class="source">
    <pre><code>def collidingPolyWithPoly(self, obj):
    return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Circle.collidingWith">
    <p>def <span class="ident">collidingWith</span>(</p><p>self, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a boolean True if this sprite is currently overlapping the sprite 
referenced by <code>obj</code>. Returns False if checking for collision with 
itself. Returns False if extents of object make it impossible for
collision to occur. Returns True if sprite's <code>edgedef</code> parameter overlaps
with other sprite's <code>edgedef</code> parameter, taking into consideration both
sprites' center, rotation and scale settings.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Circle.collidingWith', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Circle.collidingWith" class="source">
    <pre><code>def collidingWith(self, obj):
    """
    Return a boolean True if this sprite is currently overlapping the sprite 
    referenced by `obj`. Returns False if checking for collision with 
    itself. Returns False if extents of object make it impossible for
    collision to occur. Returns True if sprite's `edgedef` parameter overlaps
    with other sprite's `edgedef` parameter, taking into consideration both
    sprites' center, rotation and scale settings.
    """
    if self is obj:
        return False
    else:
        self._setExtents()
        obj._setExtents()
        # Gross check for overlap will usually rule out a collision
        if (self.xmin > obj.xmax
            or self.xmax < obj.xmin
            or self.ymin > obj.ymax
            or self.ymax < obj.ymin):
            return False
        # Otherwise, perform a careful overlap determination
        elif type(self.asset) is CircleAsset:
            if type(obj.asset) is CircleAsset:
                # two circles .. check distance between
                sx = (self.xmin + self.xmax) / 2
                sy = (self.ymin + self.ymax) / 2
                ox = (obj.xmin + obj.xmax) / 2
                oy = (obj.ymin + obj.ymax) / 2
                d = math.sqrt((sx-ox)**2 + (sy-oy)**2)
                return d <= self.width/2 + obj.width/2
            else:
                return self.collidingCircleWithPoly(self, obj)
        else:
            if type(obj.asset) is CircleAsset:
                return self.collidingCircleWithPoly(obj, self)
            else:
                return self.collidingPolyWithPoly(obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Circle.collidingWithSprites">
    <p>def <span class="ident">collidingWithSprites</span>(</p><p>self, sclass=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a list of sprite objects identified by the <code>sclass</code> parameter
that are currently colliding with (that is, with which the <code>ggame.Sprite.collidingWith</code>
method returns True) this sprite. If <code>sclass</code> is set to <code>None</code> (default), then
all other sprites are checked for collision, otherwise, only sprites whose
class matches <code>sclass</code> are checked.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Circle.collidingWithSprites', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Circle.collidingWithSprites" class="source">
    <pre><code>def collidingWithSprites(self, sclass = None):
    """
    Return a list of sprite objects identified by the `sclass` parameter
    that are currently colliding with (that is, with which the `ggame.Sprite.collidingWith`
    method returns True) this sprite. If `sclass` is set to `None` (default), then
    all other sprites are checked for collision, otherwise, only sprites whose
    class matches `sclass` are checked.
    """
    if sclass is None:
        slist = App.spritelist
    else:
        slist = App.getSpritesbyClass(sclass)
    return list(filter(self.collidingWith, slist))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Circle.destroy">
    <p>def <span class="ident">destroy</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Circle.destroy', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Circle.destroy" class="source">
    <pre><code>def destroy(self):
    MathApp._removeVisual(self)
    MathApp._removeMovable(self)
    MathApp._removeStrokable(self)
    _MathDynamic.destroy(self)
    Sprite.destroy(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Circle.firstImage">
    <p>def <span class="ident">firstImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>first</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Circle.firstImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Circle.firstImage" class="source">
    <pre><code>def firstImage(self):
    """
    Select and display the *first* image used by this sprite.
    """
    self.GFX.texture = self.asset[0]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Circle.lastImage">
    <p>def <span class="ident">lastImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>last</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Circle.lastImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Circle.lastImage" class="source">
    <pre><code>def lastImage(self):
    """
    Select and display the *last* image used by this sprite.
    """
    self.GFX.texture = self.asset[-1]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Circle.mousedown">
    <p>def <span class="ident">mousedown</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Circle.mousedown', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Circle.mousedown" class="source">
    <pre><code>def mousedown(self):
    self.mouseisdown = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Circle.mouseup">
    <p>def <span class="ident">mouseup</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Circle.mouseup', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Circle.mouseup" class="source">
    <pre><code>def mouseup(self):
    self.mouseisdown = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Circle.nextImage">
    <p>def <span class="ident">nextImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>next</em> image used by this sprite.
If the current image is already the <em>last</em> image, then
the image is not advanced.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.nextImage</code> on the last image will cause the <em>first</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Circle.nextImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Circle.nextImage" class="source">
    <pre><code>def nextImage(self, wrap = False):
    """
    Select and display the *next* image used by this sprite.
    If the current image is already the *last* image, then
    the image is not advanced.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.nextImage` on the last image will cause the *first*
    image to be loaded.
    """
    self._index += 1
    if self._index >= len(self.asset):
        if wrap:
            self._index = 0
        else:
            self._index = len(self.asset)-1
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Circle.physicalPointTouching">
    <p>def <span class="ident">physicalPointTouching</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Circle.physicalPointTouching', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Circle.physicalPointTouching" class="source">
    <pre><code>def physicalPointTouching(self, ppos):
    r = MathApp.distance(self._pcenter, ppos)
    inner = self._pradius - self.style.width/2
    outer = self._pradius + self.style.width/2
    return r <= outer and r >= inner
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Circle.prevImage">
    <p>def <span class="ident">prevImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>previous</em> image used by this sprite.
If the current image is already the <em>first</em> image, then
the image is not changed.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.prevImage</code> on the first image will cause the <em>last</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Circle.prevImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Circle.prevImage" class="source">
    <pre><code>def prevImage(self, wrap = False):
    """
    Select and display the *previous* image used by this sprite.
    If the current image is already the *first* image, then
    the image is not changed.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.prevImage` on the first image will cause the *last*
    image to be loaded.
    """
    self._index -= 1
    if self._index < 0:
        if wrap:
            self._index = len(self.asset)-1
        else:
            self._index = 0
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Circle.processEvent">
    <p>def <span class="ident">processEvent</span>(</p><p>self, event)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Circle.processEvent', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Circle.processEvent" class="source">
    <pre><code>def processEvent(self, event):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Circle.rectangularCollisionModel">
    <p>def <span class="ident">rectangularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Circle.rectangularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Circle.rectangularCollisionModel" class="source">
    <pre><code>def rectangularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Circle.select">
    <p>def <span class="ident">select</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Circle.select', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Circle.select" class="source">
    <pre><code>def select(self):
    self.selected = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Circle.setImage">
    <p>def <span class="ident">setImage</span>(</p><p>self, index=0)</p>
    </div>
    

    
  
    <div class="desc"><p>Select the image to display by giving its <code>index</code>, where an index
of zero represents the <em>first</em> image in the asset.</p>
<p>This is equivalent to setting the <code>ggame.Sprite.index</code> property
directly.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Circle.setImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Circle.setImage" class="source">
    <pre><code>def setImage(self, index=0):
    """
    Select the image to display by giving its `index`, where an index
    of zero represents the *first* image in the asset.
    This is equivalent to setting the `ggame.Sprite.index` property
    directly.
    """
    self.index = index
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Circle.step">
    <p>def <span class="ident">step</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Circle.step', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Circle.step" class="source">
    <pre><code>def step(self):
    self._touchAsset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Circle.stroke">
    <p>def <span class="ident">stroke</span>(</p><p>self, ppos, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Circle.stroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Circle.stroke" class="source">
    <pre><code>def stroke(self, ppos, pdisp):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Circle.translate">
    <p>def <span class="ident">translate</span>(</p><p>self, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Circle.translate', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Circle.translate" class="source">
    <pre><code>def translate(self, pdisp):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Circle.unselect">
    <p>def <span class="ident">unselect</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Circle.unselect', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Circle.unselect" class="source">
    <pre><code>def unselect(self):
    self.selected = False
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggmath.Circle.center" class="name">var <span class="ident">center</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Circle.fxcenter" class="name">var <span class="ident">fxcenter</span></p>
            

            
  
    <div class="desc"><p>This represents the horizontal position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its left hand edge. A value of 1.0 refers to its 
right hand edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Circle.fycenter" class="name">var <span class="ident">fycenter</span></p>
            

            
  
    <div class="desc"><p>This represents the vertical position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its top edge. A value of 1.0 refers to its 
bottom edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Circle.height" class="name">var <span class="ident">height</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display height of the sprite.
Assigning a value to the height will scale the image vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Circle.index" class="name">var <span class="ident">index</span></p>
            

            
  
    <div class="desc"><p>This is an integer index in to the list of images available for this sprite.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Circle.movable" class="name">var <span class="ident">movable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Circle.position" class="name">var <span class="ident">position</span></p>
            

            
  
    <div class="desc"><p>This represents the (x,y) coordinates of the sprite on the screen. Assigning
a value to this attribute will move the sprite to the new coordinates.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Circle.radius" class="name">var <span class="ident">radius</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Circle.rotation" class="name">var <span class="ident">rotation</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the rotation of the sprite on the screen.
Value may be a floating point number. A value of 0.0 means no rotation. A value 
of 1.0 means  a rotation of 1 radian in a counter-clockwise direction. One radian
is 180/pi or approximately 57.3 degrees.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Circle.scale" class="name">var <span class="ident">scale</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the size of the sprite ('scale' it) on the 
screen. Value may be a floating point number. A value of 1.0 means that the sprite
image will keep its original size. A value of 2.0 would double it, etc.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Circle.selectable" class="name">var <span class="ident">selectable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Circle.strokable" class="name">var <span class="ident">strokable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Circle.visible" class="name">var <span class="ident">visible</span></p>
            

            
  
    <div class="desc"><p>This boolean attribute may be used to change the visibility of the sprite. Setting
<code>ggame.Sprite.visible</code> to <code>False</code> will prevent the sprite from rendering on the 
screen.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Circle.width" class="name">var <span class="ident">width</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display width of the sprite.
Assigning a value to the width will scale the image horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Circle.x" class="name">var <span class="ident">x</span></p>
            

            
  
    <div class="desc"><p>This represents the x-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Circle.y" class="name">var <span class="ident">y</span></p>
            

            
  
    <div class="desc"><p>This represents the y-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.Circle.collidingCircleWithPoly">
    <p>def <span class="ident">collidingCircleWithPoly</span>(</p><p>cls, circ, poly)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Circle.collidingCircleWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Circle.collidingCircleWithPoly" class="source">
    <pre><code>@classmethod
def collidingCircleWithPoly(cls, circ, poly):
    return True
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ggmath.GlassButton" class="name">class <span class="ident">GlassButton</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton" class="source">
    <pre><code>class GlassButton(InputImageButton):
    
    def __init__(self, callback, *args, **kwargs):
        """
        Required Inputs
        
        * **callback** reference of a function to execute, passing this button object
        * **pos** position of point
        """        
        kwargs.setdefault('frame', Frame(0,0,100,100))
        kwargs.setdefault('qty', 2)
        super().__init__("button-round.png", callback, *args, **kwargs)
        self.scale = 0.3
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggmath.GlassButton">GlassButton</a></li>
          <li><a href="#ggmath.InputImageButton">InputImageButton</a></li>
          <li><a href="#ggmath.ImagePoint">ImagePoint</a></li>
          <li>__pdoc_file_module__._Point</li>
          <li>__pdoc_file_module__._MathVisual</li>
          <li>ggame.Sprite</li>
          <li>__pdoc_file_module__._MathDynamic</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="ggmath.GlassButton.defaultcolor" class="name">var <span class="ident">defaultcolor</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.GlassButton.defaultsize" class="name">var <span class="ident">defaultsize</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.GlassButton.defaultstyle" class="name">var <span class="ident">defaultstyle</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.GlassButton.defaultwidth" class="name">var <span class="ident">defaultwidth</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.GlassButton.nonposinputsdef" class="name">var <span class="ident">nonposinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.GlassButton.posinputsdef" class="name">var <span class="ident">posinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.GlassButton.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, callback, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Required Inputs</p>
<ul>
<li><strong>callback</strong> reference of a function to execute, passing this button object</li>
<li><strong>pos</strong> position of point</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton.__init__" class="source">
    <pre><code>def __init__(self, callback, *args, **kwargs):
    """
    Required Inputs
    
    * **callback** reference of a function to execute, passing this button object
    * **pos** position of point
    """        
    kwargs.setdefault('frame', Frame(0,0,100,100))
    kwargs.setdefault('qty', 2)
    super().__init__("button-round.png", callback, *args, **kwargs)
    self.scale = 0.3
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.GlassButton.Eval">
    <p>def <span class="ident">Eval</span>(</p><p>self, val)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton.Eval', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton.Eval" class="source">
    <pre><code>def Eval(self, val):
    if callable(val):
        self._setDynamic() # dynamically defined .. must step
        return val
    else:
        return lambda : val  
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.GlassButton.canstroke">
    <p>def <span class="ident">canstroke</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton.canstroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton.canstroke" class="source">
    <pre><code>def canstroke(self, ppos):
    return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.GlassButton.circularCollisionModel">
    <p>def <span class="ident">circularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton.circularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton.circularCollisionModel" class="source">
    <pre><code>def circularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.GlassButton.collidingPolyWithPoly">
    <p>def <span class="ident">collidingPolyWithPoly</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton.collidingPolyWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton.collidingPolyWithPoly" class="source">
    <pre><code>def collidingPolyWithPoly(self, obj):
    return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.GlassButton.collidingWith">
    <p>def <span class="ident">collidingWith</span>(</p><p>self, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a boolean True if this sprite is currently overlapping the sprite 
referenced by <code>obj</code>. Returns False if checking for collision with 
itself. Returns False if extents of object make it impossible for
collision to occur. Returns True if sprite's <code>edgedef</code> parameter overlaps
with other sprite's <code>edgedef</code> parameter, taking into consideration both
sprites' center, rotation and scale settings.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton.collidingWith', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton.collidingWith" class="source">
    <pre><code>def collidingWith(self, obj):
    """
    Return a boolean True if this sprite is currently overlapping the sprite 
    referenced by `obj`. Returns False if checking for collision with 
    itself. Returns False if extents of object make it impossible for
    collision to occur. Returns True if sprite's `edgedef` parameter overlaps
    with other sprite's `edgedef` parameter, taking into consideration both
    sprites' center, rotation and scale settings.
    """
    if self is obj:
        return False
    else:
        self._setExtents()
        obj._setExtents()
        # Gross check for overlap will usually rule out a collision
        if (self.xmin > obj.xmax
            or self.xmax < obj.xmin
            or self.ymin > obj.ymax
            or self.ymax < obj.ymin):
            return False
        # Otherwise, perform a careful overlap determination
        elif type(self.asset) is CircleAsset:
            if type(obj.asset) is CircleAsset:
                # two circles .. check distance between
                sx = (self.xmin + self.xmax) / 2
                sy = (self.ymin + self.ymax) / 2
                ox = (obj.xmin + obj.xmax) / 2
                oy = (obj.ymin + obj.ymax) / 2
                d = math.sqrt((sx-ox)**2 + (sy-oy)**2)
                return d <= self.width/2 + obj.width/2
            else:
                return self.collidingCircleWithPoly(self, obj)
        else:
            if type(obj.asset) is CircleAsset:
                return self.collidingCircleWithPoly(obj, self)
            else:
                return self.collidingPolyWithPoly(obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.GlassButton.collidingWithSprites">
    <p>def <span class="ident">collidingWithSprites</span>(</p><p>self, sclass=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a list of sprite objects identified by the <code>sclass</code> parameter
that are currently colliding with (that is, with which the <code>ggame.Sprite.collidingWith</code>
method returns True) this sprite. If <code>sclass</code> is set to <code>None</code> (default), then
all other sprites are checked for collision, otherwise, only sprites whose
class matches <code>sclass</code> are checked.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton.collidingWithSprites', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton.collidingWithSprites" class="source">
    <pre><code>def collidingWithSprites(self, sclass = None):
    """
    Return a list of sprite objects identified by the `sclass` parameter
    that are currently colliding with (that is, with which the `ggame.Sprite.collidingWith`
    method returns True) this sprite. If `sclass` is set to `None` (default), then
    all other sprites are checked for collision, otherwise, only sprites whose
    class matches `sclass` are checked.
    """
    if sclass is None:
        slist = App.spritelist
    else:
        slist = App.getSpritesbyClass(sclass)
    return list(filter(self.collidingWith, slist))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.GlassButton.destroy">
    <p>def <span class="ident">destroy</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton.destroy', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton.destroy" class="source">
    <pre><code>def destroy(self):
    MathApp._removeVisual(self)
    MathApp._removeMovable(self)
    MathApp._removeStrokable(self)
    _MathDynamic.destroy(self)
    Sprite.destroy(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.GlassButton.distanceTo">
    <p>def <span class="ident">distanceTo</span>(</p><p>self, otherpoint)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton.distanceTo', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton.distanceTo" class="source">
    <pre><code>def distanceTo(self, otherpoint):
    try:
        pos = self.posinputs.pos
        opos = otherpoint.posinputs.pos
        return MathApp.distance(pos, opos())
    except AttributeError:
        return otherpoint  # presumably a scalar - use this distance
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.GlassButton.firstImage">
    <p>def <span class="ident">firstImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>first</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton.firstImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton.firstImage" class="source">
    <pre><code>def firstImage(self):
    """
    Select and display the *first* image used by this sprite.
    """
    self.GFX.texture = self.asset[0]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.GlassButton.lastImage">
    <p>def <span class="ident">lastImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>last</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton.lastImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton.lastImage" class="source">
    <pre><code>def lastImage(self):
    """
    Select and display the *last* image used by this sprite.
    """
    self.GFX.texture = self.asset[-1]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.GlassButton.mousedown">
    <p>def <span class="ident">mousedown</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton.mousedown', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton.mousedown" class="source">
    <pre><code>def mousedown(self):
    self.mouseisdown = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.GlassButton.mouseup">
    <p>def <span class="ident">mouseup</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton.mouseup', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton.mouseup" class="source">
    <pre><code>def mouseup(self):
    self.mouseisdown = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.GlassButton.nextImage">
    <p>def <span class="ident">nextImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>next</em> image used by this sprite.
If the current image is already the <em>last</em> image, then
the image is not advanced.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.nextImage</code> on the last image will cause the <em>first</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton.nextImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton.nextImage" class="source">
    <pre><code>def nextImage(self, wrap = False):
    """
    Select and display the *next* image used by this sprite.
    If the current image is already the *last* image, then
    the image is not advanced.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.nextImage` on the last image will cause the *first*
    image to be loaded.
    """
    self._index += 1
    if self._index >= len(self.asset):
        if wrap:
            self._index = 0
        else:
            self._index = len(self.asset)-1
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.GlassButton.physicalPointTouching">
    <p>def <span class="ident">physicalPointTouching</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton.physicalPointTouching', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton.physicalPointTouching" class="source">
    <pre><code>def physicalPointTouching(self, ppos):
    self._setExtents()  # ensure xmin, xmax are correct
    x, y = ppos
    return x >= self.xmin and x < self.xmax and y >= self.ymin and y <= self.ymax
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.GlassButton.prevImage">
    <p>def <span class="ident">prevImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>previous</em> image used by this sprite.
If the current image is already the <em>first</em> image, then
the image is not changed.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.prevImage</code> on the first image will cause the <em>last</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton.prevImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton.prevImage" class="source">
    <pre><code>def prevImage(self, wrap = False):
    """
    Select and display the *previous* image used by this sprite.
    If the current image is already the *first* image, then
    the image is not changed.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.prevImage` on the first image will cause the *last*
    image to be loaded.
    """
    self._index -= 1
    if self._index < 0:
        if wrap:
            self._index = len(self.asset)-1
        else:
            self._index = 0
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.GlassButton.processEvent">
    <p>def <span class="ident">processEvent</span>(</p><p>self, event)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton.processEvent', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton.processEvent" class="source">
    <pre><code>def processEvent(self, event):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.GlassButton.rectangularCollisionModel">
    <p>def <span class="ident">rectangularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton.rectangularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton.rectangularCollisionModel" class="source">
    <pre><code>def rectangularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.GlassButton.select">
    <p>def <span class="ident">select</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton.select', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton.select" class="source">
    <pre><code>def select(self):
    super().select()
    if self._callback: self._callback(self)
    self.unselect()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.GlassButton.setImage">
    <p>def <span class="ident">setImage</span>(</p><p>self, index=0)</p>
    </div>
    

    
  
    <div class="desc"><p>Select the image to display by giving its <code>index</code>, where an index
of zero represents the <em>first</em> image in the asset.</p>
<p>This is equivalent to setting the <code>ggame.Sprite.index</code> property
directly.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton.setImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton.setImage" class="source">
    <pre><code>def setImage(self, index=0):
    """
    Select the image to display by giving its `index`, where an index
    of zero represents the *first* image in the asset.
    This is equivalent to setting the `ggame.Sprite.index` property
    directly.
    """
    self.index = index
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.GlassButton.step">
    <p>def <span class="ident">step</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton.step', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton.step" class="source">
    <pre><code>def step(self):
    pass  # FIXME
    self._touchAsset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.GlassButton.stroke">
    <p>def <span class="ident">stroke</span>(</p><p>self, ppos, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton.stroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton.stroke" class="source">
    <pre><code>def stroke(self, ppos, pdisp):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.GlassButton.translate">
    <p>def <span class="ident">translate</span>(</p><p>self, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton.translate', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton.translate" class="source">
    <pre><code>def translate(self, pdisp):
    ldisp = MathApp.translatePhysicalToLogical(pdisp)
    pos = self.posinputs.pos()
    self.posinputs = self.posinputs._replace(pos=self.Eval((pos[0] + ldisp[0], pos[1] + ldisp[1])))
    self._touchAsset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.GlassButton.unselect">
    <p>def <span class="ident">unselect</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton.unselect', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton.unselect" class="source">
    <pre><code>def unselect(self):
    super().unselect()
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggmath.GlassButton.center" class="name">var <span class="ident">center</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#ggmath.ImagePoint">ImagePoint</a></code>.<code><a href="#ggmath.ImagePoint.center">center</a></code>
    </p>

            
  
    <div class="desc inherited"><p>This attribute represents the horizontal and vertical position of the 
sprite "center" as a tuple of floating point numbers. See the 
descriptions for <code>ggame.Sprite.fxcenter</code> and <code>ggame.Sprite.fycenter</code> for 
more details.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.GlassButton.fxcenter" class="name">var <span class="ident">fxcenter</span></p>
            

            
  
    <div class="desc"><p>This represents the horizontal position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its left hand edge. A value of 1.0 refers to its 
right hand edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.GlassButton.fycenter" class="name">var <span class="ident">fycenter</span></p>
            

            
  
    <div class="desc"><p>This represents the vertical position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its top edge. A value of 1.0 refers to its 
bottom edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.GlassButton.height" class="name">var <span class="ident">height</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display height of the sprite.
Assigning a value to the height will scale the image vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.GlassButton.index" class="name">var <span class="ident">index</span></p>
            

            
  
    <div class="desc"><p>This is an integer index in to the list of images available for this sprite.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.GlassButton.movable" class="name">var <span class="ident">movable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.GlassButton.position" class="name">var <span class="ident">position</span></p>
            

            
  
    <div class="desc"><p>This represents the (x,y) coordinates of the sprite on the screen. Assigning
a value to this attribute will move the sprite to the new coordinates.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.GlassButton.rotation" class="name">var <span class="ident">rotation</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the rotation of the sprite on the screen.
Value may be a floating point number. A value of 0.0 means no rotation. A value 
of 1.0 means  a rotation of 1 radian in a counter-clockwise direction. One radian
is 180/pi or approximately 57.3 degrees.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.GlassButton.scale" class="name">var <span class="ident">scale</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.GlassButton.selectable" class="name">var <span class="ident">selectable</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#ggmath.InputImageButton">InputImageButton</a></code>.<code><a href="#ggmath.InputImageButton.selectable">selectable</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.GlassButton.strokable" class="name">var <span class="ident">strokable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.GlassButton.visible" class="name">var <span class="ident">visible</span></p>
            

            
  
    <div class="desc"><p>This boolean attribute may be used to change the visibility of the sprite. Setting
<code>ggame.Sprite.visible</code> to <code>False</code> will prevent the sprite from rendering on the 
screen.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.GlassButton.width" class="name">var <span class="ident">width</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display width of the sprite.
Assigning a value to the width will scale the image horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.GlassButton.x" class="name">var <span class="ident">x</span></p>
            

            
  
    <div class="desc"><p>This represents the x-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.GlassButton.y" class="name">var <span class="ident">y</span></p>
            

            
  
    <div class="desc"><p>This represents the y-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.GlassButton.collidingCircleWithPoly">
    <p>def <span class="ident">collidingCircleWithPoly</span>(</p><p>cls, circ, poly)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.GlassButton.collidingCircleWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.GlassButton.collidingCircleWithPoly" class="source">
    <pre><code>@classmethod
def collidingCircleWithPoly(cls, circ, poly):
    return True
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ggmath.ImageIndicator" class="name">class <span class="ident">ImageIndicator</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImageIndicator', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImageIndicator" class="source">
    <pre><code>class ImageIndicator(_MathVisual):

    posinputsdef = ['pos']
    nonposinputsdef = ['value']

    def __init__(self, url, *args, **kwargs):
        """
        Required Inputs
        
        * **url** location of image file consisting of two image sprite sheet
        * **pos** position of point
        * **value** state of the indicator (True/False or integer)

        Optional Inputs
        * **frame** sub-frame location of image within file
        * **qty** number of sub-frames, when used as sprite sheet
        * **direction** one of 'horizontal' (default) or 'vertical'
        * **margin** pixels between sub-frames if sprite sheet
        """
        kwargs.setdefault('frame', None)
        kwargs.setdefault('qty', 1)
        kwargs.setdefault('direction', 'horizontal')
        kwargs.setdefault('margin', 0)
        super().__init__(
            ImageAsset(url, 
                kwargs['frame'], 
                kwargs['qty'], 
                kwargs['direction'], 
                kwargs['margin']), 
            *args, **kwargs)
        self.center = (0,0)

    def _buildAsset(self):
        inval = self.nposinputs.value()
        if inval == True:
            self.setImage(1)
        elif inval == False:
            self.setImage(0)
        else:
            self.setImage(inval)
        return self.asset

    def physicalPointTouching(self, ppos):
        self._setExtents()  # ensure xmin, xmax are correct
        x, y = ppos
        return x >= self.xmin and x < self.xmax and y >= self.ymin and y <= self.ymax

    def translate(self, pdisp):
        pass
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggmath.ImageIndicator">ImageIndicator</a></li>
          <li>__pdoc_file_module__._MathVisual</li>
          <li>ggame.Sprite</li>
          <li>__pdoc_file_module__._MathDynamic</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="ggmath.ImageIndicator.defaultcolor" class="name">var <span class="ident">defaultcolor</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImageIndicator.defaultsize" class="name">var <span class="ident">defaultsize</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImageIndicator.defaultstyle" class="name">var <span class="ident">defaultstyle</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImageIndicator.defaultwidth" class="name">var <span class="ident">defaultwidth</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImageIndicator.nonposinputsdef" class="name">var <span class="ident">nonposinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImageIndicator.posinputsdef" class="name">var <span class="ident">posinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.ImageIndicator.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, url, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Required Inputs</p>
<ul>
<li><strong>url</strong> location of image file consisting of two image sprite sheet</li>
<li><strong>pos</strong> position of point</li>
<li><strong>value</strong> state of the indicator (True/False or integer)</li>
</ul>
<p>Optional Inputs
<em> <strong>frame</strong> sub-frame location of image within file
</em> <strong>qty</strong> number of sub-frames, when used as sprite sheet
<em> <strong>direction</strong> one of 'horizontal' (default) or 'vertical'
</em> <strong>margin</strong> pixels between sub-frames if sprite sheet</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImageIndicator.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImageIndicator.__init__" class="source">
    <pre><code>def __init__(self, url, *args, **kwargs):
    """
    Required Inputs
    
    * **url** location of image file consisting of two image sprite sheet
    * **pos** position of point
    * **value** state of the indicator (True/False or integer)
    Optional Inputs
    * **frame** sub-frame location of image within file
    * **qty** number of sub-frames, when used as sprite sheet
    * **direction** one of 'horizontal' (default) or 'vertical'
    * **margin** pixels between sub-frames if sprite sheet
    """
    kwargs.setdefault('frame', None)
    kwargs.setdefault('qty', 1)
    kwargs.setdefault('direction', 'horizontal')
    kwargs.setdefault('margin', 0)
    super().__init__(
        ImageAsset(url, 
            kwargs['frame'], 
            kwargs['qty'], 
            kwargs['direction'], 
            kwargs['margin']), 
        *args, **kwargs)
    self.center = (0,0)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImageIndicator.Eval">
    <p>def <span class="ident">Eval</span>(</p><p>self, val)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImageIndicator.Eval', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImageIndicator.Eval" class="source">
    <pre><code>def Eval(self, val):
    if callable(val):
        self._setDynamic() # dynamically defined .. must step
        return val
    else:
        return lambda : val  
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImageIndicator.canstroke">
    <p>def <span class="ident">canstroke</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImageIndicator.canstroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImageIndicator.canstroke" class="source">
    <pre><code>def canstroke(self, ppos):
    return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImageIndicator.circularCollisionModel">
    <p>def <span class="ident">circularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImageIndicator.circularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImageIndicator.circularCollisionModel" class="source">
    <pre><code>def circularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImageIndicator.collidingPolyWithPoly">
    <p>def <span class="ident">collidingPolyWithPoly</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImageIndicator.collidingPolyWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImageIndicator.collidingPolyWithPoly" class="source">
    <pre><code>def collidingPolyWithPoly(self, obj):
    return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImageIndicator.collidingWith">
    <p>def <span class="ident">collidingWith</span>(</p><p>self, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a boolean True if this sprite is currently overlapping the sprite 
referenced by <code>obj</code>. Returns False if checking for collision with 
itself. Returns False if extents of object make it impossible for
collision to occur. Returns True if sprite's <code>edgedef</code> parameter overlaps
with other sprite's <code>edgedef</code> parameter, taking into consideration both
sprites' center, rotation and scale settings.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImageIndicator.collidingWith', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImageIndicator.collidingWith" class="source">
    <pre><code>def collidingWith(self, obj):
    """
    Return a boolean True if this sprite is currently overlapping the sprite 
    referenced by `obj`. Returns False if checking for collision with 
    itself. Returns False if extents of object make it impossible for
    collision to occur. Returns True if sprite's `edgedef` parameter overlaps
    with other sprite's `edgedef` parameter, taking into consideration both
    sprites' center, rotation and scale settings.
    """
    if self is obj:
        return False
    else:
        self._setExtents()
        obj._setExtents()
        # Gross check for overlap will usually rule out a collision
        if (self.xmin > obj.xmax
            or self.xmax < obj.xmin
            or self.ymin > obj.ymax
            or self.ymax < obj.ymin):
            return False
        # Otherwise, perform a careful overlap determination
        elif type(self.asset) is CircleAsset:
            if type(obj.asset) is CircleAsset:
                # two circles .. check distance between
                sx = (self.xmin + self.xmax) / 2
                sy = (self.ymin + self.ymax) / 2
                ox = (obj.xmin + obj.xmax) / 2
                oy = (obj.ymin + obj.ymax) / 2
                d = math.sqrt((sx-ox)**2 + (sy-oy)**2)
                return d <= self.width/2 + obj.width/2
            else:
                return self.collidingCircleWithPoly(self, obj)
        else:
            if type(obj.asset) is CircleAsset:
                return self.collidingCircleWithPoly(obj, self)
            else:
                return self.collidingPolyWithPoly(obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImageIndicator.collidingWithSprites">
    <p>def <span class="ident">collidingWithSprites</span>(</p><p>self, sclass=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a list of sprite objects identified by the <code>sclass</code> parameter
that are currently colliding with (that is, with which the <code>ggame.Sprite.collidingWith</code>
method returns True) this sprite. If <code>sclass</code> is set to <code>None</code> (default), then
all other sprites are checked for collision, otherwise, only sprites whose
class matches <code>sclass</code> are checked.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImageIndicator.collidingWithSprites', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImageIndicator.collidingWithSprites" class="source">
    <pre><code>def collidingWithSprites(self, sclass = None):
    """
    Return a list of sprite objects identified by the `sclass` parameter
    that are currently colliding with (that is, with which the `ggame.Sprite.collidingWith`
    method returns True) this sprite. If `sclass` is set to `None` (default), then
    all other sprites are checked for collision, otherwise, only sprites whose
    class matches `sclass` are checked.
    """
    if sclass is None:
        slist = App.spritelist
    else:
        slist = App.getSpritesbyClass(sclass)
    return list(filter(self.collidingWith, slist))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImageIndicator.destroy">
    <p>def <span class="ident">destroy</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImageIndicator.destroy', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImageIndicator.destroy" class="source">
    <pre><code>def destroy(self):
    MathApp._removeVisual(self)
    MathApp._removeMovable(self)
    MathApp._removeStrokable(self)
    _MathDynamic.destroy(self)
    Sprite.destroy(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImageIndicator.firstImage">
    <p>def <span class="ident">firstImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>first</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImageIndicator.firstImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImageIndicator.firstImage" class="source">
    <pre><code>def firstImage(self):
    """
    Select and display the *first* image used by this sprite.
    """
    self.GFX.texture = self.asset[0]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImageIndicator.lastImage">
    <p>def <span class="ident">lastImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>last</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImageIndicator.lastImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImageIndicator.lastImage" class="source">
    <pre><code>def lastImage(self):
    """
    Select and display the *last* image used by this sprite.
    """
    self.GFX.texture = self.asset[-1]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImageIndicator.mousedown">
    <p>def <span class="ident">mousedown</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImageIndicator.mousedown', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImageIndicator.mousedown" class="source">
    <pre><code>def mousedown(self):
    self.mouseisdown = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImageIndicator.mouseup">
    <p>def <span class="ident">mouseup</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImageIndicator.mouseup', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImageIndicator.mouseup" class="source">
    <pre><code>def mouseup(self):
    self.mouseisdown = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImageIndicator.nextImage">
    <p>def <span class="ident">nextImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>next</em> image used by this sprite.
If the current image is already the <em>last</em> image, then
the image is not advanced.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.nextImage</code> on the last image will cause the <em>first</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImageIndicator.nextImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImageIndicator.nextImage" class="source">
    <pre><code>def nextImage(self, wrap = False):
    """
    Select and display the *next* image used by this sprite.
    If the current image is already the *last* image, then
    the image is not advanced.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.nextImage` on the last image will cause the *first*
    image to be loaded.
    """
    self._index += 1
    if self._index >= len(self.asset):
        if wrap:
            self._index = 0
        else:
            self._index = len(self.asset)-1
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImageIndicator.physicalPointTouching">
    <p>def <span class="ident">physicalPointTouching</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImageIndicator.physicalPointTouching', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImageIndicator.physicalPointTouching" class="source">
    <pre><code>def physicalPointTouching(self, ppos):
    self._setExtents()  # ensure xmin, xmax are correct
    x, y = ppos
    return x >= self.xmin and x < self.xmax and y >= self.ymin and y <= self.ymax
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImageIndicator.prevImage">
    <p>def <span class="ident">prevImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>previous</em> image used by this sprite.
If the current image is already the <em>first</em> image, then
the image is not changed.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.prevImage</code> on the first image will cause the <em>last</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImageIndicator.prevImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImageIndicator.prevImage" class="source">
    <pre><code>def prevImage(self, wrap = False):
    """
    Select and display the *previous* image used by this sprite.
    If the current image is already the *first* image, then
    the image is not changed.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.prevImage` on the first image will cause the *last*
    image to be loaded.
    """
    self._index -= 1
    if self._index < 0:
        if wrap:
            self._index = len(self.asset)-1
        else:
            self._index = 0
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImageIndicator.processEvent">
    <p>def <span class="ident">processEvent</span>(</p><p>self, event)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImageIndicator.processEvent', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImageIndicator.processEvent" class="source">
    <pre><code>def processEvent(self, event):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImageIndicator.rectangularCollisionModel">
    <p>def <span class="ident">rectangularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImageIndicator.rectangularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImageIndicator.rectangularCollisionModel" class="source">
    <pre><code>def rectangularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImageIndicator.select">
    <p>def <span class="ident">select</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImageIndicator.select', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImageIndicator.select" class="source">
    <pre><code>def select(self):
    self.selected = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImageIndicator.setImage">
    <p>def <span class="ident">setImage</span>(</p><p>self, index=0)</p>
    </div>
    

    
  
    <div class="desc"><p>Select the image to display by giving its <code>index</code>, where an index
of zero represents the <em>first</em> image in the asset.</p>
<p>This is equivalent to setting the <code>ggame.Sprite.index</code> property
directly.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImageIndicator.setImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImageIndicator.setImage" class="source">
    <pre><code>def setImage(self, index=0):
    """
    Select the image to display by giving its `index`, where an index
    of zero represents the *first* image in the asset.
    This is equivalent to setting the `ggame.Sprite.index` property
    directly.
    """
    self.index = index
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImageIndicator.step">
    <p>def <span class="ident">step</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImageIndicator.step', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImageIndicator.step" class="source">
    <pre><code>def step(self):
    self._touchAsset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImageIndicator.stroke">
    <p>def <span class="ident">stroke</span>(</p><p>self, ppos, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImageIndicator.stroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImageIndicator.stroke" class="source">
    <pre><code>def stroke(self, ppos, pdisp):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImageIndicator.translate">
    <p>def <span class="ident">translate</span>(</p><p>self, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImageIndicator.translate', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImageIndicator.translate" class="source">
    <pre><code>def translate(self, pdisp):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImageIndicator.unselect">
    <p>def <span class="ident">unselect</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImageIndicator.unselect', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImageIndicator.unselect" class="source">
    <pre><code>def unselect(self):
    self.selected = False
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggmath.ImageIndicator.center" class="name">var <span class="ident">center</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImageIndicator.fxcenter" class="name">var <span class="ident">fxcenter</span></p>
            

            
  
    <div class="desc"><p>This represents the horizontal position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its left hand edge. A value of 1.0 refers to its 
right hand edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImageIndicator.fycenter" class="name">var <span class="ident">fycenter</span></p>
            

            
  
    <div class="desc"><p>This represents the vertical position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its top edge. A value of 1.0 refers to its 
bottom edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImageIndicator.height" class="name">var <span class="ident">height</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display height of the sprite.
Assigning a value to the height will scale the image vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImageIndicator.index" class="name">var <span class="ident">index</span></p>
            

            
  
    <div class="desc"><p>This is an integer index in to the list of images available for this sprite.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImageIndicator.movable" class="name">var <span class="ident">movable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImageIndicator.position" class="name">var <span class="ident">position</span></p>
            

            
  
    <div class="desc"><p>This represents the (x,y) coordinates of the sprite on the screen. Assigning
a value to this attribute will move the sprite to the new coordinates.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImageIndicator.rotation" class="name">var <span class="ident">rotation</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the rotation of the sprite on the screen.
Value may be a floating point number. A value of 0.0 means no rotation. A value 
of 1.0 means  a rotation of 1 radian in a counter-clockwise direction. One radian
is 180/pi or approximately 57.3 degrees.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImageIndicator.scale" class="name">var <span class="ident">scale</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the size of the sprite ('scale' it) on the 
screen. Value may be a floating point number. A value of 1.0 means that the sprite
image will keep its original size. A value of 2.0 would double it, etc.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImageIndicator.selectable" class="name">var <span class="ident">selectable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImageIndicator.strokable" class="name">var <span class="ident">strokable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImageIndicator.visible" class="name">var <span class="ident">visible</span></p>
            

            
  
    <div class="desc"><p>This boolean attribute may be used to change the visibility of the sprite. Setting
<code>ggame.Sprite.visible</code> to <code>False</code> will prevent the sprite from rendering on the 
screen.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImageIndicator.width" class="name">var <span class="ident">width</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display width of the sprite.
Assigning a value to the width will scale the image horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImageIndicator.x" class="name">var <span class="ident">x</span></p>
            

            
  
    <div class="desc"><p>This represents the x-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImageIndicator.y" class="name">var <span class="ident">y</span></p>
            

            
  
    <div class="desc"><p>This represents the y-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.ImageIndicator.collidingCircleWithPoly">
    <p>def <span class="ident">collidingCircleWithPoly</span>(</p><p>cls, circ, poly)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImageIndicator.collidingCircleWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImageIndicator.collidingCircleWithPoly" class="source">
    <pre><code>@classmethod
def collidingCircleWithPoly(cls, circ, poly):
    return True
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ggmath.ImagePoint" class="name">class <span class="ident">ImagePoint</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint" class="source">
    <pre><code>class ImagePoint(_Point):


    def __init__(self, url, *args, **kwargs):
        """
        Required Inputs
        
        * **url** location of image file
        * **pos** position of point
        
        Optional Inputs
        * **frame** sub-frame location of image within file
        * **qty** number of sub-frames, when used as sprite sheet
        * **direction** one of 'horizontal' (default) or 'vertical'
        * **margin** pixels between sub-frames if sprite sheet
        """
        frame = kwargs.get('frame', None)
        qty = kwargs.get('qty', 1)
        direction = kwargs.get('direction', 'horizontal')
        margin = kwargs.get('margin', 0)
        self._imageasset = ImageAsset(url, frame, qty, direction, margin)
        super().__init__(self._imageasset, *args, **kwargs)


    def _buildAsset(self):
        return self._imageasset

    def physicalPointTouching(self, ppos):
        self._setExtents()  # ensure xmin, xmax are correct
        x, y = ppos
        return x >= self.xmin and x < self.xmax and y >= self.ymin and y <= self.ymax
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggmath.ImagePoint">ImagePoint</a></li>
          <li>__pdoc_file_module__._Point</li>
          <li>__pdoc_file_module__._MathVisual</li>
          <li>ggame.Sprite</li>
          <li>__pdoc_file_module__._MathDynamic</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="ggmath.ImagePoint.defaultcolor" class="name">var <span class="ident">defaultcolor</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImagePoint.defaultsize" class="name">var <span class="ident">defaultsize</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImagePoint.defaultstyle" class="name">var <span class="ident">defaultstyle</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImagePoint.defaultwidth" class="name">var <span class="ident">defaultwidth</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImagePoint.nonposinputsdef" class="name">var <span class="ident">nonposinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImagePoint.posinputsdef" class="name">var <span class="ident">posinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.ImagePoint.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, url, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Required Inputs</p>
<ul>
<li><strong>url</strong> location of image file</li>
<li><strong>pos</strong> position of point</li>
</ul>
<p>Optional Inputs
<em> <strong>frame</strong> sub-frame location of image within file
</em> <strong>qty</strong> number of sub-frames, when used as sprite sheet
<em> <strong>direction</strong> one of 'horizontal' (default) or 'vertical'
</em> <strong>margin</strong> pixels between sub-frames if sprite sheet</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint.__init__" class="source">
    <pre><code>def __init__(self, url, *args, **kwargs):
    """
    Required Inputs
    
    * **url** location of image file
    * **pos** position of point
    
    Optional Inputs
    * **frame** sub-frame location of image within file
    * **qty** number of sub-frames, when used as sprite sheet
    * **direction** one of 'horizontal' (default) or 'vertical'
    * **margin** pixels between sub-frames if sprite sheet
    """
    frame = kwargs.get('frame', None)
    qty = kwargs.get('qty', 1)
    direction = kwargs.get('direction', 'horizontal')
    margin = kwargs.get('margin', 0)
    self._imageasset = ImageAsset(url, frame, qty, direction, margin)
    super().__init__(self._imageasset, *args, **kwargs)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImagePoint.Eval">
    <p>def <span class="ident">Eval</span>(</p><p>self, val)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint.Eval', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint.Eval" class="source">
    <pre><code>def Eval(self, val):
    if callable(val):
        self._setDynamic() # dynamically defined .. must step
        return val
    else:
        return lambda : val  
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImagePoint.canstroke">
    <p>def <span class="ident">canstroke</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint.canstroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint.canstroke" class="source">
    <pre><code>def canstroke(self, ppos):
    return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImagePoint.circularCollisionModel">
    <p>def <span class="ident">circularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint.circularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint.circularCollisionModel" class="source">
    <pre><code>def circularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImagePoint.collidingPolyWithPoly">
    <p>def <span class="ident">collidingPolyWithPoly</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint.collidingPolyWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint.collidingPolyWithPoly" class="source">
    <pre><code>def collidingPolyWithPoly(self, obj):
    return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImagePoint.collidingWith">
    <p>def <span class="ident">collidingWith</span>(</p><p>self, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a boolean True if this sprite is currently overlapping the sprite 
referenced by <code>obj</code>. Returns False if checking for collision with 
itself. Returns False if extents of object make it impossible for
collision to occur. Returns True if sprite's <code>edgedef</code> parameter overlaps
with other sprite's <code>edgedef</code> parameter, taking into consideration both
sprites' center, rotation and scale settings.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint.collidingWith', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint.collidingWith" class="source">
    <pre><code>def collidingWith(self, obj):
    """
    Return a boolean True if this sprite is currently overlapping the sprite 
    referenced by `obj`. Returns False if checking for collision with 
    itself. Returns False if extents of object make it impossible for
    collision to occur. Returns True if sprite's `edgedef` parameter overlaps
    with other sprite's `edgedef` parameter, taking into consideration both
    sprites' center, rotation and scale settings.
    """
    if self is obj:
        return False
    else:
        self._setExtents()
        obj._setExtents()
        # Gross check for overlap will usually rule out a collision
        if (self.xmin > obj.xmax
            or self.xmax < obj.xmin
            or self.ymin > obj.ymax
            or self.ymax < obj.ymin):
            return False
        # Otherwise, perform a careful overlap determination
        elif type(self.asset) is CircleAsset:
            if type(obj.asset) is CircleAsset:
                # two circles .. check distance between
                sx = (self.xmin + self.xmax) / 2
                sy = (self.ymin + self.ymax) / 2
                ox = (obj.xmin + obj.xmax) / 2
                oy = (obj.ymin + obj.ymax) / 2
                d = math.sqrt((sx-ox)**2 + (sy-oy)**2)
                return d <= self.width/2 + obj.width/2
            else:
                return self.collidingCircleWithPoly(self, obj)
        else:
            if type(obj.asset) is CircleAsset:
                return self.collidingCircleWithPoly(obj, self)
            else:
                return self.collidingPolyWithPoly(obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImagePoint.collidingWithSprites">
    <p>def <span class="ident">collidingWithSprites</span>(</p><p>self, sclass=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a list of sprite objects identified by the <code>sclass</code> parameter
that are currently colliding with (that is, with which the <code>ggame.Sprite.collidingWith</code>
method returns True) this sprite. If <code>sclass</code> is set to <code>None</code> (default), then
all other sprites are checked for collision, otherwise, only sprites whose
class matches <code>sclass</code> are checked.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint.collidingWithSprites', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint.collidingWithSprites" class="source">
    <pre><code>def collidingWithSprites(self, sclass = None):
    """
    Return a list of sprite objects identified by the `sclass` parameter
    that are currently colliding with (that is, with which the `ggame.Sprite.collidingWith`
    method returns True) this sprite. If `sclass` is set to `None` (default), then
    all other sprites are checked for collision, otherwise, only sprites whose
    class matches `sclass` are checked.
    """
    if sclass is None:
        slist = App.spritelist
    else:
        slist = App.getSpritesbyClass(sclass)
    return list(filter(self.collidingWith, slist))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImagePoint.destroy">
    <p>def <span class="ident">destroy</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint.destroy', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint.destroy" class="source">
    <pre><code>def destroy(self):
    MathApp._removeVisual(self)
    MathApp._removeMovable(self)
    MathApp._removeStrokable(self)
    _MathDynamic.destroy(self)
    Sprite.destroy(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImagePoint.distanceTo">
    <p>def <span class="ident">distanceTo</span>(</p><p>self, otherpoint)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint.distanceTo', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint.distanceTo" class="source">
    <pre><code>def distanceTo(self, otherpoint):
    try:
        pos = self.posinputs.pos
        opos = otherpoint.posinputs.pos
        return MathApp.distance(pos, opos())
    except AttributeError:
        return otherpoint  # presumably a scalar - use this distance
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImagePoint.firstImage">
    <p>def <span class="ident">firstImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>first</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint.firstImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint.firstImage" class="source">
    <pre><code>def firstImage(self):
    """
    Select and display the *first* image used by this sprite.
    """
    self.GFX.texture = self.asset[0]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImagePoint.lastImage">
    <p>def <span class="ident">lastImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>last</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint.lastImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint.lastImage" class="source">
    <pre><code>def lastImage(self):
    """
    Select and display the *last* image used by this sprite.
    """
    self.GFX.texture = self.asset[-1]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImagePoint.mousedown">
    <p>def <span class="ident">mousedown</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint.mousedown', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint.mousedown" class="source">
    <pre><code>def mousedown(self):
    self.mouseisdown = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImagePoint.mouseup">
    <p>def <span class="ident">mouseup</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint.mouseup', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint.mouseup" class="source">
    <pre><code>def mouseup(self):
    self.mouseisdown = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImagePoint.nextImage">
    <p>def <span class="ident">nextImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>next</em> image used by this sprite.
If the current image is already the <em>last</em> image, then
the image is not advanced.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.nextImage</code> on the last image will cause the <em>first</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint.nextImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint.nextImage" class="source">
    <pre><code>def nextImage(self, wrap = False):
    """
    Select and display the *next* image used by this sprite.
    If the current image is already the *last* image, then
    the image is not advanced.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.nextImage` on the last image will cause the *first*
    image to be loaded.
    """
    self._index += 1
    if self._index >= len(self.asset):
        if wrap:
            self._index = 0
        else:
            self._index = len(self.asset)-1
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImagePoint.physicalPointTouching">
    <p>def <span class="ident">physicalPointTouching</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint.physicalPointTouching', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint.physicalPointTouching" class="source">
    <pre><code>def physicalPointTouching(self, ppos):
    self._setExtents()  # ensure xmin, xmax are correct
    x, y = ppos
    return x >= self.xmin and x < self.xmax and y >= self.ymin and y <= self.ymax
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImagePoint.prevImage">
    <p>def <span class="ident">prevImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>previous</em> image used by this sprite.
If the current image is already the <em>first</em> image, then
the image is not changed.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.prevImage</code> on the first image will cause the <em>last</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint.prevImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint.prevImage" class="source">
    <pre><code>def prevImage(self, wrap = False):
    """
    Select and display the *previous* image used by this sprite.
    If the current image is already the *first* image, then
    the image is not changed.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.prevImage` on the first image will cause the *last*
    image to be loaded.
    """
    self._index -= 1
    if self._index < 0:
        if wrap:
            self._index = len(self.asset)-1
        else:
            self._index = 0
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImagePoint.processEvent">
    <p>def <span class="ident">processEvent</span>(</p><p>self, event)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint.processEvent', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint.processEvent" class="source">
    <pre><code>def processEvent(self, event):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImagePoint.rectangularCollisionModel">
    <p>def <span class="ident">rectangularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint.rectangularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint.rectangularCollisionModel" class="source">
    <pre><code>def rectangularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImagePoint.select">
    <p>def <span class="ident">select</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint.select', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint.select" class="source">
    <pre><code>def select(self):
    self.selected = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImagePoint.setImage">
    <p>def <span class="ident">setImage</span>(</p><p>self, index=0)</p>
    </div>
    

    
  
    <div class="desc"><p>Select the image to display by giving its <code>index</code>, where an index
of zero represents the <em>first</em> image in the asset.</p>
<p>This is equivalent to setting the <code>ggame.Sprite.index</code> property
directly.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint.setImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint.setImage" class="source">
    <pre><code>def setImage(self, index=0):
    """
    Select the image to display by giving its `index`, where an index
    of zero represents the *first* image in the asset.
    This is equivalent to setting the `ggame.Sprite.index` property
    directly.
    """
    self.index = index
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImagePoint.step">
    <p>def <span class="ident">step</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint.step', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint.step" class="source">
    <pre><code>def step(self):
    pass  # FIXME
    self._touchAsset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImagePoint.stroke">
    <p>def <span class="ident">stroke</span>(</p><p>self, ppos, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint.stroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint.stroke" class="source">
    <pre><code>def stroke(self, ppos, pdisp):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImagePoint.translate">
    <p>def <span class="ident">translate</span>(</p><p>self, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint.translate', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint.translate" class="source">
    <pre><code>def translate(self, pdisp):
    ldisp = MathApp.translatePhysicalToLogical(pdisp)
    pos = self.posinputs.pos()
    self.posinputs = self.posinputs._replace(pos=self.Eval((pos[0] + ldisp[0], pos[1] + ldisp[1])))
    self._touchAsset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.ImagePoint.unselect">
    <p>def <span class="ident">unselect</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint.unselect', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint.unselect" class="source">
    <pre><code>def unselect(self):
    self.selected = False
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggmath.ImagePoint.center" class="name">var <span class="ident">center</span></p>
            

            
  
    <div class="desc"><p>This attribute represents the horizontal and vertical position of the 
sprite "center" as a tuple of floating point numbers. See the 
descriptions for <code>ggame.Sprite.fxcenter</code> and <code>ggame.Sprite.fycenter</code> for 
more details.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImagePoint.fxcenter" class="name">var <span class="ident">fxcenter</span></p>
            

            
  
    <div class="desc"><p>This represents the horizontal position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its left hand edge. A value of 1.0 refers to its 
right hand edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImagePoint.fycenter" class="name">var <span class="ident">fycenter</span></p>
            

            
  
    <div class="desc"><p>This represents the vertical position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its top edge. A value of 1.0 refers to its 
bottom edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImagePoint.height" class="name">var <span class="ident">height</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display height of the sprite.
Assigning a value to the height will scale the image vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImagePoint.index" class="name">var <span class="ident">index</span></p>
            

            
  
    <div class="desc"><p>This is an integer index in to the list of images available for this sprite.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImagePoint.movable" class="name">var <span class="ident">movable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImagePoint.position" class="name">var <span class="ident">position</span></p>
            

            
  
    <div class="desc"><p>This represents the (x,y) coordinates of the sprite on the screen. Assigning
a value to this attribute will move the sprite to the new coordinates.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImagePoint.rotation" class="name">var <span class="ident">rotation</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the rotation of the sprite on the screen.
Value may be a floating point number. A value of 0.0 means no rotation. A value 
of 1.0 means  a rotation of 1 radian in a counter-clockwise direction. One radian
is 180/pi or approximately 57.3 degrees.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImagePoint.scale" class="name">var <span class="ident">scale</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the size of the sprite ('scale' it) on the 
screen. Value may be a floating point number. A value of 1.0 means that the sprite
image will keep its original size. A value of 2.0 would double it, etc.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImagePoint.selectable" class="name">var <span class="ident">selectable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImagePoint.strokable" class="name">var <span class="ident">strokable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImagePoint.visible" class="name">var <span class="ident">visible</span></p>
            

            
  
    <div class="desc"><p>This boolean attribute may be used to change the visibility of the sprite. Setting
<code>ggame.Sprite.visible</code> to <code>False</code> will prevent the sprite from rendering on the 
screen.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImagePoint.width" class="name">var <span class="ident">width</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display width of the sprite.
Assigning a value to the width will scale the image horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImagePoint.x" class="name">var <span class="ident">x</span></p>
            

            
  
    <div class="desc"><p>This represents the x-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.ImagePoint.y" class="name">var <span class="ident">y</span></p>
            

            
  
    <div class="desc"><p>This represents the y-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.ImagePoint.collidingCircleWithPoly">
    <p>def <span class="ident">collidingCircleWithPoly</span>(</p><p>cls, circ, poly)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.ImagePoint.collidingCircleWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.ImagePoint.collidingCircleWithPoly" class="source">
    <pre><code>@classmethod
def collidingCircleWithPoly(cls, circ, poly):
    return True
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ggmath.InputButton" class="name">class <span class="ident">InputButton</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputButton', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputButton" class="source">
    <pre><code>class InputButton(Label):
    
    def __init__(self, callback, *args,  **kwargs):
        """
        Required Inputs
        
        * **pos** position of button
        * **text** text of button
        * **callback** reference of a function to execute, passing this button object
        """
        super().__init__(*args, **kwargs)
        self._touchAsset()
        self._callback = callback
        self.selectable = True

    def _buildAsset(self):
        return TextAsset(self.nposinputs.text(), 
                            style="bold {0}px Courier".format(self.stdinputs.size()),
                            width=self.stdinputs.width(),
                            fill=self.stdinputs.color())

    def select(self):
        super().select()
        if self._callback: self._callback(self)
        self.unselect()

    def unselect(self):
        super().unselect()
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggmath.InputButton">InputButton</a></li>
          <li><a href="#ggmath.Label">Label</a></li>
          <li>__pdoc_file_module__._MathVisual</li>
          <li>ggame.Sprite</li>
          <li>__pdoc_file_module__._MathDynamic</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="ggmath.InputButton.defaultcolor" class="name">var <span class="ident">defaultcolor</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputButton.defaultsize" class="name">var <span class="ident">defaultsize</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputButton.defaultstyle" class="name">var <span class="ident">defaultstyle</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputButton.defaultwidth" class="name">var <span class="ident">defaultwidth</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputButton.nonposinputsdef" class="name">var <span class="ident">nonposinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputButton.posinputsdef" class="name">var <span class="ident">posinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.InputButton.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, callback, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Required Inputs</p>
<ul>
<li><strong>pos</strong> position of button</li>
<li><strong>text</strong> text of button</li>
<li><strong>callback</strong> reference of a function to execute, passing this button object</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputButton.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputButton.__init__" class="source">
    <pre><code>def __init__(self, callback, *args,  **kwargs):
    """
    Required Inputs
    
    * **pos** position of button
    * **text** text of button
    * **callback** reference of a function to execute, passing this button object
    """
    super().__init__(*args, **kwargs)
    self._touchAsset()
    self._callback = callback
    self.selectable = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputButton.Eval">
    <p>def <span class="ident">Eval</span>(</p><p>self, val)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputButton.Eval', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputButton.Eval" class="source">
    <pre><code>def Eval(self, val):
    if callable(val):
        self._setDynamic() # dynamically defined .. must step
        return val
    else:
        return lambda : val  
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputButton.canstroke">
    <p>def <span class="ident">canstroke</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputButton.canstroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputButton.canstroke" class="source">
    <pre><code>def canstroke(self, ppos):
    return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputButton.circularCollisionModel">
    <p>def <span class="ident">circularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputButton.circularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputButton.circularCollisionModel" class="source">
    <pre><code>def circularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputButton.collidingPolyWithPoly">
    <p>def <span class="ident">collidingPolyWithPoly</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputButton.collidingPolyWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputButton.collidingPolyWithPoly" class="source">
    <pre><code>def collidingPolyWithPoly(self, obj):
    return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputButton.collidingWith">
    <p>def <span class="ident">collidingWith</span>(</p><p>self, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a boolean True if this sprite is currently overlapping the sprite 
referenced by <code>obj</code>. Returns False if checking for collision with 
itself. Returns False if extents of object make it impossible for
collision to occur. Returns True if sprite's <code>edgedef</code> parameter overlaps
with other sprite's <code>edgedef</code> parameter, taking into consideration both
sprites' center, rotation and scale settings.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputButton.collidingWith', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputButton.collidingWith" class="source">
    <pre><code>def collidingWith(self, obj):
    """
    Return a boolean True if this sprite is currently overlapping the sprite 
    referenced by `obj`. Returns False if checking for collision with 
    itself. Returns False if extents of object make it impossible for
    collision to occur. Returns True if sprite's `edgedef` parameter overlaps
    with other sprite's `edgedef` parameter, taking into consideration both
    sprites' center, rotation and scale settings.
    """
    if self is obj:
        return False
    else:
        self._setExtents()
        obj._setExtents()
        # Gross check for overlap will usually rule out a collision
        if (self.xmin > obj.xmax
            or self.xmax < obj.xmin
            or self.ymin > obj.ymax
            or self.ymax < obj.ymin):
            return False
        # Otherwise, perform a careful overlap determination
        elif type(self.asset) is CircleAsset:
            if type(obj.asset) is CircleAsset:
                # two circles .. check distance between
                sx = (self.xmin + self.xmax) / 2
                sy = (self.ymin + self.ymax) / 2
                ox = (obj.xmin + obj.xmax) / 2
                oy = (obj.ymin + obj.ymax) / 2
                d = math.sqrt((sx-ox)**2 + (sy-oy)**2)
                return d <= self.width/2 + obj.width/2
            else:
                return self.collidingCircleWithPoly(self, obj)
        else:
            if type(obj.asset) is CircleAsset:
                return self.collidingCircleWithPoly(obj, self)
            else:
                return self.collidingPolyWithPoly(obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputButton.collidingWithSprites">
    <p>def <span class="ident">collidingWithSprites</span>(</p><p>self, sclass=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a list of sprite objects identified by the <code>sclass</code> parameter
that are currently colliding with (that is, with which the <code>ggame.Sprite.collidingWith</code>
method returns True) this sprite. If <code>sclass</code> is set to <code>None</code> (default), then
all other sprites are checked for collision, otherwise, only sprites whose
class matches <code>sclass</code> are checked.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputButton.collidingWithSprites', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputButton.collidingWithSprites" class="source">
    <pre><code>def collidingWithSprites(self, sclass = None):
    """
    Return a list of sprite objects identified by the `sclass` parameter
    that are currently colliding with (that is, with which the `ggame.Sprite.collidingWith`
    method returns True) this sprite. If `sclass` is set to `None` (default), then
    all other sprites are checked for collision, otherwise, only sprites whose
    class matches `sclass` are checked.
    """
    if sclass is None:
        slist = App.spritelist
    else:
        slist = App.getSpritesbyClass(sclass)
    return list(filter(self.collidingWith, slist))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputButton.destroy">
    <p>def <span class="ident">destroy</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputButton.destroy', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputButton.destroy" class="source">
    <pre><code>def destroy(self):
    MathApp._removeVisual(self)
    MathApp._removeMovable(self)
    MathApp._removeStrokable(self)
    _MathDynamic.destroy(self)
    Sprite.destroy(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputButton.firstImage">
    <p>def <span class="ident">firstImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>first</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputButton.firstImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputButton.firstImage" class="source">
    <pre><code>def firstImage(self):
    """
    Select and display the *first* image used by this sprite.
    """
    self.GFX.texture = self.asset[0]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputButton.lastImage">
    <p>def <span class="ident">lastImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>last</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputButton.lastImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputButton.lastImage" class="source">
    <pre><code>def lastImage(self):
    """
    Select and display the *last* image used by this sprite.
    """
    self.GFX.texture = self.asset[-1]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputButton.mousedown">
    <p>def <span class="ident">mousedown</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputButton.mousedown', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputButton.mousedown" class="source">
    <pre><code>def mousedown(self):
    self.mouseisdown = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputButton.mouseup">
    <p>def <span class="ident">mouseup</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputButton.mouseup', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputButton.mouseup" class="source">
    <pre><code>def mouseup(self):
    self.mouseisdown = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputButton.nextImage">
    <p>def <span class="ident">nextImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>next</em> image used by this sprite.
If the current image is already the <em>last</em> image, then
the image is not advanced.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.nextImage</code> on the last image will cause the <em>first</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputButton.nextImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputButton.nextImage" class="source">
    <pre><code>def nextImage(self, wrap = False):
    """
    Select and display the *next* image used by this sprite.
    If the current image is already the *last* image, then
    the image is not advanced.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.nextImage` on the last image will cause the *first*
    image to be loaded.
    """
    self._index += 1
    if self._index >= len(self.asset):
        if wrap:
            self._index = 0
        else:
            self._index = len(self.asset)-1
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputButton.physicalPointTouching">
    <p>def <span class="ident">physicalPointTouching</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputButton.physicalPointTouching', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputButton.physicalPointTouching" class="source">
    <pre><code>def physicalPointTouching(self, ppos):
    _ppos = self.spposinputs.pos
    return (ppos[0] >= _ppos[0] and 
        ppos[0] <= _ppos[0] + self.sstdinputs.width and
        ppos[1] >= _ppos[1] and 
        ppos[1] <= _ppos[1] + self.sstdinputs.size)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputButton.prevImage">
    <p>def <span class="ident">prevImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>previous</em> image used by this sprite.
If the current image is already the <em>first</em> image, then
the image is not changed.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.prevImage</code> on the first image will cause the <em>last</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputButton.prevImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputButton.prevImage" class="source">
    <pre><code>def prevImage(self, wrap = False):
    """
    Select and display the *previous* image used by this sprite.
    If the current image is already the *first* image, then
    the image is not changed.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.prevImage` on the first image will cause the *last*
    image to be loaded.
    """
    self._index -= 1
    if self._index < 0:
        if wrap:
            self._index = len(self.asset)-1
        else:
            self._index = 0
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputButton.processEvent">
    <p>def <span class="ident">processEvent</span>(</p><p>self, event)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputButton.processEvent', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputButton.processEvent" class="source">
    <pre><code>def processEvent(self, event):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputButton.rectangularCollisionModel">
    <p>def <span class="ident">rectangularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputButton.rectangularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputButton.rectangularCollisionModel" class="source">
    <pre><code>def rectangularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputButton.select">
    <p>def <span class="ident">select</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputButton.select', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputButton.select" class="source">
    <pre><code>def select(self):
    super().select()
    if self._callback: self._callback(self)
    self.unselect()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputButton.setImage">
    <p>def <span class="ident">setImage</span>(</p><p>self, index=0)</p>
    </div>
    

    
  
    <div class="desc"><p>Select the image to display by giving its <code>index</code>, where an index
of zero represents the <em>first</em> image in the asset.</p>
<p>This is equivalent to setting the <code>ggame.Sprite.index</code> property
directly.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputButton.setImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputButton.setImage" class="source">
    <pre><code>def setImage(self, index=0):
    """
    Select the image to display by giving its `index`, where an index
    of zero represents the *first* image in the asset.
    This is equivalent to setting the `ggame.Sprite.index` property
    directly.
    """
    self.index = index
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputButton.step">
    <p>def <span class="ident">step</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputButton.step', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputButton.step" class="source">
    <pre><code>def step(self):
    self._touchAsset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputButton.stroke">
    <p>def <span class="ident">stroke</span>(</p><p>self, ppos, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputButton.stroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputButton.stroke" class="source">
    <pre><code>def stroke(self, ppos, pdisp):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputButton.translate">
    <p>def <span class="ident">translate</span>(</p><p>self, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputButton.translate', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputButton.translate" class="source">
    <pre><code>def translate(self, pdisp):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputButton.unselect">
    <p>def <span class="ident">unselect</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputButton.unselect', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputButton.unselect" class="source">
    <pre><code>def unselect(self):
    super().unselect()
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggmath.InputButton.center" class="name">var <span class="ident">center</span></p>
            

            
  
    <div class="desc"><p>This attribute represents the horizontal and vertical position of the 
sprite "center" as a tuple of floating point numbers. See the 
descriptions for <code>ggame.Sprite.fxcenter</code> and <code>ggame.Sprite.fycenter</code> for 
more details.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputButton.fxcenter" class="name">var <span class="ident">fxcenter</span></p>
            

            
  
    <div class="desc"><p>This represents the horizontal position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its left hand edge. A value of 1.0 refers to its 
right hand edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputButton.fycenter" class="name">var <span class="ident">fycenter</span></p>
            

            
  
    <div class="desc"><p>This represents the vertical position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its top edge. A value of 1.0 refers to its 
bottom edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputButton.height" class="name">var <span class="ident">height</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display height of the sprite.
Assigning a value to the height will scale the image vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputButton.index" class="name">var <span class="ident">index</span></p>
            

            
  
    <div class="desc"><p>This is an integer index in to the list of images available for this sprite.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputButton.movable" class="name">var <span class="ident">movable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputButton.position" class="name">var <span class="ident">position</span></p>
            

            
  
    <div class="desc"><p>This represents the (x,y) coordinates of the sprite on the screen. Assigning
a value to this attribute will move the sprite to the new coordinates.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputButton.rotation" class="name">var <span class="ident">rotation</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the rotation of the sprite on the screen.
Value may be a floating point number. A value of 0.0 means no rotation. A value 
of 1.0 means  a rotation of 1 radian in a counter-clockwise direction. One radian
is 180/pi or approximately 57.3 degrees.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputButton.scale" class="name">var <span class="ident">scale</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the size of the sprite ('scale' it) on the 
screen. Value may be a floating point number. A value of 1.0 means that the sprite
image will keep its original size. A value of 2.0 would double it, etc.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputButton.selectable" class="name">var <span class="ident">selectable</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#ggmath.Label">Label</a></code>.<code><a href="#ggmath.Label.selectable">selectable</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputButton.strokable" class="name">var <span class="ident">strokable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputButton.visible" class="name">var <span class="ident">visible</span></p>
            

            
  
    <div class="desc"><p>This boolean attribute may be used to change the visibility of the sprite. Setting
<code>ggame.Sprite.visible</code> to <code>False</code> will prevent the sprite from rendering on the 
screen.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputButton.width" class="name">var <span class="ident">width</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display width of the sprite.
Assigning a value to the width will scale the image horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputButton.x" class="name">var <span class="ident">x</span></p>
            

            
  
    <div class="desc"><p>This represents the x-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputButton.y" class="name">var <span class="ident">y</span></p>
            

            
  
    <div class="desc"><p>This represents the y-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.InputButton.collidingCircleWithPoly">
    <p>def <span class="ident">collidingCircleWithPoly</span>(</p><p>cls, circ, poly)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputButton.collidingCircleWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputButton.collidingCircleWithPoly" class="source">
    <pre><code>@classmethod
def collidingCircleWithPoly(cls, circ, poly):
    return True
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ggmath.InputImageButton" class="name">class <span class="ident">InputImageButton</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton" class="source">
    <pre><code>class InputImageButton(ImagePoint):
    
    def __init__(self, url, callback, *args, **kwargs):
        """
        Required Inputs
        
        * **url** location of image file
        * **callback** reference of a function to execute, passing this button object
        * **pos** position of point
        
        Optional Inputs
        * **frame** sub-frame location of image within file
        * **qty** number of sub-frames, when used as sprite sheet
        * **direction** one of 'horizontal' (default) or 'vertical'
        * **margin** pixels between sub-frames if sprite sheet
        """
        super().__init__(url, *args, **kwargs)
        self.center = (0,0)
        self._callback = callback
        self.selectable = True
        self.firstImage()
        self.mousewasdown = self.mouseisdown

    def select(self):
        super().select()
        if self._callback: self._callback(self)
        self.unselect()

    def unselect(self):
        super().unselect()

    def __call__(self):
        # code for controlling the button image state only works if the
        # button state is being monitored!
        if self.mouseisdown != self.mousewasdown:
            if self.mouseisdown:
                self.nextImage()
            else:
                self.firstImage()
            self.mousewasdown = self.mouseisdown
        return self.mouseisdown
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggmath.InputImageButton">InputImageButton</a></li>
          <li><a href="#ggmath.ImagePoint">ImagePoint</a></li>
          <li>__pdoc_file_module__._Point</li>
          <li>__pdoc_file_module__._MathVisual</li>
          <li>ggame.Sprite</li>
          <li>__pdoc_file_module__._MathDynamic</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="ggmath.InputImageButton.defaultcolor" class="name">var <span class="ident">defaultcolor</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageButton.defaultsize" class="name">var <span class="ident">defaultsize</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageButton.defaultstyle" class="name">var <span class="ident">defaultstyle</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageButton.defaultwidth" class="name">var <span class="ident">defaultwidth</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageButton.nonposinputsdef" class="name">var <span class="ident">nonposinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageButton.posinputsdef" class="name">var <span class="ident">posinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageButton.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, url, callback, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Required Inputs</p>
<ul>
<li><strong>url</strong> location of image file</li>
<li><strong>callback</strong> reference of a function to execute, passing this button object</li>
<li><strong>pos</strong> position of point</li>
</ul>
<p>Optional Inputs
<em> <strong>frame</strong> sub-frame location of image within file
</em> <strong>qty</strong> number of sub-frames, when used as sprite sheet
<em> <strong>direction</strong> one of 'horizontal' (default) or 'vertical'
</em> <strong>margin</strong> pixels between sub-frames if sprite sheet</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton.__init__" class="source">
    <pre><code>def __init__(self, url, callback, *args, **kwargs):
    """
    Required Inputs
    
    * **url** location of image file
    * **callback** reference of a function to execute, passing this button object
    * **pos** position of point
    
    Optional Inputs
    * **frame** sub-frame location of image within file
    * **qty** number of sub-frames, when used as sprite sheet
    * **direction** one of 'horizontal' (default) or 'vertical'
    * **margin** pixels between sub-frames if sprite sheet
    """
    super().__init__(url, *args, **kwargs)
    self.center = (0,0)
    self._callback = callback
    self.selectable = True
    self.firstImage()
    self.mousewasdown = self.mouseisdown
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageButton.Eval">
    <p>def <span class="ident">Eval</span>(</p><p>self, val)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton.Eval', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton.Eval" class="source">
    <pre><code>def Eval(self, val):
    if callable(val):
        self._setDynamic() # dynamically defined .. must step
        return val
    else:
        return lambda : val  
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageButton.canstroke">
    <p>def <span class="ident">canstroke</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton.canstroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton.canstroke" class="source">
    <pre><code>def canstroke(self, ppos):
    return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageButton.circularCollisionModel">
    <p>def <span class="ident">circularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton.circularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton.circularCollisionModel" class="source">
    <pre><code>def circularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageButton.collidingPolyWithPoly">
    <p>def <span class="ident">collidingPolyWithPoly</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton.collidingPolyWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton.collidingPolyWithPoly" class="source">
    <pre><code>def collidingPolyWithPoly(self, obj):
    return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageButton.collidingWith">
    <p>def <span class="ident">collidingWith</span>(</p><p>self, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a boolean True if this sprite is currently overlapping the sprite 
referenced by <code>obj</code>. Returns False if checking for collision with 
itself. Returns False if extents of object make it impossible for
collision to occur. Returns True if sprite's <code>edgedef</code> parameter overlaps
with other sprite's <code>edgedef</code> parameter, taking into consideration both
sprites' center, rotation and scale settings.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton.collidingWith', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton.collidingWith" class="source">
    <pre><code>def collidingWith(self, obj):
    """
    Return a boolean True if this sprite is currently overlapping the sprite 
    referenced by `obj`. Returns False if checking for collision with 
    itself. Returns False if extents of object make it impossible for
    collision to occur. Returns True if sprite's `edgedef` parameter overlaps
    with other sprite's `edgedef` parameter, taking into consideration both
    sprites' center, rotation and scale settings.
    """
    if self is obj:
        return False
    else:
        self._setExtents()
        obj._setExtents()
        # Gross check for overlap will usually rule out a collision
        if (self.xmin > obj.xmax
            or self.xmax < obj.xmin
            or self.ymin > obj.ymax
            or self.ymax < obj.ymin):
            return False
        # Otherwise, perform a careful overlap determination
        elif type(self.asset) is CircleAsset:
            if type(obj.asset) is CircleAsset:
                # two circles .. check distance between
                sx = (self.xmin + self.xmax) / 2
                sy = (self.ymin + self.ymax) / 2
                ox = (obj.xmin + obj.xmax) / 2
                oy = (obj.ymin + obj.ymax) / 2
                d = math.sqrt((sx-ox)**2 + (sy-oy)**2)
                return d <= self.width/2 + obj.width/2
            else:
                return self.collidingCircleWithPoly(self, obj)
        else:
            if type(obj.asset) is CircleAsset:
                return self.collidingCircleWithPoly(obj, self)
            else:
                return self.collidingPolyWithPoly(obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageButton.collidingWithSprites">
    <p>def <span class="ident">collidingWithSprites</span>(</p><p>self, sclass=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a list of sprite objects identified by the <code>sclass</code> parameter
that are currently colliding with (that is, with which the <code>ggame.Sprite.collidingWith</code>
method returns True) this sprite. If <code>sclass</code> is set to <code>None</code> (default), then
all other sprites are checked for collision, otherwise, only sprites whose
class matches <code>sclass</code> are checked.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton.collidingWithSprites', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton.collidingWithSprites" class="source">
    <pre><code>def collidingWithSprites(self, sclass = None):
    """
    Return a list of sprite objects identified by the `sclass` parameter
    that are currently colliding with (that is, with which the `ggame.Sprite.collidingWith`
    method returns True) this sprite. If `sclass` is set to `None` (default), then
    all other sprites are checked for collision, otherwise, only sprites whose
    class matches `sclass` are checked.
    """
    if sclass is None:
        slist = App.spritelist
    else:
        slist = App.getSpritesbyClass(sclass)
    return list(filter(self.collidingWith, slist))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageButton.destroy">
    <p>def <span class="ident">destroy</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton.destroy', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton.destroy" class="source">
    <pre><code>def destroy(self):
    MathApp._removeVisual(self)
    MathApp._removeMovable(self)
    MathApp._removeStrokable(self)
    _MathDynamic.destroy(self)
    Sprite.destroy(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageButton.distanceTo">
    <p>def <span class="ident">distanceTo</span>(</p><p>self, otherpoint)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton.distanceTo', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton.distanceTo" class="source">
    <pre><code>def distanceTo(self, otherpoint):
    try:
        pos = self.posinputs.pos
        opos = otherpoint.posinputs.pos
        return MathApp.distance(pos, opos())
    except AttributeError:
        return otherpoint  # presumably a scalar - use this distance
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageButton.firstImage">
    <p>def <span class="ident">firstImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>first</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton.firstImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton.firstImage" class="source">
    <pre><code>def firstImage(self):
    """
    Select and display the *first* image used by this sprite.
    """
    self.GFX.texture = self.asset[0]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageButton.lastImage">
    <p>def <span class="ident">lastImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>last</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton.lastImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton.lastImage" class="source">
    <pre><code>def lastImage(self):
    """
    Select and display the *last* image used by this sprite.
    """
    self.GFX.texture = self.asset[-1]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageButton.mousedown">
    <p>def <span class="ident">mousedown</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton.mousedown', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton.mousedown" class="source">
    <pre><code>def mousedown(self):
    self.mouseisdown = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageButton.mouseup">
    <p>def <span class="ident">mouseup</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton.mouseup', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton.mouseup" class="source">
    <pre><code>def mouseup(self):
    self.mouseisdown = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageButton.nextImage">
    <p>def <span class="ident">nextImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>next</em> image used by this sprite.
If the current image is already the <em>last</em> image, then
the image is not advanced.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.nextImage</code> on the last image will cause the <em>first</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton.nextImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton.nextImage" class="source">
    <pre><code>def nextImage(self, wrap = False):
    """
    Select and display the *next* image used by this sprite.
    If the current image is already the *last* image, then
    the image is not advanced.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.nextImage` on the last image will cause the *first*
    image to be loaded.
    """
    self._index += 1
    if self._index >= len(self.asset):
        if wrap:
            self._index = 0
        else:
            self._index = len(self.asset)-1
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageButton.physicalPointTouching">
    <p>def <span class="ident">physicalPointTouching</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton.physicalPointTouching', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton.physicalPointTouching" class="source">
    <pre><code>def physicalPointTouching(self, ppos):
    self._setExtents()  # ensure xmin, xmax are correct
    x, y = ppos
    return x >= self.xmin and x < self.xmax and y >= self.ymin and y <= self.ymax
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageButton.prevImage">
    <p>def <span class="ident">prevImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>previous</em> image used by this sprite.
If the current image is already the <em>first</em> image, then
the image is not changed.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.prevImage</code> on the first image will cause the <em>last</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton.prevImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton.prevImage" class="source">
    <pre><code>def prevImage(self, wrap = False):
    """
    Select and display the *previous* image used by this sprite.
    If the current image is already the *first* image, then
    the image is not changed.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.prevImage` on the first image will cause the *last*
    image to be loaded.
    """
    self._index -= 1
    if self._index < 0:
        if wrap:
            self._index = len(self.asset)-1
        else:
            self._index = 0
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageButton.processEvent">
    <p>def <span class="ident">processEvent</span>(</p><p>self, event)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton.processEvent', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton.processEvent" class="source">
    <pre><code>def processEvent(self, event):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageButton.rectangularCollisionModel">
    <p>def <span class="ident">rectangularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton.rectangularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton.rectangularCollisionModel" class="source">
    <pre><code>def rectangularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageButton.select">
    <p>def <span class="ident">select</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton.select', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton.select" class="source">
    <pre><code>def select(self):
    super().select()
    if self._callback: self._callback(self)
    self.unselect()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageButton.setImage">
    <p>def <span class="ident">setImage</span>(</p><p>self, index=0)</p>
    </div>
    

    
  
    <div class="desc"><p>Select the image to display by giving its <code>index</code>, where an index
of zero represents the <em>first</em> image in the asset.</p>
<p>This is equivalent to setting the <code>ggame.Sprite.index</code> property
directly.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton.setImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton.setImage" class="source">
    <pre><code>def setImage(self, index=0):
    """
    Select the image to display by giving its `index`, where an index
    of zero represents the *first* image in the asset.
    This is equivalent to setting the `ggame.Sprite.index` property
    directly.
    """
    self.index = index
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageButton.step">
    <p>def <span class="ident">step</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton.step', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton.step" class="source">
    <pre><code>def step(self):
    pass  # FIXME
    self._touchAsset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageButton.stroke">
    <p>def <span class="ident">stroke</span>(</p><p>self, ppos, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton.stroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton.stroke" class="source">
    <pre><code>def stroke(self, ppos, pdisp):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageButton.translate">
    <p>def <span class="ident">translate</span>(</p><p>self, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton.translate', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton.translate" class="source">
    <pre><code>def translate(self, pdisp):
    ldisp = MathApp.translatePhysicalToLogical(pdisp)
    pos = self.posinputs.pos()
    self.posinputs = self.posinputs._replace(pos=self.Eval((pos[0] + ldisp[0], pos[1] + ldisp[1])))
    self._touchAsset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageButton.unselect">
    <p>def <span class="ident">unselect</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton.unselect', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton.unselect" class="source">
    <pre><code>def unselect(self):
    super().unselect()
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggmath.InputImageButton.center" class="name">var <span class="ident">center</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageButton.fxcenter" class="name">var <span class="ident">fxcenter</span></p>
            

            
  
    <div class="desc"><p>This represents the horizontal position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its left hand edge. A value of 1.0 refers to its 
right hand edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageButton.fycenter" class="name">var <span class="ident">fycenter</span></p>
            

            
  
    <div class="desc"><p>This represents the vertical position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its top edge. A value of 1.0 refers to its 
bottom edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageButton.height" class="name">var <span class="ident">height</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display height of the sprite.
Assigning a value to the height will scale the image vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageButton.index" class="name">var <span class="ident">index</span></p>
            

            
  
    <div class="desc"><p>This is an integer index in to the list of images available for this sprite.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageButton.mousewasdown" class="name">var <span class="ident">mousewasdown</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageButton.movable" class="name">var <span class="ident">movable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageButton.position" class="name">var <span class="ident">position</span></p>
            

            
  
    <div class="desc"><p>This represents the (x,y) coordinates of the sprite on the screen. Assigning
a value to this attribute will move the sprite to the new coordinates.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageButton.rotation" class="name">var <span class="ident">rotation</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the rotation of the sprite on the screen.
Value may be a floating point number. A value of 0.0 means no rotation. A value 
of 1.0 means  a rotation of 1 radian in a counter-clockwise direction. One radian
is 180/pi or approximately 57.3 degrees.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageButton.scale" class="name">var <span class="ident">scale</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the size of the sprite ('scale' it) on the 
screen. Value may be a floating point number. A value of 1.0 means that the sprite
image will keep its original size. A value of 2.0 would double it, etc.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageButton.selectable" class="name">var <span class="ident">selectable</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#ggmath.ImagePoint">ImagePoint</a></code>.<code><a href="#ggmath.ImagePoint.selectable">selectable</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageButton.strokable" class="name">var <span class="ident">strokable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageButton.visible" class="name">var <span class="ident">visible</span></p>
            

            
  
    <div class="desc"><p>This boolean attribute may be used to change the visibility of the sprite. Setting
<code>ggame.Sprite.visible</code> to <code>False</code> will prevent the sprite from rendering on the 
screen.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageButton.width" class="name">var <span class="ident">width</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display width of the sprite.
Assigning a value to the width will scale the image horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageButton.x" class="name">var <span class="ident">x</span></p>
            

            
  
    <div class="desc"><p>This represents the x-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageButton.y" class="name">var <span class="ident">y</span></p>
            

            
  
    <div class="desc"><p>This represents the y-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageButton.collidingCircleWithPoly">
    <p>def <span class="ident">collidingCircleWithPoly</span>(</p><p>cls, circ, poly)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageButton.collidingCircleWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageButton.collidingCircleWithPoly" class="source">
    <pre><code>@classmethod
def collidingCircleWithPoly(cls, circ, poly):
    return True
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ggmath.InputImageToggle" class="name">class <span class="ident">InputImageToggle</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle" class="source">
    <pre><code>class InputImageToggle(ImagePoint):

    def __init__(self, url, statelist, initindex, *args, **kwargs):
        """
        Required Inputs
        
        * **url** location of image file
        * **statelist** list of values to correspond with toggle states
        * **initindex** index to initial toggle state
        * **pos** position of point
        
        Optional Inputs
        * **frame** sub-frame location of image within file
        * **direction** for sprite sheet one of 'horizontal' (default) or 'vertical'
        * **margin** pixels between sub-frames if sprite sheet
        * Note the qty of images is equal to length of the statelist
        """
        self.statelist = statelist
        kwargs.setdefault('qty', len(statelist))
        super().__init__(url, *args, **kwargs)
        self.center = (0,0)
        self.selectable = True
        self.togglestate = initindex
        self.setImage(self.togglestate)

    def select(self):
        super().select()
        self.togglestate += 1
        if self.togglestate == len(self.statelist):
            self.togglestate = 0
        self.setImage(self.togglestate)
        self.unselect()

    def __call__(self):
        return self.statelist[self.togglestate]
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggmath.InputImageToggle">InputImageToggle</a></li>
          <li><a href="#ggmath.ImagePoint">ImagePoint</a></li>
          <li>__pdoc_file_module__._Point</li>
          <li>__pdoc_file_module__._MathVisual</li>
          <li>ggame.Sprite</li>
          <li>__pdoc_file_module__._MathDynamic</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="ggmath.InputImageToggle.defaultcolor" class="name">var <span class="ident">defaultcolor</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageToggle.defaultsize" class="name">var <span class="ident">defaultsize</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageToggle.defaultstyle" class="name">var <span class="ident">defaultstyle</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageToggle.defaultwidth" class="name">var <span class="ident">defaultwidth</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageToggle.nonposinputsdef" class="name">var <span class="ident">nonposinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageToggle.posinputsdef" class="name">var <span class="ident">posinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageToggle.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, url, statelist, initindex, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Required Inputs</p>
<ul>
<li><strong>url</strong> location of image file</li>
<li><strong>statelist</strong> list of values to correspond with toggle states</li>
<li><strong>initindex</strong> index to initial toggle state</li>
<li><strong>pos</strong> position of point</li>
</ul>
<p>Optional Inputs
<em> <strong>frame</strong> sub-frame location of image within file
</em> <strong>direction</strong> for sprite sheet one of 'horizontal' (default) or 'vertical'
<em> <strong>margin</strong> pixels between sub-frames if sprite sheet
</em> Note the qty of images is equal to length of the statelist</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle.__init__" class="source">
    <pre><code>def __init__(self, url, statelist, initindex, *args, **kwargs):
    """
    Required Inputs
    
    * **url** location of image file
    * **statelist** list of values to correspond with toggle states
    * **initindex** index to initial toggle state
    * **pos** position of point
    
    Optional Inputs
    * **frame** sub-frame location of image within file
    * **direction** for sprite sheet one of 'horizontal' (default) or 'vertical'
    * **margin** pixels between sub-frames if sprite sheet
    * Note the qty of images is equal to length of the statelist
    """
    self.statelist = statelist
    kwargs.setdefault('qty', len(statelist))
    super().__init__(url, *args, **kwargs)
    self.center = (0,0)
    self.selectable = True
    self.togglestate = initindex
    self.setImage(self.togglestate)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageToggle.Eval">
    <p>def <span class="ident">Eval</span>(</p><p>self, val)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle.Eval', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle.Eval" class="source">
    <pre><code>def Eval(self, val):
    if callable(val):
        self._setDynamic() # dynamically defined .. must step
        return val
    else:
        return lambda : val  
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageToggle.canstroke">
    <p>def <span class="ident">canstroke</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle.canstroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle.canstroke" class="source">
    <pre><code>def canstroke(self, ppos):
    return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageToggle.circularCollisionModel">
    <p>def <span class="ident">circularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle.circularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle.circularCollisionModel" class="source">
    <pre><code>def circularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageToggle.collidingPolyWithPoly">
    <p>def <span class="ident">collidingPolyWithPoly</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle.collidingPolyWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle.collidingPolyWithPoly" class="source">
    <pre><code>def collidingPolyWithPoly(self, obj):
    return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageToggle.collidingWith">
    <p>def <span class="ident">collidingWith</span>(</p><p>self, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a boolean True if this sprite is currently overlapping the sprite 
referenced by <code>obj</code>. Returns False if checking for collision with 
itself. Returns False if extents of object make it impossible for
collision to occur. Returns True if sprite's <code>edgedef</code> parameter overlaps
with other sprite's <code>edgedef</code> parameter, taking into consideration both
sprites' center, rotation and scale settings.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle.collidingWith', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle.collidingWith" class="source">
    <pre><code>def collidingWith(self, obj):
    """
    Return a boolean True if this sprite is currently overlapping the sprite 
    referenced by `obj`. Returns False if checking for collision with 
    itself. Returns False if extents of object make it impossible for
    collision to occur. Returns True if sprite's `edgedef` parameter overlaps
    with other sprite's `edgedef` parameter, taking into consideration both
    sprites' center, rotation and scale settings.
    """
    if self is obj:
        return False
    else:
        self._setExtents()
        obj._setExtents()
        # Gross check for overlap will usually rule out a collision
        if (self.xmin > obj.xmax
            or self.xmax < obj.xmin
            or self.ymin > obj.ymax
            or self.ymax < obj.ymin):
            return False
        # Otherwise, perform a careful overlap determination
        elif type(self.asset) is CircleAsset:
            if type(obj.asset) is CircleAsset:
                # two circles .. check distance between
                sx = (self.xmin + self.xmax) / 2
                sy = (self.ymin + self.ymax) / 2
                ox = (obj.xmin + obj.xmax) / 2
                oy = (obj.ymin + obj.ymax) / 2
                d = math.sqrt((sx-ox)**2 + (sy-oy)**2)
                return d <= self.width/2 + obj.width/2
            else:
                return self.collidingCircleWithPoly(self, obj)
        else:
            if type(obj.asset) is CircleAsset:
                return self.collidingCircleWithPoly(obj, self)
            else:
                return self.collidingPolyWithPoly(obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageToggle.collidingWithSprites">
    <p>def <span class="ident">collidingWithSprites</span>(</p><p>self, sclass=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a list of sprite objects identified by the <code>sclass</code> parameter
that are currently colliding with (that is, with which the <code>ggame.Sprite.collidingWith</code>
method returns True) this sprite. If <code>sclass</code> is set to <code>None</code> (default), then
all other sprites are checked for collision, otherwise, only sprites whose
class matches <code>sclass</code> are checked.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle.collidingWithSprites', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle.collidingWithSprites" class="source">
    <pre><code>def collidingWithSprites(self, sclass = None):
    """
    Return a list of sprite objects identified by the `sclass` parameter
    that are currently colliding with (that is, with which the `ggame.Sprite.collidingWith`
    method returns True) this sprite. If `sclass` is set to `None` (default), then
    all other sprites are checked for collision, otherwise, only sprites whose
    class matches `sclass` are checked.
    """
    if sclass is None:
        slist = App.spritelist
    else:
        slist = App.getSpritesbyClass(sclass)
    return list(filter(self.collidingWith, slist))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageToggle.destroy">
    <p>def <span class="ident">destroy</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle.destroy', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle.destroy" class="source">
    <pre><code>def destroy(self):
    MathApp._removeVisual(self)
    MathApp._removeMovable(self)
    MathApp._removeStrokable(self)
    _MathDynamic.destroy(self)
    Sprite.destroy(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageToggle.distanceTo">
    <p>def <span class="ident">distanceTo</span>(</p><p>self, otherpoint)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle.distanceTo', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle.distanceTo" class="source">
    <pre><code>def distanceTo(self, otherpoint):
    try:
        pos = self.posinputs.pos
        opos = otherpoint.posinputs.pos
        return MathApp.distance(pos, opos())
    except AttributeError:
        return otherpoint  # presumably a scalar - use this distance
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageToggle.firstImage">
    <p>def <span class="ident">firstImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>first</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle.firstImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle.firstImage" class="source">
    <pre><code>def firstImage(self):
    """
    Select and display the *first* image used by this sprite.
    """
    self.GFX.texture = self.asset[0]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageToggle.lastImage">
    <p>def <span class="ident">lastImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>last</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle.lastImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle.lastImage" class="source">
    <pre><code>def lastImage(self):
    """
    Select and display the *last* image used by this sprite.
    """
    self.GFX.texture = self.asset[-1]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageToggle.mousedown">
    <p>def <span class="ident">mousedown</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle.mousedown', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle.mousedown" class="source">
    <pre><code>def mousedown(self):
    self.mouseisdown = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageToggle.mouseup">
    <p>def <span class="ident">mouseup</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle.mouseup', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle.mouseup" class="source">
    <pre><code>def mouseup(self):
    self.mouseisdown = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageToggle.nextImage">
    <p>def <span class="ident">nextImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>next</em> image used by this sprite.
If the current image is already the <em>last</em> image, then
the image is not advanced.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.nextImage</code> on the last image will cause the <em>first</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle.nextImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle.nextImage" class="source">
    <pre><code>def nextImage(self, wrap = False):
    """
    Select and display the *next* image used by this sprite.
    If the current image is already the *last* image, then
    the image is not advanced.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.nextImage` on the last image will cause the *first*
    image to be loaded.
    """
    self._index += 1
    if self._index >= len(self.asset):
        if wrap:
            self._index = 0
        else:
            self._index = len(self.asset)-1
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageToggle.physicalPointTouching">
    <p>def <span class="ident">physicalPointTouching</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle.physicalPointTouching', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle.physicalPointTouching" class="source">
    <pre><code>def physicalPointTouching(self, ppos):
    self._setExtents()  # ensure xmin, xmax are correct
    x, y = ppos
    return x >= self.xmin and x < self.xmax and y >= self.ymin and y <= self.ymax
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageToggle.prevImage">
    <p>def <span class="ident">prevImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>previous</em> image used by this sprite.
If the current image is already the <em>first</em> image, then
the image is not changed.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.prevImage</code> on the first image will cause the <em>last</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle.prevImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle.prevImage" class="source">
    <pre><code>def prevImage(self, wrap = False):
    """
    Select and display the *previous* image used by this sprite.
    If the current image is already the *first* image, then
    the image is not changed.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.prevImage` on the first image will cause the *last*
    image to be loaded.
    """
    self._index -= 1
    if self._index < 0:
        if wrap:
            self._index = len(self.asset)-1
        else:
            self._index = 0
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageToggle.processEvent">
    <p>def <span class="ident">processEvent</span>(</p><p>self, event)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle.processEvent', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle.processEvent" class="source">
    <pre><code>def processEvent(self, event):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageToggle.rectangularCollisionModel">
    <p>def <span class="ident">rectangularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle.rectangularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle.rectangularCollisionModel" class="source">
    <pre><code>def rectangularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageToggle.select">
    <p>def <span class="ident">select</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle.select', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle.select" class="source">
    <pre><code>def select(self):
    super().select()
    self.togglestate += 1
    if self.togglestate == len(self.statelist):
        self.togglestate = 0
    self.setImage(self.togglestate)
    self.unselect()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageToggle.setImage">
    <p>def <span class="ident">setImage</span>(</p><p>self, index=0)</p>
    </div>
    

    
  
    <div class="desc"><p>Select the image to display by giving its <code>index</code>, where an index
of zero represents the <em>first</em> image in the asset.</p>
<p>This is equivalent to setting the <code>ggame.Sprite.index</code> property
directly.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle.setImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle.setImage" class="source">
    <pre><code>def setImage(self, index=0):
    """
    Select the image to display by giving its `index`, where an index
    of zero represents the *first* image in the asset.
    This is equivalent to setting the `ggame.Sprite.index` property
    directly.
    """
    self.index = index
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageToggle.step">
    <p>def <span class="ident">step</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle.step', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle.step" class="source">
    <pre><code>def step(self):
    pass  # FIXME
    self._touchAsset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageToggle.stroke">
    <p>def <span class="ident">stroke</span>(</p><p>self, ppos, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle.stroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle.stroke" class="source">
    <pre><code>def stroke(self, ppos, pdisp):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageToggle.translate">
    <p>def <span class="ident">translate</span>(</p><p>self, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle.translate', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle.translate" class="source">
    <pre><code>def translate(self, pdisp):
    ldisp = MathApp.translatePhysicalToLogical(pdisp)
    pos = self.posinputs.pos()
    self.posinputs = self.posinputs._replace(pos=self.Eval((pos[0] + ldisp[0], pos[1] + ldisp[1])))
    self._touchAsset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageToggle.unselect">
    <p>def <span class="ident">unselect</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle.unselect', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle.unselect" class="source">
    <pre><code>def unselect(self):
    self.selected = False
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggmath.InputImageToggle.center" class="name">var <span class="ident">center</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageToggle.fxcenter" class="name">var <span class="ident">fxcenter</span></p>
            

            
  
    <div class="desc"><p>This represents the horizontal position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its left hand edge. A value of 1.0 refers to its 
right hand edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageToggle.fycenter" class="name">var <span class="ident">fycenter</span></p>
            

            
  
    <div class="desc"><p>This represents the vertical position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its top edge. A value of 1.0 refers to its 
bottom edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageToggle.height" class="name">var <span class="ident">height</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display height of the sprite.
Assigning a value to the height will scale the image vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageToggle.index" class="name">var <span class="ident">index</span></p>
            

            
  
    <div class="desc"><p>This is an integer index in to the list of images available for this sprite.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageToggle.movable" class="name">var <span class="ident">movable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageToggle.position" class="name">var <span class="ident">position</span></p>
            

            
  
    <div class="desc"><p>This represents the (x,y) coordinates of the sprite on the screen. Assigning
a value to this attribute will move the sprite to the new coordinates.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageToggle.rotation" class="name">var <span class="ident">rotation</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the rotation of the sprite on the screen.
Value may be a floating point number. A value of 0.0 means no rotation. A value 
of 1.0 means  a rotation of 1 radian in a counter-clockwise direction. One radian
is 180/pi or approximately 57.3 degrees.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageToggle.scale" class="name">var <span class="ident">scale</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the size of the sprite ('scale' it) on the 
screen. Value may be a floating point number. A value of 1.0 means that the sprite
image will keep its original size. A value of 2.0 would double it, etc.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageToggle.selectable" class="name">var <span class="ident">selectable</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#ggmath.ImagePoint">ImagePoint</a></code>.<code><a href="#ggmath.ImagePoint.selectable">selectable</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageToggle.statelist" class="name">var <span class="ident">statelist</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageToggle.strokable" class="name">var <span class="ident">strokable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageToggle.togglestate" class="name">var <span class="ident">togglestate</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageToggle.visible" class="name">var <span class="ident">visible</span></p>
            

            
  
    <div class="desc"><p>This boolean attribute may be used to change the visibility of the sprite. Setting
<code>ggame.Sprite.visible</code> to <code>False</code> will prevent the sprite from rendering on the 
screen.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageToggle.width" class="name">var <span class="ident">width</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display width of the sprite.
Assigning a value to the width will scale the image horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageToggle.x" class="name">var <span class="ident">x</span></p>
            

            
  
    <div class="desc"><p>This represents the x-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputImageToggle.y" class="name">var <span class="ident">y</span></p>
            

            
  
    <div class="desc"><p>This represents the y-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.InputImageToggle.collidingCircleWithPoly">
    <p>def <span class="ident">collidingCircleWithPoly</span>(</p><p>cls, circ, poly)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputImageToggle.collidingCircleWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputImageToggle.collidingCircleWithPoly" class="source">
    <pre><code>@classmethod
def collidingCircleWithPoly(cls, circ, poly):
    return True
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ggmath.InputNumeric" class="name">class <span class="ident">InputNumeric</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputNumeric', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputNumeric" class="source">
    <pre><code>class InputNumeric(Label):
    
    def __init__(self, pos, val, **kwargs):
        """
        Required Inputs
        
        * **pos** position of button
        * **val** initial value of input
        
        Optional Keyword Input
        * **fmt** a Python format string (default is {0.2})
        """
        self._fmt = kwargs.get('fmt', '{0.2}')
        self._val = self.Eval(val)()  # initialize to simple numeric
        self._savedval = self._val
        self._updateText()
        super().__init__(pos, self._textValue, **kwargs)
        self.selectable = True
        
    def _textValue(self):
        return self._text()

    def _updateText(self):
        self._text = self.Eval(self._fmt.format(self._val))

    def processEvent(self, event):
        if event.key in "0123456789insertdelete":
            key = event.key
            if event.key == 'insert':
                key = '-'
            elif event.key == 'delete':
                key = '.'
            if self._text() == "0":
                self._text = self.Eval("")
            self._text = self.Eval(self._text() + key)
            self._touchAsset()
        elif event.key in ['enter','escape']:
            if event.key == 'enter':
                try:
                    self._val = float(self._text())
                except ValueError:
                    self._val = self._savedval
                self._savedval = self._val
            self.unselect()
            

    def select(self):
        super().select()
        self._savedval = self._val
        self._val = 0
        self._updateText()
        self._touchAsset()
        MathApp.listenKeyEvent("keypress", "*", self.processEvent)

    def unselect(self):
        super().unselect()
        self._val = self._savedval
        self._updateText()
        self._touchAsset()
        try:
            MathApp.unlistenKeyEvent("keypress", "*", self.processEvent)
        except ValueError:
            pass

    def __call__(self):
        return self._val
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggmath.InputNumeric">InputNumeric</a></li>
          <li><a href="#ggmath.Label">Label</a></li>
          <li>__pdoc_file_module__._MathVisual</li>
          <li>ggame.Sprite</li>
          <li>__pdoc_file_module__._MathDynamic</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="ggmath.InputNumeric.defaultcolor" class="name">var <span class="ident">defaultcolor</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputNumeric.defaultsize" class="name">var <span class="ident">defaultsize</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputNumeric.defaultstyle" class="name">var <span class="ident">defaultstyle</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputNumeric.defaultwidth" class="name">var <span class="ident">defaultwidth</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputNumeric.nonposinputsdef" class="name">var <span class="ident">nonposinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputNumeric.posinputsdef" class="name">var <span class="ident">posinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.InputNumeric.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, pos, val, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Required Inputs</p>
<ul>
<li><strong>pos</strong> position of button</li>
<li><strong>val</strong> initial value of input</li>
</ul>
<p>Optional Keyword Input
* <strong>fmt</strong> a Python format string (default is {0.2})</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputNumeric.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputNumeric.__init__" class="source">
    <pre><code>def __init__(self, pos, val, **kwargs):
    """
    Required Inputs
    
    * **pos** position of button
    * **val** initial value of input
    
    Optional Keyword Input
    * **fmt** a Python format string (default is {0.2})
    """
    self._fmt = kwargs.get('fmt', '{0.2}')
    self._val = self.Eval(val)()  # initialize to simple numeric
    self._savedval = self._val
    self._updateText()
    super().__init__(pos, self._textValue, **kwargs)
    self.selectable = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputNumeric.Eval">
    <p>def <span class="ident">Eval</span>(</p><p>self, val)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputNumeric.Eval', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputNumeric.Eval" class="source">
    <pre><code>def Eval(self, val):
    if callable(val):
        self._setDynamic() # dynamically defined .. must step
        return val
    else:
        return lambda : val  
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputNumeric.canstroke">
    <p>def <span class="ident">canstroke</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputNumeric.canstroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputNumeric.canstroke" class="source">
    <pre><code>def canstroke(self, ppos):
    return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputNumeric.circularCollisionModel">
    <p>def <span class="ident">circularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputNumeric.circularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputNumeric.circularCollisionModel" class="source">
    <pre><code>def circularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputNumeric.collidingPolyWithPoly">
    <p>def <span class="ident">collidingPolyWithPoly</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputNumeric.collidingPolyWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputNumeric.collidingPolyWithPoly" class="source">
    <pre><code>def collidingPolyWithPoly(self, obj):
    return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputNumeric.collidingWith">
    <p>def <span class="ident">collidingWith</span>(</p><p>self, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a boolean True if this sprite is currently overlapping the sprite 
referenced by <code>obj</code>. Returns False if checking for collision with 
itself. Returns False if extents of object make it impossible for
collision to occur. Returns True if sprite's <code>edgedef</code> parameter overlaps
with other sprite's <code>edgedef</code> parameter, taking into consideration both
sprites' center, rotation and scale settings.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputNumeric.collidingWith', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputNumeric.collidingWith" class="source">
    <pre><code>def collidingWith(self, obj):
    """
    Return a boolean True if this sprite is currently overlapping the sprite 
    referenced by `obj`. Returns False if checking for collision with 
    itself. Returns False if extents of object make it impossible for
    collision to occur. Returns True if sprite's `edgedef` parameter overlaps
    with other sprite's `edgedef` parameter, taking into consideration both
    sprites' center, rotation and scale settings.
    """
    if self is obj:
        return False
    else:
        self._setExtents()
        obj._setExtents()
        # Gross check for overlap will usually rule out a collision
        if (self.xmin > obj.xmax
            or self.xmax < obj.xmin
            or self.ymin > obj.ymax
            or self.ymax < obj.ymin):
            return False
        # Otherwise, perform a careful overlap determination
        elif type(self.asset) is CircleAsset:
            if type(obj.asset) is CircleAsset:
                # two circles .. check distance between
                sx = (self.xmin + self.xmax) / 2
                sy = (self.ymin + self.ymax) / 2
                ox = (obj.xmin + obj.xmax) / 2
                oy = (obj.ymin + obj.ymax) / 2
                d = math.sqrt((sx-ox)**2 + (sy-oy)**2)
                return d <= self.width/2 + obj.width/2
            else:
                return self.collidingCircleWithPoly(self, obj)
        else:
            if type(obj.asset) is CircleAsset:
                return self.collidingCircleWithPoly(obj, self)
            else:
                return self.collidingPolyWithPoly(obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputNumeric.collidingWithSprites">
    <p>def <span class="ident">collidingWithSprites</span>(</p><p>self, sclass=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a list of sprite objects identified by the <code>sclass</code> parameter
that are currently colliding with (that is, with which the <code>ggame.Sprite.collidingWith</code>
method returns True) this sprite. If <code>sclass</code> is set to <code>None</code> (default), then
all other sprites are checked for collision, otherwise, only sprites whose
class matches <code>sclass</code> are checked.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputNumeric.collidingWithSprites', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputNumeric.collidingWithSprites" class="source">
    <pre><code>def collidingWithSprites(self, sclass = None):
    """
    Return a list of sprite objects identified by the `sclass` parameter
    that are currently colliding with (that is, with which the `ggame.Sprite.collidingWith`
    method returns True) this sprite. If `sclass` is set to `None` (default), then
    all other sprites are checked for collision, otherwise, only sprites whose
    class matches `sclass` are checked.
    """
    if sclass is None:
        slist = App.spritelist
    else:
        slist = App.getSpritesbyClass(sclass)
    return list(filter(self.collidingWith, slist))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputNumeric.destroy">
    <p>def <span class="ident">destroy</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputNumeric.destroy', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputNumeric.destroy" class="source">
    <pre><code>def destroy(self):
    MathApp._removeVisual(self)
    MathApp._removeMovable(self)
    MathApp._removeStrokable(self)
    _MathDynamic.destroy(self)
    Sprite.destroy(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputNumeric.firstImage">
    <p>def <span class="ident">firstImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>first</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputNumeric.firstImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputNumeric.firstImage" class="source">
    <pre><code>def firstImage(self):
    """
    Select and display the *first* image used by this sprite.
    """
    self.GFX.texture = self.asset[0]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputNumeric.lastImage">
    <p>def <span class="ident">lastImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>last</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputNumeric.lastImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputNumeric.lastImage" class="source">
    <pre><code>def lastImage(self):
    """
    Select and display the *last* image used by this sprite.
    """
    self.GFX.texture = self.asset[-1]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputNumeric.mousedown">
    <p>def <span class="ident">mousedown</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputNumeric.mousedown', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputNumeric.mousedown" class="source">
    <pre><code>def mousedown(self):
    self.mouseisdown = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputNumeric.mouseup">
    <p>def <span class="ident">mouseup</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputNumeric.mouseup', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputNumeric.mouseup" class="source">
    <pre><code>def mouseup(self):
    self.mouseisdown = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputNumeric.nextImage">
    <p>def <span class="ident">nextImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>next</em> image used by this sprite.
If the current image is already the <em>last</em> image, then
the image is not advanced.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.nextImage</code> on the last image will cause the <em>first</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputNumeric.nextImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputNumeric.nextImage" class="source">
    <pre><code>def nextImage(self, wrap = False):
    """
    Select and display the *next* image used by this sprite.
    If the current image is already the *last* image, then
    the image is not advanced.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.nextImage` on the last image will cause the *first*
    image to be loaded.
    """
    self._index += 1
    if self._index >= len(self.asset):
        if wrap:
            self._index = 0
        else:
            self._index = len(self.asset)-1
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputNumeric.physicalPointTouching">
    <p>def <span class="ident">physicalPointTouching</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputNumeric.physicalPointTouching', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputNumeric.physicalPointTouching" class="source">
    <pre><code>def physicalPointTouching(self, ppos):
    _ppos = self.spposinputs.pos
    return (ppos[0] >= _ppos[0] and 
        ppos[0] <= _ppos[0] + self.sstdinputs.width and
        ppos[1] >= _ppos[1] and 
        ppos[1] <= _ppos[1] + self.sstdinputs.size)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputNumeric.prevImage">
    <p>def <span class="ident">prevImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>previous</em> image used by this sprite.
If the current image is already the <em>first</em> image, then
the image is not changed.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.prevImage</code> on the first image will cause the <em>last</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputNumeric.prevImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputNumeric.prevImage" class="source">
    <pre><code>def prevImage(self, wrap = False):
    """
    Select and display the *previous* image used by this sprite.
    If the current image is already the *first* image, then
    the image is not changed.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.prevImage` on the first image will cause the *last*
    image to be loaded.
    """
    self._index -= 1
    if self._index < 0:
        if wrap:
            self._index = len(self.asset)-1
        else:
            self._index = 0
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputNumeric.processEvent">
    <p>def <span class="ident">processEvent</span>(</p><p>self, event)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputNumeric.processEvent', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputNumeric.processEvent" class="source">
    <pre><code>def processEvent(self, event):
    if event.key in "0123456789insertdelete":
        key = event.key
        if event.key == 'insert':
            key = '-'
        elif event.key == 'delete':
            key = '.'
        if self._text() == "0":
            self._text = self.Eval("")
        self._text = self.Eval(self._text() + key)
        self._touchAsset()
    elif event.key in ['enter','escape']:
        if event.key == 'enter':
            try:
                self._val = float(self._text())
            except ValueError:
                self._val = self._savedval
            self._savedval = self._val
        self.unselect()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputNumeric.rectangularCollisionModel">
    <p>def <span class="ident">rectangularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputNumeric.rectangularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputNumeric.rectangularCollisionModel" class="source">
    <pre><code>def rectangularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputNumeric.select">
    <p>def <span class="ident">select</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputNumeric.select', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputNumeric.select" class="source">
    <pre><code>def select(self):
    super().select()
    self._savedval = self._val
    self._val = 0
    self._updateText()
    self._touchAsset()
    MathApp.listenKeyEvent("keypress", "*", self.processEvent)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputNumeric.setImage">
    <p>def <span class="ident">setImage</span>(</p><p>self, index=0)</p>
    </div>
    

    
  
    <div class="desc"><p>Select the image to display by giving its <code>index</code>, where an index
of zero represents the <em>first</em> image in the asset.</p>
<p>This is equivalent to setting the <code>ggame.Sprite.index</code> property
directly.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputNumeric.setImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputNumeric.setImage" class="source">
    <pre><code>def setImage(self, index=0):
    """
    Select the image to display by giving its `index`, where an index
    of zero represents the *first* image in the asset.
    This is equivalent to setting the `ggame.Sprite.index` property
    directly.
    """
    self.index = index
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputNumeric.step">
    <p>def <span class="ident">step</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputNumeric.step', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputNumeric.step" class="source">
    <pre><code>def step(self):
    self._touchAsset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputNumeric.stroke">
    <p>def <span class="ident">stroke</span>(</p><p>self, ppos, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputNumeric.stroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputNumeric.stroke" class="source">
    <pre><code>def stroke(self, ppos, pdisp):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputNumeric.translate">
    <p>def <span class="ident">translate</span>(</p><p>self, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputNumeric.translate', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputNumeric.translate" class="source">
    <pre><code>def translate(self, pdisp):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.InputNumeric.unselect">
    <p>def <span class="ident">unselect</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputNumeric.unselect', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputNumeric.unselect" class="source">
    <pre><code>def unselect(self):
    super().unselect()
    self._val = self._savedval
    self._updateText()
    self._touchAsset()
    try:
        MathApp.unlistenKeyEvent("keypress", "*", self.processEvent)
    except ValueError:
        pass
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggmath.InputNumeric.center" class="name">var <span class="ident">center</span></p>
            

            
  
    <div class="desc"><p>This attribute represents the horizontal and vertical position of the 
sprite "center" as a tuple of floating point numbers. See the 
descriptions for <code>ggame.Sprite.fxcenter</code> and <code>ggame.Sprite.fycenter</code> for 
more details.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputNumeric.fxcenter" class="name">var <span class="ident">fxcenter</span></p>
            

            
  
    <div class="desc"><p>This represents the horizontal position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its left hand edge. A value of 1.0 refers to its 
right hand edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputNumeric.fycenter" class="name">var <span class="ident">fycenter</span></p>
            

            
  
    <div class="desc"><p>This represents the vertical position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its top edge. A value of 1.0 refers to its 
bottom edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputNumeric.height" class="name">var <span class="ident">height</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display height of the sprite.
Assigning a value to the height will scale the image vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputNumeric.index" class="name">var <span class="ident">index</span></p>
            

            
  
    <div class="desc"><p>This is an integer index in to the list of images available for this sprite.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputNumeric.movable" class="name">var <span class="ident">movable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputNumeric.position" class="name">var <span class="ident">position</span></p>
            

            
  
    <div class="desc"><p>This represents the (x,y) coordinates of the sprite on the screen. Assigning
a value to this attribute will move the sprite to the new coordinates.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputNumeric.rotation" class="name">var <span class="ident">rotation</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the rotation of the sprite on the screen.
Value may be a floating point number. A value of 0.0 means no rotation. A value 
of 1.0 means  a rotation of 1 radian in a counter-clockwise direction. One radian
is 180/pi or approximately 57.3 degrees.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputNumeric.scale" class="name">var <span class="ident">scale</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the size of the sprite ('scale' it) on the 
screen. Value may be a floating point number. A value of 1.0 means that the sprite
image will keep its original size. A value of 2.0 would double it, etc.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputNumeric.selectable" class="name">var <span class="ident">selectable</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#ggmath.Label">Label</a></code>.<code><a href="#ggmath.Label.selectable">selectable</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputNumeric.strokable" class="name">var <span class="ident">strokable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputNumeric.visible" class="name">var <span class="ident">visible</span></p>
            

            
  
    <div class="desc"><p>This boolean attribute may be used to change the visibility of the sprite. Setting
<code>ggame.Sprite.visible</code> to <code>False</code> will prevent the sprite from rendering on the 
screen.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputNumeric.width" class="name">var <span class="ident">width</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display width of the sprite.
Assigning a value to the width will scale the image horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputNumeric.x" class="name">var <span class="ident">x</span></p>
            

            
  
    <div class="desc"><p>This represents the x-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.InputNumeric.y" class="name">var <span class="ident">y</span></p>
            

            
  
    <div class="desc"><p>This represents the y-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.InputNumeric.collidingCircleWithPoly">
    <p>def <span class="ident">collidingCircleWithPoly</span>(</p><p>cls, circ, poly)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.InputNumeric.collidingCircleWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.InputNumeric.collidingCircleWithPoly" class="source">
    <pre><code>@classmethod
def collidingCircleWithPoly(cls, circ, poly):
    return True
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ggmath.LEDIndicator" class="name">class <span class="ident">LEDIndicator</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LEDIndicator', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LEDIndicator" class="source">
    <pre><code>class LEDIndicator(ImageIndicator):
    
    def __init__(self, *args, **kwargs):
        """
        Required Inputs
        
        * **pos** position of point
        * **value** state of the indicator (True/False or integer)

        """
        kwargs.setdefault('frame', Frame(0,0,600,600))
        kwargs.setdefault('qty', 2)
        super().__init__("red-led-off-on.png", *args, **kwargs)
        self.scale = 0.05
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggmath.LEDIndicator">LEDIndicator</a></li>
          <li><a href="#ggmath.ImageIndicator">ImageIndicator</a></li>
          <li>__pdoc_file_module__._MathVisual</li>
          <li>ggame.Sprite</li>
          <li>__pdoc_file_module__._MathDynamic</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="ggmath.LEDIndicator.defaultcolor" class="name">var <span class="ident">defaultcolor</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LEDIndicator.defaultsize" class="name">var <span class="ident">defaultsize</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LEDIndicator.defaultstyle" class="name">var <span class="ident">defaultstyle</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LEDIndicator.defaultwidth" class="name">var <span class="ident">defaultwidth</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LEDIndicator.nonposinputsdef" class="name">var <span class="ident">nonposinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LEDIndicator.posinputsdef" class="name">var <span class="ident">posinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.LEDIndicator.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Required Inputs</p>
<ul>
<li><strong>pos</strong> position of point</li>
<li><strong>value</strong> state of the indicator (True/False or integer)</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LEDIndicator.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LEDIndicator.__init__" class="source">
    <pre><code>def __init__(self, *args, **kwargs):
    """
    Required Inputs
    
    * **pos** position of point
    * **value** state of the indicator (True/False or integer)
    """
    kwargs.setdefault('frame', Frame(0,0,600,600))
    kwargs.setdefault('qty', 2)
    super().__init__("red-led-off-on.png", *args, **kwargs)
    self.scale = 0.05
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LEDIndicator.Eval">
    <p>def <span class="ident">Eval</span>(</p><p>self, val)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LEDIndicator.Eval', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LEDIndicator.Eval" class="source">
    <pre><code>def Eval(self, val):
    if callable(val):
        self._setDynamic() # dynamically defined .. must step
        return val
    else:
        return lambda : val  
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LEDIndicator.canstroke">
    <p>def <span class="ident">canstroke</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LEDIndicator.canstroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LEDIndicator.canstroke" class="source">
    <pre><code>def canstroke(self, ppos):
    return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LEDIndicator.circularCollisionModel">
    <p>def <span class="ident">circularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LEDIndicator.circularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LEDIndicator.circularCollisionModel" class="source">
    <pre><code>def circularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LEDIndicator.collidingPolyWithPoly">
    <p>def <span class="ident">collidingPolyWithPoly</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LEDIndicator.collidingPolyWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LEDIndicator.collidingPolyWithPoly" class="source">
    <pre><code>def collidingPolyWithPoly(self, obj):
    return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LEDIndicator.collidingWith">
    <p>def <span class="ident">collidingWith</span>(</p><p>self, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a boolean True if this sprite is currently overlapping the sprite 
referenced by <code>obj</code>. Returns False if checking for collision with 
itself. Returns False if extents of object make it impossible for
collision to occur. Returns True if sprite's <code>edgedef</code> parameter overlaps
with other sprite's <code>edgedef</code> parameter, taking into consideration both
sprites' center, rotation and scale settings.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LEDIndicator.collidingWith', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LEDIndicator.collidingWith" class="source">
    <pre><code>def collidingWith(self, obj):
    """
    Return a boolean True if this sprite is currently overlapping the sprite 
    referenced by `obj`. Returns False if checking for collision with 
    itself. Returns False if extents of object make it impossible for
    collision to occur. Returns True if sprite's `edgedef` parameter overlaps
    with other sprite's `edgedef` parameter, taking into consideration both
    sprites' center, rotation and scale settings.
    """
    if self is obj:
        return False
    else:
        self._setExtents()
        obj._setExtents()
        # Gross check for overlap will usually rule out a collision
        if (self.xmin > obj.xmax
            or self.xmax < obj.xmin
            or self.ymin > obj.ymax
            or self.ymax < obj.ymin):
            return False
        # Otherwise, perform a careful overlap determination
        elif type(self.asset) is CircleAsset:
            if type(obj.asset) is CircleAsset:
                # two circles .. check distance between
                sx = (self.xmin + self.xmax) / 2
                sy = (self.ymin + self.ymax) / 2
                ox = (obj.xmin + obj.xmax) / 2
                oy = (obj.ymin + obj.ymax) / 2
                d = math.sqrt((sx-ox)**2 + (sy-oy)**2)
                return d <= self.width/2 + obj.width/2
            else:
                return self.collidingCircleWithPoly(self, obj)
        else:
            if type(obj.asset) is CircleAsset:
                return self.collidingCircleWithPoly(obj, self)
            else:
                return self.collidingPolyWithPoly(obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LEDIndicator.collidingWithSprites">
    <p>def <span class="ident">collidingWithSprites</span>(</p><p>self, sclass=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a list of sprite objects identified by the <code>sclass</code> parameter
that are currently colliding with (that is, with which the <code>ggame.Sprite.collidingWith</code>
method returns True) this sprite. If <code>sclass</code> is set to <code>None</code> (default), then
all other sprites are checked for collision, otherwise, only sprites whose
class matches <code>sclass</code> are checked.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LEDIndicator.collidingWithSprites', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LEDIndicator.collidingWithSprites" class="source">
    <pre><code>def collidingWithSprites(self, sclass = None):
    """
    Return a list of sprite objects identified by the `sclass` parameter
    that are currently colliding with (that is, with which the `ggame.Sprite.collidingWith`
    method returns True) this sprite. If `sclass` is set to `None` (default), then
    all other sprites are checked for collision, otherwise, only sprites whose
    class matches `sclass` are checked.
    """
    if sclass is None:
        slist = App.spritelist
    else:
        slist = App.getSpritesbyClass(sclass)
    return list(filter(self.collidingWith, slist))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LEDIndicator.destroy">
    <p>def <span class="ident">destroy</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LEDIndicator.destroy', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LEDIndicator.destroy" class="source">
    <pre><code>def destroy(self):
    MathApp._removeVisual(self)
    MathApp._removeMovable(self)
    MathApp._removeStrokable(self)
    _MathDynamic.destroy(self)
    Sprite.destroy(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LEDIndicator.firstImage">
    <p>def <span class="ident">firstImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>first</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LEDIndicator.firstImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LEDIndicator.firstImage" class="source">
    <pre><code>def firstImage(self):
    """
    Select and display the *first* image used by this sprite.
    """
    self.GFX.texture = self.asset[0]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LEDIndicator.lastImage">
    <p>def <span class="ident">lastImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>last</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LEDIndicator.lastImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LEDIndicator.lastImage" class="source">
    <pre><code>def lastImage(self):
    """
    Select and display the *last* image used by this sprite.
    """
    self.GFX.texture = self.asset[-1]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LEDIndicator.mousedown">
    <p>def <span class="ident">mousedown</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LEDIndicator.mousedown', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LEDIndicator.mousedown" class="source">
    <pre><code>def mousedown(self):
    self.mouseisdown = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LEDIndicator.mouseup">
    <p>def <span class="ident">mouseup</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LEDIndicator.mouseup', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LEDIndicator.mouseup" class="source">
    <pre><code>def mouseup(self):
    self.mouseisdown = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LEDIndicator.nextImage">
    <p>def <span class="ident">nextImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>next</em> image used by this sprite.
If the current image is already the <em>last</em> image, then
the image is not advanced.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.nextImage</code> on the last image will cause the <em>first</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LEDIndicator.nextImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LEDIndicator.nextImage" class="source">
    <pre><code>def nextImage(self, wrap = False):
    """
    Select and display the *next* image used by this sprite.
    If the current image is already the *last* image, then
    the image is not advanced.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.nextImage` on the last image will cause the *first*
    image to be loaded.
    """
    self._index += 1
    if self._index >= len(self.asset):
        if wrap:
            self._index = 0
        else:
            self._index = len(self.asset)-1
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LEDIndicator.physicalPointTouching">
    <p>def <span class="ident">physicalPointTouching</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LEDIndicator.physicalPointTouching', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LEDIndicator.physicalPointTouching" class="source">
    <pre><code>def physicalPointTouching(self, ppos):
    self._setExtents()  # ensure xmin, xmax are correct
    x, y = ppos
    return x >= self.xmin and x < self.xmax and y >= self.ymin and y <= self.ymax
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LEDIndicator.prevImage">
    <p>def <span class="ident">prevImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>previous</em> image used by this sprite.
If the current image is already the <em>first</em> image, then
the image is not changed.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.prevImage</code> on the first image will cause the <em>last</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LEDIndicator.prevImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LEDIndicator.prevImage" class="source">
    <pre><code>def prevImage(self, wrap = False):
    """
    Select and display the *previous* image used by this sprite.
    If the current image is already the *first* image, then
    the image is not changed.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.prevImage` on the first image will cause the *last*
    image to be loaded.
    """
    self._index -= 1
    if self._index < 0:
        if wrap:
            self._index = len(self.asset)-1
        else:
            self._index = 0
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LEDIndicator.processEvent">
    <p>def <span class="ident">processEvent</span>(</p><p>self, event)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LEDIndicator.processEvent', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LEDIndicator.processEvent" class="source">
    <pre><code>def processEvent(self, event):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LEDIndicator.rectangularCollisionModel">
    <p>def <span class="ident">rectangularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LEDIndicator.rectangularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LEDIndicator.rectangularCollisionModel" class="source">
    <pre><code>def rectangularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LEDIndicator.select">
    <p>def <span class="ident">select</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LEDIndicator.select', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LEDIndicator.select" class="source">
    <pre><code>def select(self):
    self.selected = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LEDIndicator.setImage">
    <p>def <span class="ident">setImage</span>(</p><p>self, index=0)</p>
    </div>
    

    
  
    <div class="desc"><p>Select the image to display by giving its <code>index</code>, where an index
of zero represents the <em>first</em> image in the asset.</p>
<p>This is equivalent to setting the <code>ggame.Sprite.index</code> property
directly.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LEDIndicator.setImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LEDIndicator.setImage" class="source">
    <pre><code>def setImage(self, index=0):
    """
    Select the image to display by giving its `index`, where an index
    of zero represents the *first* image in the asset.
    This is equivalent to setting the `ggame.Sprite.index` property
    directly.
    """
    self.index = index
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LEDIndicator.step">
    <p>def <span class="ident">step</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LEDIndicator.step', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LEDIndicator.step" class="source">
    <pre><code>def step(self):
    self._touchAsset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LEDIndicator.stroke">
    <p>def <span class="ident">stroke</span>(</p><p>self, ppos, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LEDIndicator.stroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LEDIndicator.stroke" class="source">
    <pre><code>def stroke(self, ppos, pdisp):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LEDIndicator.translate">
    <p>def <span class="ident">translate</span>(</p><p>self, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LEDIndicator.translate', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LEDIndicator.translate" class="source">
    <pre><code>def translate(self, pdisp):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LEDIndicator.unselect">
    <p>def <span class="ident">unselect</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LEDIndicator.unselect', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LEDIndicator.unselect" class="source">
    <pre><code>def unselect(self):
    self.selected = False
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggmath.LEDIndicator.center" class="name">var <span class="ident">center</span></p>
            

            
  
    <div class="desc"><p>This attribute represents the horizontal and vertical position of the 
sprite "center" as a tuple of floating point numbers. See the 
descriptions for <code>ggame.Sprite.fxcenter</code> and <code>ggame.Sprite.fycenter</code> for 
more details.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LEDIndicator.fxcenter" class="name">var <span class="ident">fxcenter</span></p>
            

            
  
    <div class="desc"><p>This represents the horizontal position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its left hand edge. A value of 1.0 refers to its 
right hand edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LEDIndicator.fycenter" class="name">var <span class="ident">fycenter</span></p>
            

            
  
    <div class="desc"><p>This represents the vertical position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its top edge. A value of 1.0 refers to its 
bottom edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LEDIndicator.height" class="name">var <span class="ident">height</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display height of the sprite.
Assigning a value to the height will scale the image vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LEDIndicator.index" class="name">var <span class="ident">index</span></p>
            

            
  
    <div class="desc"><p>This is an integer index in to the list of images available for this sprite.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LEDIndicator.movable" class="name">var <span class="ident">movable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LEDIndicator.position" class="name">var <span class="ident">position</span></p>
            

            
  
    <div class="desc"><p>This represents the (x,y) coordinates of the sprite on the screen. Assigning
a value to this attribute will move the sprite to the new coordinates.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LEDIndicator.rotation" class="name">var <span class="ident">rotation</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the rotation of the sprite on the screen.
Value may be a floating point number. A value of 0.0 means no rotation. A value 
of 1.0 means  a rotation of 1 radian in a counter-clockwise direction. One radian
is 180/pi or approximately 57.3 degrees.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LEDIndicator.scale" class="name">var <span class="ident">scale</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LEDIndicator.selectable" class="name">var <span class="ident">selectable</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#ggmath.ImageIndicator">ImageIndicator</a></code>.<code><a href="#ggmath.ImageIndicator.selectable">selectable</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LEDIndicator.strokable" class="name">var <span class="ident">strokable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LEDIndicator.visible" class="name">var <span class="ident">visible</span></p>
            

            
  
    <div class="desc"><p>This boolean attribute may be used to change the visibility of the sprite. Setting
<code>ggame.Sprite.visible</code> to <code>False</code> will prevent the sprite from rendering on the 
screen.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LEDIndicator.width" class="name">var <span class="ident">width</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display width of the sprite.
Assigning a value to the width will scale the image horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LEDIndicator.x" class="name">var <span class="ident">x</span></p>
            

            
  
    <div class="desc"><p>This represents the x-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LEDIndicator.y" class="name">var <span class="ident">y</span></p>
            

            
  
    <div class="desc"><p>This represents the y-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.LEDIndicator.collidingCircleWithPoly">
    <p>def <span class="ident">collidingCircleWithPoly</span>(</p><p>cls, circ, poly)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LEDIndicator.collidingCircleWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LEDIndicator.collidingCircleWithPoly" class="source">
    <pre><code>@classmethod
def collidingCircleWithPoly(cls, circ, poly):
    return True
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ggmath.Label" class="name">class <span class="ident">Label</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Label', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Label" class="source">
    <pre><code>class Label(_MathVisual):
    
    posinputsdef = ['pos']
    nonposinputsdef = ['text']
    
    def __init__(self, *args, **kwargs):
        """
        Required Inputs
        
        * **pos** position of label
        * **text** text contents of label
        """
        super().__init__(TextAsset(""), *args, **kwargs)
        self._touchAsset()

    def _buildAsset(self):
        return TextAsset(self.nposinputs.text(), 
                            style="{0}px Courier".format(self.stdinputs.size()),
                            width=self.stdinputs.width(),
                            fill=self.stdinputs.color())

    def __call__(self):
        return self.nposinputs.text()

    def physicalPointTouching(self, ppos):
        _ppos = self.spposinputs.pos
        return (ppos[0] >= _ppos[0] and 
            ppos[0] <= _ppos[0] + self.sstdinputs.width and
            ppos[1] >= _ppos[1] and 
            ppos[1] <= _ppos[1] + self.sstdinputs.size)

    def translate(self, pdisp):
        pass
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggmath.Label">Label</a></li>
          <li>__pdoc_file_module__._MathVisual</li>
          <li>ggame.Sprite</li>
          <li>__pdoc_file_module__._MathDynamic</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="ggmath.Label.defaultcolor" class="name">var <span class="ident">defaultcolor</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Label.defaultsize" class="name">var <span class="ident">defaultsize</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Label.defaultstyle" class="name">var <span class="ident">defaultstyle</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Label.defaultwidth" class="name">var <span class="ident">defaultwidth</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Label.nonposinputsdef" class="name">var <span class="ident">nonposinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Label.posinputsdef" class="name">var <span class="ident">posinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.Label.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Required Inputs</p>
<ul>
<li><strong>pos</strong> position of label</li>
<li><strong>text</strong> text contents of label</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Label.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Label.__init__" class="source">
    <pre><code>def __init__(self, *args, **kwargs):
    """
    Required Inputs
    
    * **pos** position of label
    * **text** text contents of label
    """
    super().__init__(TextAsset(""), *args, **kwargs)
    self._touchAsset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Label.Eval">
    <p>def <span class="ident">Eval</span>(</p><p>self, val)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Label.Eval', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Label.Eval" class="source">
    <pre><code>def Eval(self, val):
    if callable(val):
        self._setDynamic() # dynamically defined .. must step
        return val
    else:
        return lambda : val  
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Label.canstroke">
    <p>def <span class="ident">canstroke</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Label.canstroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Label.canstroke" class="source">
    <pre><code>def canstroke(self, ppos):
    return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Label.circularCollisionModel">
    <p>def <span class="ident">circularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Label.circularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Label.circularCollisionModel" class="source">
    <pre><code>def circularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Label.collidingPolyWithPoly">
    <p>def <span class="ident">collidingPolyWithPoly</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Label.collidingPolyWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Label.collidingPolyWithPoly" class="source">
    <pre><code>def collidingPolyWithPoly(self, obj):
    return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Label.collidingWith">
    <p>def <span class="ident">collidingWith</span>(</p><p>self, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a boolean True if this sprite is currently overlapping the sprite 
referenced by <code>obj</code>. Returns False if checking for collision with 
itself. Returns False if extents of object make it impossible for
collision to occur. Returns True if sprite's <code>edgedef</code> parameter overlaps
with other sprite's <code>edgedef</code> parameter, taking into consideration both
sprites' center, rotation and scale settings.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Label.collidingWith', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Label.collidingWith" class="source">
    <pre><code>def collidingWith(self, obj):
    """
    Return a boolean True if this sprite is currently overlapping the sprite 
    referenced by `obj`. Returns False if checking for collision with 
    itself. Returns False if extents of object make it impossible for
    collision to occur. Returns True if sprite's `edgedef` parameter overlaps
    with other sprite's `edgedef` parameter, taking into consideration both
    sprites' center, rotation and scale settings.
    """
    if self is obj:
        return False
    else:
        self._setExtents()
        obj._setExtents()
        # Gross check for overlap will usually rule out a collision
        if (self.xmin > obj.xmax
            or self.xmax < obj.xmin
            or self.ymin > obj.ymax
            or self.ymax < obj.ymin):
            return False
        # Otherwise, perform a careful overlap determination
        elif type(self.asset) is CircleAsset:
            if type(obj.asset) is CircleAsset:
                # two circles .. check distance between
                sx = (self.xmin + self.xmax) / 2
                sy = (self.ymin + self.ymax) / 2
                ox = (obj.xmin + obj.xmax) / 2
                oy = (obj.ymin + obj.ymax) / 2
                d = math.sqrt((sx-ox)**2 + (sy-oy)**2)
                return d <= self.width/2 + obj.width/2
            else:
                return self.collidingCircleWithPoly(self, obj)
        else:
            if type(obj.asset) is CircleAsset:
                return self.collidingCircleWithPoly(obj, self)
            else:
                return self.collidingPolyWithPoly(obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Label.collidingWithSprites">
    <p>def <span class="ident">collidingWithSprites</span>(</p><p>self, sclass=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a list of sprite objects identified by the <code>sclass</code> parameter
that are currently colliding with (that is, with which the <code>ggame.Sprite.collidingWith</code>
method returns True) this sprite. If <code>sclass</code> is set to <code>None</code> (default), then
all other sprites are checked for collision, otherwise, only sprites whose
class matches <code>sclass</code> are checked.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Label.collidingWithSprites', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Label.collidingWithSprites" class="source">
    <pre><code>def collidingWithSprites(self, sclass = None):
    """
    Return a list of sprite objects identified by the `sclass` parameter
    that are currently colliding with (that is, with which the `ggame.Sprite.collidingWith`
    method returns True) this sprite. If `sclass` is set to `None` (default), then
    all other sprites are checked for collision, otherwise, only sprites whose
    class matches `sclass` are checked.
    """
    if sclass is None:
        slist = App.spritelist
    else:
        slist = App.getSpritesbyClass(sclass)
    return list(filter(self.collidingWith, slist))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Label.destroy">
    <p>def <span class="ident">destroy</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Label.destroy', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Label.destroy" class="source">
    <pre><code>def destroy(self):
    MathApp._removeVisual(self)
    MathApp._removeMovable(self)
    MathApp._removeStrokable(self)
    _MathDynamic.destroy(self)
    Sprite.destroy(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Label.firstImage">
    <p>def <span class="ident">firstImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>first</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Label.firstImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Label.firstImage" class="source">
    <pre><code>def firstImage(self):
    """
    Select and display the *first* image used by this sprite.
    """
    self.GFX.texture = self.asset[0]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Label.lastImage">
    <p>def <span class="ident">lastImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>last</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Label.lastImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Label.lastImage" class="source">
    <pre><code>def lastImage(self):
    """
    Select and display the *last* image used by this sprite.
    """
    self.GFX.texture = self.asset[-1]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Label.mousedown">
    <p>def <span class="ident">mousedown</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Label.mousedown', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Label.mousedown" class="source">
    <pre><code>def mousedown(self):
    self.mouseisdown = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Label.mouseup">
    <p>def <span class="ident">mouseup</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Label.mouseup', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Label.mouseup" class="source">
    <pre><code>def mouseup(self):
    self.mouseisdown = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Label.nextImage">
    <p>def <span class="ident">nextImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>next</em> image used by this sprite.
If the current image is already the <em>last</em> image, then
the image is not advanced.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.nextImage</code> on the last image will cause the <em>first</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Label.nextImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Label.nextImage" class="source">
    <pre><code>def nextImage(self, wrap = False):
    """
    Select and display the *next* image used by this sprite.
    If the current image is already the *last* image, then
    the image is not advanced.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.nextImage` on the last image will cause the *first*
    image to be loaded.
    """
    self._index += 1
    if self._index >= len(self.asset):
        if wrap:
            self._index = 0
        else:
            self._index = len(self.asset)-1
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Label.physicalPointTouching">
    <p>def <span class="ident">physicalPointTouching</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Label.physicalPointTouching', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Label.physicalPointTouching" class="source">
    <pre><code>def physicalPointTouching(self, ppos):
    _ppos = self.spposinputs.pos
    return (ppos[0] >= _ppos[0] and 
        ppos[0] <= _ppos[0] + self.sstdinputs.width and
        ppos[1] >= _ppos[1] and 
        ppos[1] <= _ppos[1] + self.sstdinputs.size)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Label.prevImage">
    <p>def <span class="ident">prevImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>previous</em> image used by this sprite.
If the current image is already the <em>first</em> image, then
the image is not changed.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.prevImage</code> on the first image will cause the <em>last</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Label.prevImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Label.prevImage" class="source">
    <pre><code>def prevImage(self, wrap = False):
    """
    Select and display the *previous* image used by this sprite.
    If the current image is already the *first* image, then
    the image is not changed.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.prevImage` on the first image will cause the *last*
    image to be loaded.
    """
    self._index -= 1
    if self._index < 0:
        if wrap:
            self._index = len(self.asset)-1
        else:
            self._index = 0
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Label.processEvent">
    <p>def <span class="ident">processEvent</span>(</p><p>self, event)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Label.processEvent', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Label.processEvent" class="source">
    <pre><code>def processEvent(self, event):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Label.rectangularCollisionModel">
    <p>def <span class="ident">rectangularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Label.rectangularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Label.rectangularCollisionModel" class="source">
    <pre><code>def rectangularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Label.select">
    <p>def <span class="ident">select</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Label.select', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Label.select" class="source">
    <pre><code>def select(self):
    self.selected = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Label.setImage">
    <p>def <span class="ident">setImage</span>(</p><p>self, index=0)</p>
    </div>
    

    
  
    <div class="desc"><p>Select the image to display by giving its <code>index</code>, where an index
of zero represents the <em>first</em> image in the asset.</p>
<p>This is equivalent to setting the <code>ggame.Sprite.index</code> property
directly.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Label.setImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Label.setImage" class="source">
    <pre><code>def setImage(self, index=0):
    """
    Select the image to display by giving its `index`, where an index
    of zero represents the *first* image in the asset.
    This is equivalent to setting the `ggame.Sprite.index` property
    directly.
    """
    self.index = index
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Label.step">
    <p>def <span class="ident">step</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Label.step', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Label.step" class="source">
    <pre><code>def step(self):
    self._touchAsset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Label.stroke">
    <p>def <span class="ident">stroke</span>(</p><p>self, ppos, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Label.stroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Label.stroke" class="source">
    <pre><code>def stroke(self, ppos, pdisp):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Label.translate">
    <p>def <span class="ident">translate</span>(</p><p>self, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Label.translate', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Label.translate" class="source">
    <pre><code>def translate(self, pdisp):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Label.unselect">
    <p>def <span class="ident">unselect</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Label.unselect', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Label.unselect" class="source">
    <pre><code>def unselect(self):
    self.selected = False
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggmath.Label.center" class="name">var <span class="ident">center</span></p>
            

            
  
    <div class="desc"><p>This attribute represents the horizontal and vertical position of the 
sprite "center" as a tuple of floating point numbers. See the 
descriptions for <code>ggame.Sprite.fxcenter</code> and <code>ggame.Sprite.fycenter</code> for 
more details.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Label.fxcenter" class="name">var <span class="ident">fxcenter</span></p>
            

            
  
    <div class="desc"><p>This represents the horizontal position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its left hand edge. A value of 1.0 refers to its 
right hand edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Label.fycenter" class="name">var <span class="ident">fycenter</span></p>
            

            
  
    <div class="desc"><p>This represents the vertical position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its top edge. A value of 1.0 refers to its 
bottom edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Label.height" class="name">var <span class="ident">height</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display height of the sprite.
Assigning a value to the height will scale the image vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Label.index" class="name">var <span class="ident">index</span></p>
            

            
  
    <div class="desc"><p>This is an integer index in to the list of images available for this sprite.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Label.movable" class="name">var <span class="ident">movable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Label.position" class="name">var <span class="ident">position</span></p>
            

            
  
    <div class="desc"><p>This represents the (x,y) coordinates of the sprite on the screen. Assigning
a value to this attribute will move the sprite to the new coordinates.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Label.rotation" class="name">var <span class="ident">rotation</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the rotation of the sprite on the screen.
Value may be a floating point number. A value of 0.0 means no rotation. A value 
of 1.0 means  a rotation of 1 radian in a counter-clockwise direction. One radian
is 180/pi or approximately 57.3 degrees.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Label.scale" class="name">var <span class="ident">scale</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the size of the sprite ('scale' it) on the 
screen. Value may be a floating point number. A value of 1.0 means that the sprite
image will keep its original size. A value of 2.0 would double it, etc.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Label.selectable" class="name">var <span class="ident">selectable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Label.strokable" class="name">var <span class="ident">strokable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Label.visible" class="name">var <span class="ident">visible</span></p>
            

            
  
    <div class="desc"><p>This boolean attribute may be used to change the visibility of the sprite. Setting
<code>ggame.Sprite.visible</code> to <code>False</code> will prevent the sprite from rendering on the 
screen.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Label.width" class="name">var <span class="ident">width</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display width of the sprite.
Assigning a value to the width will scale the image horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Label.x" class="name">var <span class="ident">x</span></p>
            

            
  
    <div class="desc"><p>This represents the x-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Label.y" class="name">var <span class="ident">y</span></p>
            

            
  
    <div class="desc"><p>This represents the y-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.Label.collidingCircleWithPoly">
    <p>def <span class="ident">collidingCircleWithPoly</span>(</p><p>cls, circ, poly)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Label.collidingCircleWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Label.collidingCircleWithPoly" class="source">
    <pre><code>@classmethod
def collidingCircleWithPoly(cls, circ, poly):
    return True
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ggmath.LineSegment" class="name">class <span class="ident">LineSegment</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LineSegment', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LineSegment" class="source">
    <pre><code>class LineSegment(_MathVisual):
    
    posinputsdef = ['pos','end']
    
    def __init__(self, *args, **kwargs):
        """
        Required Inputs
        
        * **pos** start position of segment
        * **end** end position of segment
        
        Optional Inputs
        
        * **style** line style (thickness, color)
        """
        super().__init__(LineAsset(0,0, self.defaultstyle), *args, **kwargs)
        self._touchAsset()
        
    def _buildAsset(self):
        start = self.pposinputs.pos
        end = self.pposinputs.end
        self.position = start
        return LineAsset(end[0]-start[0],
                            end[1]-start[1],
                            self.stdinputs.style())

    def physicalPointTouching(self, ppos):
        return False

    def translate(self, pdisp):
        pass
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggmath.LineSegment">LineSegment</a></li>
          <li>__pdoc_file_module__._MathVisual</li>
          <li>ggame.Sprite</li>
          <li>__pdoc_file_module__._MathDynamic</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="ggmath.LineSegment.defaultcolor" class="name">var <span class="ident">defaultcolor</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LineSegment.defaultsize" class="name">var <span class="ident">defaultsize</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LineSegment.defaultstyle" class="name">var <span class="ident">defaultstyle</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LineSegment.defaultwidth" class="name">var <span class="ident">defaultwidth</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LineSegment.nonposinputsdef" class="name">var <span class="ident">nonposinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LineSegment.posinputsdef" class="name">var <span class="ident">posinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.LineSegment.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Required Inputs</p>
<ul>
<li><strong>pos</strong> start position of segment</li>
<li><strong>end</strong> end position of segment</li>
</ul>
<p>Optional Inputs</p>
<ul>
<li><strong>style</strong> line style (thickness, color)</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LineSegment.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LineSegment.__init__" class="source">
    <pre><code>def __init__(self, *args, **kwargs):
    """
    Required Inputs
    
    * **pos** start position of segment
    * **end** end position of segment
    
    Optional Inputs
    
    * **style** line style (thickness, color)
    """
    super().__init__(LineAsset(0,0, self.defaultstyle), *args, **kwargs)
    self._touchAsset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LineSegment.Eval">
    <p>def <span class="ident">Eval</span>(</p><p>self, val)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LineSegment.Eval', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LineSegment.Eval" class="source">
    <pre><code>def Eval(self, val):
    if callable(val):
        self._setDynamic() # dynamically defined .. must step
        return val
    else:
        return lambda : val  
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LineSegment.canstroke">
    <p>def <span class="ident">canstroke</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LineSegment.canstroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LineSegment.canstroke" class="source">
    <pre><code>def canstroke(self, ppos):
    return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LineSegment.circularCollisionModel">
    <p>def <span class="ident">circularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LineSegment.circularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LineSegment.circularCollisionModel" class="source">
    <pre><code>def circularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LineSegment.collidingPolyWithPoly">
    <p>def <span class="ident">collidingPolyWithPoly</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LineSegment.collidingPolyWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LineSegment.collidingPolyWithPoly" class="source">
    <pre><code>def collidingPolyWithPoly(self, obj):
    return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LineSegment.collidingWith">
    <p>def <span class="ident">collidingWith</span>(</p><p>self, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a boolean True if this sprite is currently overlapping the sprite 
referenced by <code>obj</code>. Returns False if checking for collision with 
itself. Returns False if extents of object make it impossible for
collision to occur. Returns True if sprite's <code>edgedef</code> parameter overlaps
with other sprite's <code>edgedef</code> parameter, taking into consideration both
sprites' center, rotation and scale settings.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LineSegment.collidingWith', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LineSegment.collidingWith" class="source">
    <pre><code>def collidingWith(self, obj):
    """
    Return a boolean True if this sprite is currently overlapping the sprite 
    referenced by `obj`. Returns False if checking for collision with 
    itself. Returns False if extents of object make it impossible for
    collision to occur. Returns True if sprite's `edgedef` parameter overlaps
    with other sprite's `edgedef` parameter, taking into consideration both
    sprites' center, rotation and scale settings.
    """
    if self is obj:
        return False
    else:
        self._setExtents()
        obj._setExtents()
        # Gross check for overlap will usually rule out a collision
        if (self.xmin > obj.xmax
            or self.xmax < obj.xmin
            or self.ymin > obj.ymax
            or self.ymax < obj.ymin):
            return False
        # Otherwise, perform a careful overlap determination
        elif type(self.asset) is CircleAsset:
            if type(obj.asset) is CircleAsset:
                # two circles .. check distance between
                sx = (self.xmin + self.xmax) / 2
                sy = (self.ymin + self.ymax) / 2
                ox = (obj.xmin + obj.xmax) / 2
                oy = (obj.ymin + obj.ymax) / 2
                d = math.sqrt((sx-ox)**2 + (sy-oy)**2)
                return d <= self.width/2 + obj.width/2
            else:
                return self.collidingCircleWithPoly(self, obj)
        else:
            if type(obj.asset) is CircleAsset:
                return self.collidingCircleWithPoly(obj, self)
            else:
                return self.collidingPolyWithPoly(obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LineSegment.collidingWithSprites">
    <p>def <span class="ident">collidingWithSprites</span>(</p><p>self, sclass=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a list of sprite objects identified by the <code>sclass</code> parameter
that are currently colliding with (that is, with which the <code>ggame.Sprite.collidingWith</code>
method returns True) this sprite. If <code>sclass</code> is set to <code>None</code> (default), then
all other sprites are checked for collision, otherwise, only sprites whose
class matches <code>sclass</code> are checked.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LineSegment.collidingWithSprites', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LineSegment.collidingWithSprites" class="source">
    <pre><code>def collidingWithSprites(self, sclass = None):
    """
    Return a list of sprite objects identified by the `sclass` parameter
    that are currently colliding with (that is, with which the `ggame.Sprite.collidingWith`
    method returns True) this sprite. If `sclass` is set to `None` (default), then
    all other sprites are checked for collision, otherwise, only sprites whose
    class matches `sclass` are checked.
    """
    if sclass is None:
        slist = App.spritelist
    else:
        slist = App.getSpritesbyClass(sclass)
    return list(filter(self.collidingWith, slist))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LineSegment.destroy">
    <p>def <span class="ident">destroy</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LineSegment.destroy', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LineSegment.destroy" class="source">
    <pre><code>def destroy(self):
    MathApp._removeVisual(self)
    MathApp._removeMovable(self)
    MathApp._removeStrokable(self)
    _MathDynamic.destroy(self)
    Sprite.destroy(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LineSegment.firstImage">
    <p>def <span class="ident">firstImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>first</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LineSegment.firstImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LineSegment.firstImage" class="source">
    <pre><code>def firstImage(self):
    """
    Select and display the *first* image used by this sprite.
    """
    self.GFX.texture = self.asset[0]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LineSegment.lastImage">
    <p>def <span class="ident">lastImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>last</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LineSegment.lastImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LineSegment.lastImage" class="source">
    <pre><code>def lastImage(self):
    """
    Select and display the *last* image used by this sprite.
    """
    self.GFX.texture = self.asset[-1]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LineSegment.mousedown">
    <p>def <span class="ident">mousedown</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LineSegment.mousedown', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LineSegment.mousedown" class="source">
    <pre><code>def mousedown(self):
    self.mouseisdown = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LineSegment.mouseup">
    <p>def <span class="ident">mouseup</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LineSegment.mouseup', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LineSegment.mouseup" class="source">
    <pre><code>def mouseup(self):
    self.mouseisdown = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LineSegment.nextImage">
    <p>def <span class="ident">nextImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>next</em> image used by this sprite.
If the current image is already the <em>last</em> image, then
the image is not advanced.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.nextImage</code> on the last image will cause the <em>first</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LineSegment.nextImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LineSegment.nextImage" class="source">
    <pre><code>def nextImage(self, wrap = False):
    """
    Select and display the *next* image used by this sprite.
    If the current image is already the *last* image, then
    the image is not advanced.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.nextImage` on the last image will cause the *first*
    image to be loaded.
    """
    self._index += 1
    if self._index >= len(self.asset):
        if wrap:
            self._index = 0
        else:
            self._index = len(self.asset)-1
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LineSegment.physicalPointTouching">
    <p>def <span class="ident">physicalPointTouching</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LineSegment.physicalPointTouching', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LineSegment.physicalPointTouching" class="source">
    <pre><code>def physicalPointTouching(self, ppos):
    return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LineSegment.prevImage">
    <p>def <span class="ident">prevImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>previous</em> image used by this sprite.
If the current image is already the <em>first</em> image, then
the image is not changed.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.prevImage</code> on the first image will cause the <em>last</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LineSegment.prevImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LineSegment.prevImage" class="source">
    <pre><code>def prevImage(self, wrap = False):
    """
    Select and display the *previous* image used by this sprite.
    If the current image is already the *first* image, then
    the image is not changed.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.prevImage` on the first image will cause the *last*
    image to be loaded.
    """
    self._index -= 1
    if self._index < 0:
        if wrap:
            self._index = len(self.asset)-1
        else:
            self._index = 0
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LineSegment.processEvent">
    <p>def <span class="ident">processEvent</span>(</p><p>self, event)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LineSegment.processEvent', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LineSegment.processEvent" class="source">
    <pre><code>def processEvent(self, event):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LineSegment.rectangularCollisionModel">
    <p>def <span class="ident">rectangularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LineSegment.rectangularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LineSegment.rectangularCollisionModel" class="source">
    <pre><code>def rectangularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LineSegment.select">
    <p>def <span class="ident">select</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LineSegment.select', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LineSegment.select" class="source">
    <pre><code>def select(self):
    self.selected = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LineSegment.setImage">
    <p>def <span class="ident">setImage</span>(</p><p>self, index=0)</p>
    </div>
    

    
  
    <div class="desc"><p>Select the image to display by giving its <code>index</code>, where an index
of zero represents the <em>first</em> image in the asset.</p>
<p>This is equivalent to setting the <code>ggame.Sprite.index</code> property
directly.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LineSegment.setImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LineSegment.setImage" class="source">
    <pre><code>def setImage(self, index=0):
    """
    Select the image to display by giving its `index`, where an index
    of zero represents the *first* image in the asset.
    This is equivalent to setting the `ggame.Sprite.index` property
    directly.
    """
    self.index = index
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LineSegment.step">
    <p>def <span class="ident">step</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LineSegment.step', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LineSegment.step" class="source">
    <pre><code>def step(self):
    self._touchAsset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LineSegment.stroke">
    <p>def <span class="ident">stroke</span>(</p><p>self, ppos, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LineSegment.stroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LineSegment.stroke" class="source">
    <pre><code>def stroke(self, ppos, pdisp):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LineSegment.translate">
    <p>def <span class="ident">translate</span>(</p><p>self, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LineSegment.translate', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LineSegment.translate" class="source">
    <pre><code>def translate(self, pdisp):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.LineSegment.unselect">
    <p>def <span class="ident">unselect</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LineSegment.unselect', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LineSegment.unselect" class="source">
    <pre><code>def unselect(self):
    self.selected = False
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggmath.LineSegment.center" class="name">var <span class="ident">center</span></p>
            

            
  
    <div class="desc"><p>This attribute represents the horizontal and vertical position of the 
sprite "center" as a tuple of floating point numbers. See the 
descriptions for <code>ggame.Sprite.fxcenter</code> and <code>ggame.Sprite.fycenter</code> for 
more details.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LineSegment.fxcenter" class="name">var <span class="ident">fxcenter</span></p>
            

            
  
    <div class="desc"><p>This represents the horizontal position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its left hand edge. A value of 1.0 refers to its 
right hand edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LineSegment.fycenter" class="name">var <span class="ident">fycenter</span></p>
            

            
  
    <div class="desc"><p>This represents the vertical position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its top edge. A value of 1.0 refers to its 
bottom edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LineSegment.height" class="name">var <span class="ident">height</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display height of the sprite.
Assigning a value to the height will scale the image vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LineSegment.index" class="name">var <span class="ident">index</span></p>
            

            
  
    <div class="desc"><p>This is an integer index in to the list of images available for this sprite.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LineSegment.movable" class="name">var <span class="ident">movable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LineSegment.position" class="name">var <span class="ident">position</span></p>
            

            
  
    <div class="desc"><p>This represents the (x,y) coordinates of the sprite on the screen. Assigning
a value to this attribute will move the sprite to the new coordinates.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LineSegment.rotation" class="name">var <span class="ident">rotation</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the rotation of the sprite on the screen.
Value may be a floating point number. A value of 0.0 means no rotation. A value 
of 1.0 means  a rotation of 1 radian in a counter-clockwise direction. One radian
is 180/pi or approximately 57.3 degrees.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LineSegment.scale" class="name">var <span class="ident">scale</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the size of the sprite ('scale' it) on the 
screen. Value may be a floating point number. A value of 1.0 means that the sprite
image will keep its original size. A value of 2.0 would double it, etc.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LineSegment.selectable" class="name">var <span class="ident">selectable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LineSegment.strokable" class="name">var <span class="ident">strokable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LineSegment.visible" class="name">var <span class="ident">visible</span></p>
            

            
  
    <div class="desc"><p>This boolean attribute may be used to change the visibility of the sprite. Setting
<code>ggame.Sprite.visible</code> to <code>False</code> will prevent the sprite from rendering on the 
screen.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LineSegment.width" class="name">var <span class="ident">width</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display width of the sprite.
Assigning a value to the width will scale the image horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LineSegment.x" class="name">var <span class="ident">x</span></p>
            

            
  
    <div class="desc"><p>This represents the x-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.LineSegment.y" class="name">var <span class="ident">y</span></p>
            

            
  
    <div class="desc"><p>This represents the y-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.LineSegment.collidingCircleWithPoly">
    <p>def <span class="ident">collidingCircleWithPoly</span>(</p><p>cls, circ, poly)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.LineSegment.collidingCircleWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.LineSegment.collidingCircleWithPoly" class="source">
    <pre><code>@classmethod
def collidingCircleWithPoly(cls, circ, poly):
    return True
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ggmath.MathApp" class="name">class <span class="ident">MathApp</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MathApp', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MathApp" class="source">
    <pre><code>class MathApp(App):
    
    _scale = 200   # pixels per unit
    _xcenter = 0    # center of screen in units
    _ycenter = 0    
    _mathVisualList = [] #
    _mathDynamicList = []
    _mathMovableList = []
    _mathSelectableList = []
    _mathStrokableList = []
    _viewNotificationList = []
    time = time()
    
    def __init__(self, scale=_scale):
        super().__init__()
        MathApp.width = self.width
        MathApp.height = self.height
        MathApp._scale = scale   # pixels per unit
        # register event callbacks
        self.listenMouseEvent("click", self.handleMouseClick)
        self.listenMouseEvent("mousedown", self.handleMouseDown)
        self.listenMouseEvent("mouseup", self.handleMouseUp)
        self.listenMouseEvent("mousemove", self.handleMouseMove)
        self.listenMouseEvent("wheel", self.handleMouseWheel)
        self.mouseDown = False
        self.mouseCapturedObject = None
        self.mouseStrokedObject = None
        self.mouseDownObject = None
        self.mouseX = self.mouseY = None
        self._touchAllVisuals()
        self.selectedObj = None
        MathApp.time = time()

    def step(self):
        MathApp.time = time()
        for spr in self._mathDynamicList:
            spr.step()

    def _touchAllVisuals(self):
        # touch all visual object assets to use scaling
        for obj in self._mathVisualList:
            obj._touchAsset(True)


    @classmethod
    def logicalToPhysical(cls, lp):
        xxform = lambda xvalue, xscale, xcenter, physwidth: int((xvalue-xcenter)*xscale + physwidth/2)
        yxform = lambda yvalue, yscale, ycenter, physheight: int(physheight/2 - (yvalue-ycenter)*yscale)

        try:
            return (xxform(lp[0], cls._scale, cls._xcenter, cls._win.width),
                yxform(lp[1], cls._scale, cls._ycenter, cls._win.height))
        except AttributeError:
            return lp
            
    @classmethod
    def physicalToLogical(cls, pp):
        xxform = lambda xvalue, xscale, xcenter, physwidth: (xvalue - physwidth/2)/xscale + xcenter
        yxform = lambda yvalue, yscale, ycenter, physheight: (physheight/2 - yvalue)/yscale + ycenter

        try:
            return (xxform(pp[0], cls._scale, cls._xcenter, cls._win.width),
                yxform(pp[1], cls._scale, cls._ycenter, cls._win.height))
        except AttributeError:
            return pp
            
    @classmethod
    def translatePhysicalToLogical(cls, pp):
        xxform = lambda xvalue, xscale: xvalue/xscale
        yxform = lambda yvalue, yscale: -yvalue/yscale

        try:
            return (xxform(pp[0], cls._scale), yxform(pp[1], cls._scale))
        except AttributeError:
            return pp

    @classmethod
    def translateLogicalToPhysical(cls, pp):
        xxform = lambda xvalue, xscale: xvalue*xscale
        yxform = lambda yvalue, yscale: -yvalue*yscale

        try:
            return (xxform(pp[0], cls._scale), yxform(pp[1], cls._scale))
        except AttributeError:
            return pp

    def handleMouseClick(self, event):
        found = False
        for obj in self._mathSelectableList:
            if obj.physicalPointTouching((event.x, event.y)):
                found = True
                if not obj.selected: 
                    obj.select()
                    self.selectedObj = obj
        if not found and self.selectedObj:
            self.selectedObj.unselect()
            self.selectedObj = None

    def handleMouseDown(self, event):
        self.mouseDown = True
        self.mouseCapturedObject = None
        self.mouseStrokedObject = None
        for obj in self._mathSelectableList:
            if obj.physicalPointTouching((event.x, event.y)):
                obj.mousedown()
                self.mouseDownObject = obj
                break
        for obj in self._mathMovableList:
            if obj.physicalPointTouching((event.x, event.y)) and not (obj.strokable and obj.canstroke((event.x,event.y))):
                self.mouseCapturedObject = obj
                break
        if not self.mouseCapturedObject:
            for obj in self._mathStrokableList:
                if obj.canstroke((event.x, event.y)):
                    self.mouseStrokedObject = obj
                    break

    def handleMouseUp(self, event):
        if self.mouseDownObject:
            self.mouseDownObject.mouseup()
            self.mouseDownObject = None
        self.mouseDown = False
        self.mouseCapturedObject = None
        self.mouseStrokedObject = None

    def handleMouseMove(self, event):
        if not self.mouseX:
            self.mouseX = event.x
            self.mouseY = event.y
        dx = event.x - self.mouseX
        dy = event.y - self.mouseY
        self.mouseX = event.x
        self.mouseY = event.y
        if self.mouseDown:
            if self.mouseCapturedObject:
                self.mouseCapturedObject.translate((dx, dy))
            elif self.mouseStrokedObject:
                self.mouseStrokedObject.stroke((self.mouseX,self.mouseY), (dx,dy))
            else:
                lmove = self.translatePhysicalToLogical((dx, dy))
                MathApp._xcenter -= lmove[0]
                MathApp._ycenter -= lmove[1]
                self._touchAllVisuals()
                self._viewNotify("translate")
    
    @property
    def viewPosition(self):
        return (MathApp._xcenter, MathApp._ycenter)
        
    @viewPosition.setter
    def viewPosition(self, pos):
        MathApp._xcenter, MathApp._ycenter = pos
        self._touchAllVisuals()
        self._viewNotify("translate")
        
    def handleMouseWheel(self, event):
        zoomfactor = event.wheelDelta/100
        zoomfactor = 1+zoomfactor if zoomfactor > 0 else 1+zoomfactor
        if zoomfactor > 1.2:
            zoomfactor = 1.2
        elif zoomfactor < 0.8:
            zoomfactor = 0.8
        MathApp._scale *= zoomfactor
        self._touchAllVisuals()
        self._viewNotify("zoom")
        
    @classmethod   
    def addViewNotification(cls, handler):
        cls._viewNotificationList.append(handler)
        
    @classmethod   
    def removeViewNotification(cls, handler):
        cls._viewNotificationList.remove(handler)
    
    def _viewNotify(self, viewchange):
        for handler in self._viewNotificationList:
            handler(viewchange = viewchange, scale = self._scale, center = (self._xcenter, self._ycenter))
        
     
    @classmethod   
    def distance(cls, pos1, pos2):
        return sqrt((pos2[0]-pos1[0])**2 + (pos2[1]-pos1[1])**2)
        
    @property
    def scale(self):
        return self._scale
        
    @property
    def width(cls):
        return App._win.width
            
    @classmethod
    def _addVisual(cls, obj):
        """ FIX ME """
        if isinstance(obj, _MathVisual):
            cls._mathVisualList.append(obj)
            
    @classmethod
    def _removeVisual(cls, obj):
        if isinstance(obj, _MathVisual) and obj in cls._mathVisualList:
            cls._mathVisualList.remove(obj)

    @classmethod
    def _addDynamic(cls, obj):
        if isinstance(obj, _MathDynamic) and not obj in cls._mathDynamicList:
            cls._mathDynamicList.append(obj)
            
    @classmethod
    def _removeDynamic(cls, obj):
        if isinstance(obj, _MathDynamic) and obj in cls._mathDynamicList:
            cls._mathDynamicList.remove(obj)

    @classmethod
    def _addMovable(cls, obj):
        if isinstance(obj, _MathVisual) and not obj in cls._mathMovableList:
            cls._mathMovableList.append(obj)
            
    @classmethod
    def _removeMovable(cls, obj):
        if isinstance(obj, _MathVisual) and obj in cls._mathMovableList:
            cls._mathMovableList.remove(obj)

    @classmethod
    def _addSelectable(cls, obj):
        if isinstance(obj, _MathVisual) and not obj in cls._mathSelectableList:
            cls._mathSelectableList.append(obj)
            
    @classmethod
    def _removeSelectable(cls, obj):
       if isinstance(obj, _MathVisual)  and obj in cls._mathSelectableList:
            cls._mathSelectableList.remove(obj)

    @classmethod
    def _addStrokable(cls, obj):
        if isinstance(obj, _MathVisual) and not obj in cls._mathStrokableList:
            cls._mathStrokableList.append(obj)
            
    @classmethod
    def _removeStrokable(cls, obj):
        if isinstance(obj, _MathVisual) and obj in cls._mathStrokableList:
            cls._mathStrokableList.remove(obj)

    @classmethod
    def _destroy(cls, *args):
        """
        This will clean up any class level storage.
        """ 
        App._destroy(*args)  # hit the App class first
        MathApp._mathVisualList = [] 
        MathApp._mathDynamicList = []
        MathApp._mathMovableList = []
        MathApp._mathSelectableList = []
        MathApp._mathStrokableList = []
        MathApp._viewNotificationList = []
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggmath.MathApp">MathApp</a></li>
          <li>ggame.App</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="ggmath.MathApp.spritelist" class="name">var <span class="ident">spritelist</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MathApp.time" class="name">var <span class="ident">time</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.MathApp.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, scale=200)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MathApp.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MathApp.__init__" class="source">
    <pre><code>def __init__(self, scale=_scale):
    super().__init__()
    MathApp.width = self.width
    MathApp.height = self.height
    MathApp._scale = scale   # pixels per unit
    # register event callbacks
    self.listenMouseEvent("click", self.handleMouseClick)
    self.listenMouseEvent("mousedown", self.handleMouseDown)
    self.listenMouseEvent("mouseup", self.handleMouseUp)
    self.listenMouseEvent("mousemove", self.handleMouseMove)
    self.listenMouseEvent("wheel", self.handleMouseWheel)
    self.mouseDown = False
    self.mouseCapturedObject = None
    self.mouseStrokedObject = None
    self.mouseDownObject = None
    self.mouseX = self.mouseY = None
    self._touchAllVisuals()
    self.selectedObj = None
    MathApp.time = time()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MathApp.handleMouseClick">
    <p>def <span class="ident">handleMouseClick</span>(</p><p>self, event)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MathApp.handleMouseClick', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MathApp.handleMouseClick" class="source">
    <pre><code>def handleMouseClick(self, event):
    found = False
    for obj in self._mathSelectableList:
        if obj.physicalPointTouching((event.x, event.y)):
            found = True
            if not obj.selected: 
                obj.select()
                self.selectedObj = obj
    if not found and self.selectedObj:
        self.selectedObj.unselect()
        self.selectedObj = None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MathApp.handleMouseDown">
    <p>def <span class="ident">handleMouseDown</span>(</p><p>self, event)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MathApp.handleMouseDown', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MathApp.handleMouseDown" class="source">
    <pre><code>def handleMouseDown(self, event):
    self.mouseDown = True
    self.mouseCapturedObject = None
    self.mouseStrokedObject = None
    for obj in self._mathSelectableList:
        if obj.physicalPointTouching((event.x, event.y)):
            obj.mousedown()
            self.mouseDownObject = obj
            break
    for obj in self._mathMovableList:
        if obj.physicalPointTouching((event.x, event.y)) and not (obj.strokable and obj.canstroke((event.x,event.y))):
            self.mouseCapturedObject = obj
            break
    if not self.mouseCapturedObject:
        for obj in self._mathStrokableList:
            if obj.canstroke((event.x, event.y)):
                self.mouseStrokedObject = obj
                break
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MathApp.handleMouseMove">
    <p>def <span class="ident">handleMouseMove</span>(</p><p>self, event)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MathApp.handleMouseMove', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MathApp.handleMouseMove" class="source">
    <pre><code>def handleMouseMove(self, event):
    if not self.mouseX:
        self.mouseX = event.x
        self.mouseY = event.y
    dx = event.x - self.mouseX
    dy = event.y - self.mouseY
    self.mouseX = event.x
    self.mouseY = event.y
    if self.mouseDown:
        if self.mouseCapturedObject:
            self.mouseCapturedObject.translate((dx, dy))
        elif self.mouseStrokedObject:
            self.mouseStrokedObject.stroke((self.mouseX,self.mouseY), (dx,dy))
        else:
            lmove = self.translatePhysicalToLogical((dx, dy))
            MathApp._xcenter -= lmove[0]
            MathApp._ycenter -= lmove[1]
            self._touchAllVisuals()
            self._viewNotify("translate")
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MathApp.handleMouseUp">
    <p>def <span class="ident">handleMouseUp</span>(</p><p>self, event)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MathApp.handleMouseUp', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MathApp.handleMouseUp" class="source">
    <pre><code>def handleMouseUp(self, event):
    if self.mouseDownObject:
        self.mouseDownObject.mouseup()
        self.mouseDownObject = None
    self.mouseDown = False
    self.mouseCapturedObject = None
    self.mouseStrokedObject = None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MathApp.handleMouseWheel">
    <p>def <span class="ident">handleMouseWheel</span>(</p><p>self, event)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MathApp.handleMouseWheel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MathApp.handleMouseWheel" class="source">
    <pre><code>def handleMouseWheel(self, event):
    zoomfactor = event.wheelDelta/100
    zoomfactor = 1+zoomfactor if zoomfactor > 0 else 1+zoomfactor
    if zoomfactor > 1.2:
        zoomfactor = 1.2
    elif zoomfactor < 0.8:
        zoomfactor = 0.8
    MathApp._scale *= zoomfactor
    self._touchAllVisuals()
    self._viewNotify("zoom")
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MathApp.run">
    <p>def <span class="ident">run</span>(</p><p>self, userfunc=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Calling the <code>ggame.App.run</code> method begins the animation process whereby the 
<code>ggame.App.step</code> method is called once per animation frame. Set <code>userfunc</code>
to any function which shall be called once per animation frame.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MathApp.run', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MathApp.run" class="source">
    <pre><code>def run(self, userfunc = None):
    """
    Calling the `ggame.App.run` method begins the animation process whereby the 
    `ggame.App.step` method is called once per animation frame. Set `userfunc`
    to any function which shall be called once per animation frame.
    """
    self.userfunc = userfunc
    App._win.animate(self._animate)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MathApp.step">
    <p>def <span class="ident">step</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MathApp.step', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MathApp.step" class="source">
    <pre><code>def step(self):
    MathApp.time = time()
    for spr in self._mathDynamicList:
        spr.step()
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggmath.MathApp.mouseCapturedObject" class="name">var <span class="ident">mouseCapturedObject</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MathApp.mouseDown" class="name">var <span class="ident">mouseDown</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MathApp.mouseDownObject" class="name">var <span class="ident">mouseDownObject</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MathApp.mouseStrokedObject" class="name">var <span class="ident">mouseStrokedObject</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MathApp.scale" class="name">var <span class="ident">scale</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MathApp.selectedObj" class="name">var <span class="ident">selectedObj</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MathApp.viewPosition" class="name">var <span class="ident">viewPosition</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MathApp.width" class="name">var <span class="ident">width</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.MathApp.addViewNotification">
    <p>def <span class="ident">addViewNotification</span>(</p><p>cls, handler)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MathApp.addViewNotification', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MathApp.addViewNotification" class="source">
    <pre><code>@classmethod   
def addViewNotification(cls, handler):
    cls._viewNotificationList.append(handler)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MathApp.distance">
    <p>def <span class="ident">distance</span>(</p><p>cls, pos1, pos2)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MathApp.distance', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MathApp.distance" class="source">
    <pre><code>@classmethod   
def distance(cls, pos1, pos2):
    return sqrt((pos2[0]-pos1[0])**2 + (pos2[1]-pos1[1])**2)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MathApp.getSpritesbyClass">
    <p>def <span class="ident">getSpritesbyClass</span>(</p><p>cls, sclass)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a list of all active sprites of a given class.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MathApp.getSpritesbyClass', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MathApp.getSpritesbyClass" class="source">
    <pre><code>@classmethod
def getSpritesbyClass(cls, sclass):
    """
    Returns a list of all active sprites of a given class.
    """
    return App._spritesdict.get(sclass, [])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MathApp.listenKeyEvent">
    <p>def <span class="ident">listenKeyEvent</span>(</p><p>cls, eventtype, key, callback)</p>
    </div>
    

    
  
    <div class="desc"><p>Register to receive keyboard events. The <code>eventtype</code> parameter is a 
string that indicates what type of key event to receive (value is one
of: <code>'keydown'</code>, <code>'keyup'</code> or <code>'keypress'</code>). The <code>key</code> parameter is a 
string indicating which key (e.g. <code>'space'</code>, <code>'left arrow'</code>, etc.) to 
receive events for. The <code>callback</code> parameter is a reference to a 
function or method that will be called with the <code>ggame.KeyEvent</code> object
when the event occurs.</p>
<p>See the source for <code>ggame.KeyEvent.keys</code> for a list of key names
to use with the <code>key</code> paramter.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MathApp.listenKeyEvent', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MathApp.listenKeyEvent" class="source">
    <pre><code>@classmethod
def listenKeyEvent(cls, eventtype, key, callback):
    """
    Register to receive keyboard events. The `eventtype` parameter is a 
    string that indicates what type of key event to receive (value is one
    of: `'keydown'`, `'keyup'` or `'keypress'`). The `key` parameter is a 
    string indicating which key (e.g. `'space'`, `'left arrow'`, etc.) to 
    receive events for. The `callback` parameter is a reference to a 
    function or method that will be called with the `ggame.KeyEvent` object
    when the event occurs.
    See the source for `ggame.KeyEvent.keys` for a list of key names
    to use with the `key` paramter.
    """
    evtlist = App._eventdict.get((eventtype, key), [])
    if not callback in evtlist:
        evtlist.append(callback)
    App._eventdict[(eventtype, key)] = evtlist
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MathApp.listenMouseEvent">
    <p>def <span class="ident">listenMouseEvent</span>(</p><p>cls, eventtype, callback)</p>
    </div>
    

    
  
    <div class="desc"><p>Register to receive mouse events. The <code>eventtype</code> parameter is
a string that indicates what type of mouse event to receive (
value is one of: <code>'mousemove'</code>, <code>'mousedown'</code>, <code>'mouseup'</code>, <code>'click'</code>, 
<code>'dblclick'</code> or <code>'mousewheel'</code>). The <code>callback</code> parameter is a 
reference to a function or method that will be called with the 
<code>ggame.MouseEvent</code> object when the event occurs.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MathApp.listenMouseEvent', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MathApp.listenMouseEvent" class="source">
    <pre><code>@classmethod
def listenMouseEvent(cls, eventtype, callback):
    """
    Register to receive mouse events. The `eventtype` parameter is
    a string that indicates what type of mouse event to receive (
    value is one of: `'mousemove'`, `'mousedown'`, `'mouseup'`, `'click'`, 
    `'dblclick'` or `'mousewheel'`). The `callback` parameter is a 
    reference to a function or method that will be called with the 
    `ggame.MouseEvent` object when the event occurs.
    """
    evtlist = App._eventdict.get(eventtype, [])
    if not callback in evtlist:
        evtlist.append(callback)
    App._eventdict[eventtype] = evtlist
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MathApp.logicalToPhysical">
    <p>def <span class="ident">logicalToPhysical</span>(</p><p>cls, lp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MathApp.logicalToPhysical', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MathApp.logicalToPhysical" class="source">
    <pre><code>@classmethod
def logicalToPhysical(cls, lp):
    xxform = lambda xvalue, xscale, xcenter, physwidth: int((xvalue-xcenter)*xscale + physwidth/2)
    yxform = lambda yvalue, yscale, ycenter, physheight: int(physheight/2 - (yvalue-ycenter)*yscale)
    try:
        return (xxform(lp[0], cls._scale, cls._xcenter, cls._win.width),
            yxform(lp[1], cls._scale, cls._ycenter, cls._win.height))
    except AttributeError:
        return lp
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MathApp.physicalToLogical">
    <p>def <span class="ident">physicalToLogical</span>(</p><p>cls, pp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MathApp.physicalToLogical', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MathApp.physicalToLogical" class="source">
    <pre><code>@classmethod
def physicalToLogical(cls, pp):
    xxform = lambda xvalue, xscale, xcenter, physwidth: (xvalue - physwidth/2)/xscale + xcenter
    yxform = lambda yvalue, yscale, ycenter, physheight: (physheight/2 - yvalue)/yscale + ycenter
    try:
        return (xxform(pp[0], cls._scale, cls._xcenter, cls._win.width),
            yxform(pp[1], cls._scale, cls._ycenter, cls._win.height))
    except AttributeError:
        return pp
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MathApp.removeViewNotification">
    <p>def <span class="ident">removeViewNotification</span>(</p><p>cls, handler)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MathApp.removeViewNotification', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MathApp.removeViewNotification" class="source">
    <pre><code>@classmethod   
def removeViewNotification(cls, handler):
    cls._viewNotificationList.remove(handler)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MathApp.translateLogicalToPhysical">
    <p>def <span class="ident">translateLogicalToPhysical</span>(</p><p>cls, pp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MathApp.translateLogicalToPhysical', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MathApp.translateLogicalToPhysical" class="source">
    <pre><code>@classmethod
def translateLogicalToPhysical(cls, pp):
    xxform = lambda xvalue, xscale: xvalue*xscale
    yxform = lambda yvalue, yscale: -yvalue*yscale
    try:
        return (xxform(pp[0], cls._scale), yxform(pp[1], cls._scale))
    except AttributeError:
        return pp
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MathApp.translatePhysicalToLogical">
    <p>def <span class="ident">translatePhysicalToLogical</span>(</p><p>cls, pp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MathApp.translatePhysicalToLogical', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MathApp.translatePhysicalToLogical" class="source">
    <pre><code>@classmethod
def translatePhysicalToLogical(cls, pp):
    xxform = lambda xvalue, xscale: xvalue/xscale
    yxform = lambda yvalue, yscale: -yvalue/yscale
    try:
        return (xxform(pp[0], cls._scale), yxform(pp[1], cls._scale))
    except AttributeError:
        return pp
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MathApp.unlistenKeyEvent">
    <p>def <span class="ident">unlistenKeyEvent</span>(</p><p>cls, eventtype, key, callback)</p>
    </div>
    

    
  
    <div class="desc"><p>Use this method to remove a registration to receive a particular
keyboard event. Arguments must exactly match those used when
registering for the event.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MathApp.unlistenKeyEvent', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MathApp.unlistenKeyEvent" class="source">
    <pre><code>@classmethod
def unlistenKeyEvent(cls, eventtype, key, callback):
    """
    Use this method to remove a registration to receive a particular
    keyboard event. Arguments must exactly match those used when
    registering for the event.
    """
    App._eventdict[(eventtype,key)].remove(callback)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MathApp.unlistenMouseEvent">
    <p>def <span class="ident">unlistenMouseEvent</span>(</p><p>cls, eventtype, callback)</p>
    </div>
    

    
  
    <div class="desc"><p>Use this method to remove a registration to receive a particular
mouse event. Arguments must exactly match those used when
registering for the event.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MathApp.unlistenMouseEvent', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MathApp.unlistenMouseEvent" class="source">
    <pre><code>@classmethod
def unlistenMouseEvent(cls, eventtype, callback):
    """
    Use this method to remove a registration to receive a particular
    mouse event. Arguments must exactly match those used when
    registering for the event.
    """
    App._eventdict[eventtype].remove(callback)
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ggmath.MetalToggle" class="name">class <span class="ident">MetalToggle</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle" class="source">
    <pre><code>class MetalToggle(InputImageToggle):
    def __init__(self, initindex, *args, **kwargs):
        """
        Required Inputs
        
        * **initindex** index to initial toggle state
        * **pos** position of toggle
        """
        kwargs.setdefault('frame', Frame(0,0,110,150))
        super().__init__("toggle-up-down.png", [True, False], initindex, *args, **kwargs)
        self.scale = 0.4
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggmath.MetalToggle">MetalToggle</a></li>
          <li><a href="#ggmath.InputImageToggle">InputImageToggle</a></li>
          <li><a href="#ggmath.ImagePoint">ImagePoint</a></li>
          <li>__pdoc_file_module__._Point</li>
          <li>__pdoc_file_module__._MathVisual</li>
          <li>ggame.Sprite</li>
          <li>__pdoc_file_module__._MathDynamic</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="ggmath.MetalToggle.defaultcolor" class="name">var <span class="ident">defaultcolor</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MetalToggle.defaultsize" class="name">var <span class="ident">defaultsize</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MetalToggle.defaultstyle" class="name">var <span class="ident">defaultstyle</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MetalToggle.defaultwidth" class="name">var <span class="ident">defaultwidth</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MetalToggle.nonposinputsdef" class="name">var <span class="ident">nonposinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MetalToggle.posinputsdef" class="name">var <span class="ident">posinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.MetalToggle.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, initindex, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Required Inputs</p>
<ul>
<li><strong>initindex</strong> index to initial toggle state</li>
<li><strong>pos</strong> position of toggle</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle.__init__" class="source">
    <pre><code>def __init__(self, initindex, *args, **kwargs):
    """
    Required Inputs
    
    * **initindex** index to initial toggle state
    * **pos** position of toggle
    """
    kwargs.setdefault('frame', Frame(0,0,110,150))
    super().__init__("toggle-up-down.png", [True, False], initindex, *args, **kwargs)
    self.scale = 0.4
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MetalToggle.Eval">
    <p>def <span class="ident">Eval</span>(</p><p>self, val)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle.Eval', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle.Eval" class="source">
    <pre><code>def Eval(self, val):
    if callable(val):
        self._setDynamic() # dynamically defined .. must step
        return val
    else:
        return lambda : val  
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MetalToggle.canstroke">
    <p>def <span class="ident">canstroke</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle.canstroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle.canstroke" class="source">
    <pre><code>def canstroke(self, ppos):
    return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MetalToggle.circularCollisionModel">
    <p>def <span class="ident">circularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle.circularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle.circularCollisionModel" class="source">
    <pre><code>def circularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MetalToggle.collidingPolyWithPoly">
    <p>def <span class="ident">collidingPolyWithPoly</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle.collidingPolyWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle.collidingPolyWithPoly" class="source">
    <pre><code>def collidingPolyWithPoly(self, obj):
    return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MetalToggle.collidingWith">
    <p>def <span class="ident">collidingWith</span>(</p><p>self, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a boolean True if this sprite is currently overlapping the sprite 
referenced by <code>obj</code>. Returns False if checking for collision with 
itself. Returns False if extents of object make it impossible for
collision to occur. Returns True if sprite's <code>edgedef</code> parameter overlaps
with other sprite's <code>edgedef</code> parameter, taking into consideration both
sprites' center, rotation and scale settings.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle.collidingWith', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle.collidingWith" class="source">
    <pre><code>def collidingWith(self, obj):
    """
    Return a boolean True if this sprite is currently overlapping the sprite 
    referenced by `obj`. Returns False if checking for collision with 
    itself. Returns False if extents of object make it impossible for
    collision to occur. Returns True if sprite's `edgedef` parameter overlaps
    with other sprite's `edgedef` parameter, taking into consideration both
    sprites' center, rotation and scale settings.
    """
    if self is obj:
        return False
    else:
        self._setExtents()
        obj._setExtents()
        # Gross check for overlap will usually rule out a collision
        if (self.xmin > obj.xmax
            or self.xmax < obj.xmin
            or self.ymin > obj.ymax
            or self.ymax < obj.ymin):
            return False
        # Otherwise, perform a careful overlap determination
        elif type(self.asset) is CircleAsset:
            if type(obj.asset) is CircleAsset:
                # two circles .. check distance between
                sx = (self.xmin + self.xmax) / 2
                sy = (self.ymin + self.ymax) / 2
                ox = (obj.xmin + obj.xmax) / 2
                oy = (obj.ymin + obj.ymax) / 2
                d = math.sqrt((sx-ox)**2 + (sy-oy)**2)
                return d <= self.width/2 + obj.width/2
            else:
                return self.collidingCircleWithPoly(self, obj)
        else:
            if type(obj.asset) is CircleAsset:
                return self.collidingCircleWithPoly(obj, self)
            else:
                return self.collidingPolyWithPoly(obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MetalToggle.collidingWithSprites">
    <p>def <span class="ident">collidingWithSprites</span>(</p><p>self, sclass=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a list of sprite objects identified by the <code>sclass</code> parameter
that are currently colliding with (that is, with which the <code>ggame.Sprite.collidingWith</code>
method returns True) this sprite. If <code>sclass</code> is set to <code>None</code> (default), then
all other sprites are checked for collision, otherwise, only sprites whose
class matches <code>sclass</code> are checked.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle.collidingWithSprites', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle.collidingWithSprites" class="source">
    <pre><code>def collidingWithSprites(self, sclass = None):
    """
    Return a list of sprite objects identified by the `sclass` parameter
    that are currently colliding with (that is, with which the `ggame.Sprite.collidingWith`
    method returns True) this sprite. If `sclass` is set to `None` (default), then
    all other sprites are checked for collision, otherwise, only sprites whose
    class matches `sclass` are checked.
    """
    if sclass is None:
        slist = App.spritelist
    else:
        slist = App.getSpritesbyClass(sclass)
    return list(filter(self.collidingWith, slist))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MetalToggle.destroy">
    <p>def <span class="ident">destroy</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle.destroy', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle.destroy" class="source">
    <pre><code>def destroy(self):
    MathApp._removeVisual(self)
    MathApp._removeMovable(self)
    MathApp._removeStrokable(self)
    _MathDynamic.destroy(self)
    Sprite.destroy(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MetalToggle.distanceTo">
    <p>def <span class="ident">distanceTo</span>(</p><p>self, otherpoint)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle.distanceTo', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle.distanceTo" class="source">
    <pre><code>def distanceTo(self, otherpoint):
    try:
        pos = self.posinputs.pos
        opos = otherpoint.posinputs.pos
        return MathApp.distance(pos, opos())
    except AttributeError:
        return otherpoint  # presumably a scalar - use this distance
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MetalToggle.firstImage">
    <p>def <span class="ident">firstImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>first</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle.firstImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle.firstImage" class="source">
    <pre><code>def firstImage(self):
    """
    Select and display the *first* image used by this sprite.
    """
    self.GFX.texture = self.asset[0]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MetalToggle.lastImage">
    <p>def <span class="ident">lastImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>last</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle.lastImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle.lastImage" class="source">
    <pre><code>def lastImage(self):
    """
    Select and display the *last* image used by this sprite.
    """
    self.GFX.texture = self.asset[-1]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MetalToggle.mousedown">
    <p>def <span class="ident">mousedown</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle.mousedown', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle.mousedown" class="source">
    <pre><code>def mousedown(self):
    self.mouseisdown = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MetalToggle.mouseup">
    <p>def <span class="ident">mouseup</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle.mouseup', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle.mouseup" class="source">
    <pre><code>def mouseup(self):
    self.mouseisdown = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MetalToggle.nextImage">
    <p>def <span class="ident">nextImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>next</em> image used by this sprite.
If the current image is already the <em>last</em> image, then
the image is not advanced.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.nextImage</code> on the last image will cause the <em>first</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle.nextImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle.nextImage" class="source">
    <pre><code>def nextImage(self, wrap = False):
    """
    Select and display the *next* image used by this sprite.
    If the current image is already the *last* image, then
    the image is not advanced.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.nextImage` on the last image will cause the *first*
    image to be loaded.
    """
    self._index += 1
    if self._index >= len(self.asset):
        if wrap:
            self._index = 0
        else:
            self._index = len(self.asset)-1
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MetalToggle.physicalPointTouching">
    <p>def <span class="ident">physicalPointTouching</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle.physicalPointTouching', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle.physicalPointTouching" class="source">
    <pre><code>def physicalPointTouching(self, ppos):
    self._setExtents()  # ensure xmin, xmax are correct
    x, y = ppos
    return x >= self.xmin and x < self.xmax and y >= self.ymin and y <= self.ymax
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MetalToggle.prevImage">
    <p>def <span class="ident">prevImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>previous</em> image used by this sprite.
If the current image is already the <em>first</em> image, then
the image is not changed.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.prevImage</code> on the first image will cause the <em>last</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle.prevImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle.prevImage" class="source">
    <pre><code>def prevImage(self, wrap = False):
    """
    Select and display the *previous* image used by this sprite.
    If the current image is already the *first* image, then
    the image is not changed.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.prevImage` on the first image will cause the *last*
    image to be loaded.
    """
    self._index -= 1
    if self._index < 0:
        if wrap:
            self._index = len(self.asset)-1
        else:
            self._index = 0
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MetalToggle.processEvent">
    <p>def <span class="ident">processEvent</span>(</p><p>self, event)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle.processEvent', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle.processEvent" class="source">
    <pre><code>def processEvent(self, event):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MetalToggle.rectangularCollisionModel">
    <p>def <span class="ident">rectangularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle.rectangularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle.rectangularCollisionModel" class="source">
    <pre><code>def rectangularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MetalToggle.select">
    <p>def <span class="ident">select</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle.select', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle.select" class="source">
    <pre><code>def select(self):
    super().select()
    self.togglestate += 1
    if self.togglestate == len(self.statelist):
        self.togglestate = 0
    self.setImage(self.togglestate)
    self.unselect()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MetalToggle.setImage">
    <p>def <span class="ident">setImage</span>(</p><p>self, index=0)</p>
    </div>
    

    
  
    <div class="desc"><p>Select the image to display by giving its <code>index</code>, where an index
of zero represents the <em>first</em> image in the asset.</p>
<p>This is equivalent to setting the <code>ggame.Sprite.index</code> property
directly.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle.setImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle.setImage" class="source">
    <pre><code>def setImage(self, index=0):
    """
    Select the image to display by giving its `index`, where an index
    of zero represents the *first* image in the asset.
    This is equivalent to setting the `ggame.Sprite.index` property
    directly.
    """
    self.index = index
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MetalToggle.step">
    <p>def <span class="ident">step</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle.step', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle.step" class="source">
    <pre><code>def step(self):
    pass  # FIXME
    self._touchAsset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MetalToggle.stroke">
    <p>def <span class="ident">stroke</span>(</p><p>self, ppos, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle.stroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle.stroke" class="source">
    <pre><code>def stroke(self, ppos, pdisp):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MetalToggle.translate">
    <p>def <span class="ident">translate</span>(</p><p>self, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle.translate', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle.translate" class="source">
    <pre><code>def translate(self, pdisp):
    ldisp = MathApp.translatePhysicalToLogical(pdisp)
    pos = self.posinputs.pos()
    self.posinputs = self.posinputs._replace(pos=self.Eval((pos[0] + ldisp[0], pos[1] + ldisp[1])))
    self._touchAsset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.MetalToggle.unselect">
    <p>def <span class="ident">unselect</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle.unselect', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle.unselect" class="source">
    <pre><code>def unselect(self):
    self.selected = False
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggmath.MetalToggle.center" class="name">var <span class="ident">center</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#ggmath.ImagePoint">ImagePoint</a></code>.<code><a href="#ggmath.ImagePoint.center">center</a></code>
    </p>

            
  
    <div class="desc inherited"><p>This attribute represents the horizontal and vertical position of the 
sprite "center" as a tuple of floating point numbers. See the 
descriptions for <code>ggame.Sprite.fxcenter</code> and <code>ggame.Sprite.fycenter</code> for 
more details.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MetalToggle.fxcenter" class="name">var <span class="ident">fxcenter</span></p>
            

            
  
    <div class="desc"><p>This represents the horizontal position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its left hand edge. A value of 1.0 refers to its 
right hand edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MetalToggle.fycenter" class="name">var <span class="ident">fycenter</span></p>
            

            
  
    <div class="desc"><p>This represents the vertical position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its top edge. A value of 1.0 refers to its 
bottom edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MetalToggle.height" class="name">var <span class="ident">height</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display height of the sprite.
Assigning a value to the height will scale the image vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MetalToggle.index" class="name">var <span class="ident">index</span></p>
            

            
  
    <div class="desc"><p>This is an integer index in to the list of images available for this sprite.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MetalToggle.movable" class="name">var <span class="ident">movable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MetalToggle.position" class="name">var <span class="ident">position</span></p>
            

            
  
    <div class="desc"><p>This represents the (x,y) coordinates of the sprite on the screen. Assigning
a value to this attribute will move the sprite to the new coordinates.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MetalToggle.rotation" class="name">var <span class="ident">rotation</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the rotation of the sprite on the screen.
Value may be a floating point number. A value of 0.0 means no rotation. A value 
of 1.0 means  a rotation of 1 radian in a counter-clockwise direction. One radian
is 180/pi or approximately 57.3 degrees.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MetalToggle.scale" class="name">var <span class="ident">scale</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MetalToggle.selectable" class="name">var <span class="ident">selectable</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#ggmath.InputImageToggle">InputImageToggle</a></code>.<code><a href="#ggmath.InputImageToggle.selectable">selectable</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MetalToggle.strokable" class="name">var <span class="ident">strokable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MetalToggle.visible" class="name">var <span class="ident">visible</span></p>
            

            
  
    <div class="desc"><p>This boolean attribute may be used to change the visibility of the sprite. Setting
<code>ggame.Sprite.visible</code> to <code>False</code> will prevent the sprite from rendering on the 
screen.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MetalToggle.width" class="name">var <span class="ident">width</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display width of the sprite.
Assigning a value to the width will scale the image horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MetalToggle.x" class="name">var <span class="ident">x</span></p>
            

            
  
    <div class="desc"><p>This represents the x-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.MetalToggle.y" class="name">var <span class="ident">y</span></p>
            

            
  
    <div class="desc"><p>This represents the y-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.MetalToggle.collidingCircleWithPoly">
    <p>def <span class="ident">collidingCircleWithPoly</span>(</p><p>cls, circ, poly)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.MetalToggle.collidingCircleWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.MetalToggle.collidingCircleWithPoly" class="source">
    <pre><code>@classmethod
def collidingCircleWithPoly(cls, circ, poly):
    return True
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ggmath.Point" class="name">class <span class="ident">Point</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point" class="source">
    <pre><code>class Point(_Point):


    defaultsize = 5
    defaultstyle = LineStyle(0, Color(0, 1))


    def __init__(self, *args, **kwargs):
        """
        Required Inputs
        
        * **pos** position of point
        """
        super().__init__(CircleAsset(self.defaultsize, 
            self.defaultstyle, self.defaultcolor), *args, **kwargs)


    def _buildAsset(self):
        return CircleAsset(self.stdinputs.size(),
                            self.stdinputs.style(),
                            self.stdinputs.color())
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggmath.Point">Point</a></li>
          <li>__pdoc_file_module__._Point</li>
          <li>__pdoc_file_module__._MathVisual</li>
          <li>ggame.Sprite</li>
          <li>__pdoc_file_module__._MathDynamic</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="ggmath.Point.defaultcolor" class="name">var <span class="ident">defaultcolor</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Point.defaultsize" class="name">var <span class="ident">defaultsize</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Point.defaultstyle" class="name">var <span class="ident">defaultstyle</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Point.defaultwidth" class="name">var <span class="ident">defaultwidth</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Point.nonposinputsdef" class="name">var <span class="ident">nonposinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Point.posinputsdef" class="name">var <span class="ident">posinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.Point.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Required Inputs</p>
<ul>
<li><strong>pos</strong> position of point</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point.__init__" class="source">
    <pre><code>def __init__(self, *args, **kwargs):
    """
    Required Inputs
    
    * **pos** position of point
    """
    super().__init__(CircleAsset(self.defaultsize, 
        self.defaultstyle, self.defaultcolor), *args, **kwargs)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Point.Eval">
    <p>def <span class="ident">Eval</span>(</p><p>self, val)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point.Eval', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point.Eval" class="source">
    <pre><code>def Eval(self, val):
    if callable(val):
        self._setDynamic() # dynamically defined .. must step
        return val
    else:
        return lambda : val  
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Point.canstroke">
    <p>def <span class="ident">canstroke</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point.canstroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point.canstroke" class="source">
    <pre><code>def canstroke(self, ppos):
    return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Point.circularCollisionModel">
    <p>def <span class="ident">circularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point.circularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point.circularCollisionModel" class="source">
    <pre><code>def circularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Point.collidingPolyWithPoly">
    <p>def <span class="ident">collidingPolyWithPoly</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point.collidingPolyWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point.collidingPolyWithPoly" class="source">
    <pre><code>def collidingPolyWithPoly(self, obj):
    return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Point.collidingWith">
    <p>def <span class="ident">collidingWith</span>(</p><p>self, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a boolean True if this sprite is currently overlapping the sprite 
referenced by <code>obj</code>. Returns False if checking for collision with 
itself. Returns False if extents of object make it impossible for
collision to occur. Returns True if sprite's <code>edgedef</code> parameter overlaps
with other sprite's <code>edgedef</code> parameter, taking into consideration both
sprites' center, rotation and scale settings.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point.collidingWith', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point.collidingWith" class="source">
    <pre><code>def collidingWith(self, obj):
    """
    Return a boolean True if this sprite is currently overlapping the sprite 
    referenced by `obj`. Returns False if checking for collision with 
    itself. Returns False if extents of object make it impossible for
    collision to occur. Returns True if sprite's `edgedef` parameter overlaps
    with other sprite's `edgedef` parameter, taking into consideration both
    sprites' center, rotation and scale settings.
    """
    if self is obj:
        return False
    else:
        self._setExtents()
        obj._setExtents()
        # Gross check for overlap will usually rule out a collision
        if (self.xmin > obj.xmax
            or self.xmax < obj.xmin
            or self.ymin > obj.ymax
            or self.ymax < obj.ymin):
            return False
        # Otherwise, perform a careful overlap determination
        elif type(self.asset) is CircleAsset:
            if type(obj.asset) is CircleAsset:
                # two circles .. check distance between
                sx = (self.xmin + self.xmax) / 2
                sy = (self.ymin + self.ymax) / 2
                ox = (obj.xmin + obj.xmax) / 2
                oy = (obj.ymin + obj.ymax) / 2
                d = math.sqrt((sx-ox)**2 + (sy-oy)**2)
                return d <= self.width/2 + obj.width/2
            else:
                return self.collidingCircleWithPoly(self, obj)
        else:
            if type(obj.asset) is CircleAsset:
                return self.collidingCircleWithPoly(obj, self)
            else:
                return self.collidingPolyWithPoly(obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Point.collidingWithSprites">
    <p>def <span class="ident">collidingWithSprites</span>(</p><p>self, sclass=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a list of sprite objects identified by the <code>sclass</code> parameter
that are currently colliding with (that is, with which the <code>ggame.Sprite.collidingWith</code>
method returns True) this sprite. If <code>sclass</code> is set to <code>None</code> (default), then
all other sprites are checked for collision, otherwise, only sprites whose
class matches <code>sclass</code> are checked.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point.collidingWithSprites', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point.collidingWithSprites" class="source">
    <pre><code>def collidingWithSprites(self, sclass = None):
    """
    Return a list of sprite objects identified by the `sclass` parameter
    that are currently colliding with (that is, with which the `ggame.Sprite.collidingWith`
    method returns True) this sprite. If `sclass` is set to `None` (default), then
    all other sprites are checked for collision, otherwise, only sprites whose
    class matches `sclass` are checked.
    """
    if sclass is None:
        slist = App.spritelist
    else:
        slist = App.getSpritesbyClass(sclass)
    return list(filter(self.collidingWith, slist))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Point.destroy">
    <p>def <span class="ident">destroy</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point.destroy', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point.destroy" class="source">
    <pre><code>def destroy(self):
    MathApp._removeVisual(self)
    MathApp._removeMovable(self)
    MathApp._removeStrokable(self)
    _MathDynamic.destroy(self)
    Sprite.destroy(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Point.distanceTo">
    <p>def <span class="ident">distanceTo</span>(</p><p>self, otherpoint)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point.distanceTo', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point.distanceTo" class="source">
    <pre><code>def distanceTo(self, otherpoint):
    try:
        pos = self.posinputs.pos
        opos = otherpoint.posinputs.pos
        return MathApp.distance(pos, opos())
    except AttributeError:
        return otherpoint  # presumably a scalar - use this distance
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Point.firstImage">
    <p>def <span class="ident">firstImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>first</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point.firstImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point.firstImage" class="source">
    <pre><code>def firstImage(self):
    """
    Select and display the *first* image used by this sprite.
    """
    self.GFX.texture = self.asset[0]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Point.lastImage">
    <p>def <span class="ident">lastImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>last</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point.lastImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point.lastImage" class="source">
    <pre><code>def lastImage(self):
    """
    Select and display the *last* image used by this sprite.
    """
    self.GFX.texture = self.asset[-1]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Point.mousedown">
    <p>def <span class="ident">mousedown</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point.mousedown', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point.mousedown" class="source">
    <pre><code>def mousedown(self):
    self.mouseisdown = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Point.mouseup">
    <p>def <span class="ident">mouseup</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point.mouseup', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point.mouseup" class="source">
    <pre><code>def mouseup(self):
    self.mouseisdown = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Point.nextImage">
    <p>def <span class="ident">nextImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>next</em> image used by this sprite.
If the current image is already the <em>last</em> image, then
the image is not advanced.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.nextImage</code> on the last image will cause the <em>first</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point.nextImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point.nextImage" class="source">
    <pre><code>def nextImage(self, wrap = False):
    """
    Select and display the *next* image used by this sprite.
    If the current image is already the *last* image, then
    the image is not advanced.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.nextImage` on the last image will cause the *first*
    image to be loaded.
    """
    self._index += 1
    if self._index >= len(self.asset):
        if wrap:
            self._index = 0
        else:
            self._index = len(self.asset)-1
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Point.physicalPointTouching">
    <p>def <span class="ident">physicalPointTouching</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point.physicalPointTouching', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point.physicalPointTouching" class="source">
    <pre><code>def physicalPointTouching(self, ppos):
    return MathApp.distance(ppos, self.pposinputs.pos) < self.sstdinputs.size
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Point.prevImage">
    <p>def <span class="ident">prevImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>previous</em> image used by this sprite.
If the current image is already the <em>first</em> image, then
the image is not changed.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.prevImage</code> on the first image will cause the <em>last</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point.prevImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point.prevImage" class="source">
    <pre><code>def prevImage(self, wrap = False):
    """
    Select and display the *previous* image used by this sprite.
    If the current image is already the *first* image, then
    the image is not changed.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.prevImage` on the first image will cause the *last*
    image to be loaded.
    """
    self._index -= 1
    if self._index < 0:
        if wrap:
            self._index = len(self.asset)-1
        else:
            self._index = 0
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Point.processEvent">
    <p>def <span class="ident">processEvent</span>(</p><p>self, event)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point.processEvent', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point.processEvent" class="source">
    <pre><code>def processEvent(self, event):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Point.rectangularCollisionModel">
    <p>def <span class="ident">rectangularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point.rectangularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point.rectangularCollisionModel" class="source">
    <pre><code>def rectangularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Point.select">
    <p>def <span class="ident">select</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point.select', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point.select" class="source">
    <pre><code>def select(self):
    self.selected = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Point.setImage">
    <p>def <span class="ident">setImage</span>(</p><p>self, index=0)</p>
    </div>
    

    
  
    <div class="desc"><p>Select the image to display by giving its <code>index</code>, where an index
of zero represents the <em>first</em> image in the asset.</p>
<p>This is equivalent to setting the <code>ggame.Sprite.index</code> property
directly.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point.setImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point.setImage" class="source">
    <pre><code>def setImage(self, index=0):
    """
    Select the image to display by giving its `index`, where an index
    of zero represents the *first* image in the asset.
    This is equivalent to setting the `ggame.Sprite.index` property
    directly.
    """
    self.index = index
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Point.step">
    <p>def <span class="ident">step</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point.step', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point.step" class="source">
    <pre><code>def step(self):
    pass  # FIXME
    self._touchAsset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Point.stroke">
    <p>def <span class="ident">stroke</span>(</p><p>self, ppos, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point.stroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point.stroke" class="source">
    <pre><code>def stroke(self, ppos, pdisp):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Point.translate">
    <p>def <span class="ident">translate</span>(</p><p>self, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point.translate', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point.translate" class="source">
    <pre><code>def translate(self, pdisp):
    ldisp = MathApp.translatePhysicalToLogical(pdisp)
    pos = self.posinputs.pos()
    self.posinputs = self.posinputs._replace(pos=self.Eval((pos[0] + ldisp[0], pos[1] + ldisp[1])))
    self._touchAsset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Point.unselect">
    <p>def <span class="ident">unselect</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point.unselect', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point.unselect" class="source">
    <pre><code>def unselect(self):
    self.selected = False
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggmath.Point.center" class="name">var <span class="ident">center</span></p>
            

            
  
    <div class="desc"><p>This attribute represents the horizontal and vertical position of the 
sprite "center" as a tuple of floating point numbers. See the 
descriptions for <code>ggame.Sprite.fxcenter</code> and <code>ggame.Sprite.fycenter</code> for 
more details.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Point.fxcenter" class="name">var <span class="ident">fxcenter</span></p>
            

            
  
    <div class="desc"><p>This represents the horizontal position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its left hand edge. A value of 1.0 refers to its 
right hand edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Point.fycenter" class="name">var <span class="ident">fycenter</span></p>
            

            
  
    <div class="desc"><p>This represents the vertical position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its top edge. A value of 1.0 refers to its 
bottom edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Point.height" class="name">var <span class="ident">height</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display height of the sprite.
Assigning a value to the height will scale the image vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Point.index" class="name">var <span class="ident">index</span></p>
            

            
  
    <div class="desc"><p>This is an integer index in to the list of images available for this sprite.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Point.movable" class="name">var <span class="ident">movable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Point.position" class="name">var <span class="ident">position</span></p>
            

            
  
    <div class="desc"><p>This represents the (x,y) coordinates of the sprite on the screen. Assigning
a value to this attribute will move the sprite to the new coordinates.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Point.rotation" class="name">var <span class="ident">rotation</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the rotation of the sprite on the screen.
Value may be a floating point number. A value of 0.0 means no rotation. A value 
of 1.0 means  a rotation of 1 radian in a counter-clockwise direction. One radian
is 180/pi or approximately 57.3 degrees.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Point.scale" class="name">var <span class="ident">scale</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the size of the sprite ('scale' it) on the 
screen. Value may be a floating point number. A value of 1.0 means that the sprite
image will keep its original size. A value of 2.0 would double it, etc.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Point.selectable" class="name">var <span class="ident">selectable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Point.strokable" class="name">var <span class="ident">strokable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Point.visible" class="name">var <span class="ident">visible</span></p>
            

            
  
    <div class="desc"><p>This boolean attribute may be used to change the visibility of the sprite. Setting
<code>ggame.Sprite.visible</code> to <code>False</code> will prevent the sprite from rendering on the 
screen.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Point.width" class="name">var <span class="ident">width</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display width of the sprite.
Assigning a value to the width will scale the image horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Point.x" class="name">var <span class="ident">x</span></p>
            

            
  
    <div class="desc"><p>This represents the x-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Point.y" class="name">var <span class="ident">y</span></p>
            

            
  
    <div class="desc"><p>This represents the y-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.Point.collidingCircleWithPoly">
    <p>def <span class="ident">collidingCircleWithPoly</span>(</p><p>cls, circ, poly)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Point.collidingCircleWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Point.collidingCircleWithPoly" class="source">
    <pre><code>@classmethod
def collidingCircleWithPoly(cls, circ, poly):
    return True
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ggmath.Slider" class="name">class <span class="ident">Slider</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider" class="source">
    <pre><code>class Slider(_MathVisual):
    
    posinputsdef = ['pos']
    nonposinputsdef = ['minval','maxval','initial']

    def __init__(self, *args, **kwargs):
        super().__init__(
            RectangleAsset(1, 1), *args, **kwargs)
        self._val = self.nposinputs.initial()
        self._steps = kwargs.get('steps', 50)
        self._step = (self.nposinputs.maxval()-self.nposinputs.minval())/self._steps
        self._leftctrl = kwargs.get('leftkey', None)
        self._rightctrl = kwargs.get('rightkey', None)
        self._centerctrl = kwargs.get('centerkey', None)
        self.selectable = True  # must be after super init!
        self.strokable = True  # this enables grabbing/slideing the thumb
        self.thumbcaptured = False
        self._thumbwidth = max(self.stdinputs.width()/40, 1)
        self.thumb = Sprite(RectangleAsset(self._thumbwidth, 
            self.stdinputs.size()-2, LineStyle(1, self.stdinputs.color()), self.stdinputs.color()), 
            self.thumbXY())
        self._touchAsset()
        if self._leftctrl:
            MathApp.listenKeyEvent("keydown", self._leftctrl, self.moveLeft)
        if self._rightctrl:
            MathApp.listenKeyEvent("keydown", self._rightctrl, self.moveRight)
        if self._centerctrl:
            MathApp.listenKeyEvent("keydown", self._centerctrl, self.moveCenter)

    def thumbXY(self):
        minval = self.nposinputs.minval()
        maxval = self.nposinputs.maxval()
        return (self.spposinputs.pos[0]+(self._val-minval)*
                (self.sstdinputs.width-self._thumbwidth)/(maxval-minval),
                self.spposinputs.pos[1]+1)
            
    def __call__(self):
        return self._val

    @property
    def value(self):
        return self._val
        
    @value.setter
    def value(self, val):
        self._setval(val)

    def _buildAsset(self):
        self.setThumb()
        return RectangleAsset(
            self.stdinputs.width(), self.stdinputs.size(), 
            line=self.stdinputs.style(), fill=Color(0,0))

    def setThumb(self):
        self.thumb.position = self.thumbXY()
                
    def step(self):
        pass
    
    def _setval(self, val):
        minval = self.nposinputs.minval()
        maxval = self.nposinputs.maxval()
        if val <= minval:
            self._val = minval
        elif val >= maxval:
            self._val = maxval
        else:
            self._val = round((val - minval)*self._steps/(maxval-minval))*self._step + minval
        self.setThumb()
        
    def increment(self, step):
        self._setval(self._val + step)
        
    def select(self):
        super().select()
        if not self._leftctrl:
            MathApp.listenKeyEvent("keydown", "left arrow", self.moveLeft)
        if not self._rightctrl:
            MathApp.listenKeyEvent("keydown", "right arrow", self.moveRight)
        MathApp.listenMouseEvent("click", self.mouseClick)

    def unselect(self):
        super().unselect()
        try:
            if not self._leftctrl:
                MathApp.unlistenKeyEvent("keydown", "left arrow", self.moveLeft)
            if not self._rightctrl:
                MathApp.unlistenKeyEvent("keydown", "right arrow", self.moveRight)
            MathApp.unlistenMouseEvent("click", self.mouseClick)
        except ValueError:
            pass

    def mouseClick(self, event):
        if self.physicalPointTouching((event.x, event.y)):
            if event.x > self.thumb.x + self._thumbwidth:
                self.moveRight(event)
            elif event.x < self.thumb.x:
                self.moveLeft(event)
                
    def moveLeft(self, event):
        self.increment(-self._step)

    def moveRight(self, event):
        self.increment(self._step)
        
    def moveCenter(self, event):
        self._val = (self.snposinputs.minval + self.snposinputs.maxval)/2
        self.setThumb()
        
    def canstroke(self, ppos):
        return self.physicalPointTouchingThumb(ppos)
        
    def stroke(self, ppos, pdisp):
        _ppos = self.spposinputs.pos
        minval = self.snposinputs.minval
        maxval = self.snposinputs.maxval
        xpos = ppos[0] + pdisp[0]
        self.value = (xpos - _ppos[0])*(maxval-minval)/self.sstdinputs.width + minval

    def physicalPointTouching(self, ppos):
        _ppos = self.spposinputs.pos
        return (ppos[0] >= _ppos[0] and 
            ppos[0] <= _ppos[0] + self.sstdinputs.width and
            ppos[1] >= _ppos[1] and 
            ppos[1] <= _ppos[1] + self.sstdinputs.size)

    def physicalPointTouchingThumb(self, ppos):
        thumbpos = self.thumbXY()
        return (ppos[0] >= thumbpos[0] and 
            ppos[0] <= thumbpos[0] + self._thumbwidth + 2 and
            ppos[1] >= thumbpos[1] and 
            ppos[1] <= thumbpos[1] + self.sstdinputs.size - 2)

    def translate(self, pdisp):
        pass
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggmath.Slider">Slider</a></li>
          <li>__pdoc_file_module__._MathVisual</li>
          <li>ggame.Sprite</li>
          <li>__pdoc_file_module__._MathDynamic</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="ggmath.Slider.defaultcolor" class="name">var <span class="ident">defaultcolor</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Slider.defaultsize" class="name">var <span class="ident">defaultsize</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Slider.defaultstyle" class="name">var <span class="ident">defaultstyle</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Slider.defaultwidth" class="name">var <span class="ident">defaultwidth</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Slider.nonposinputsdef" class="name">var <span class="ident">nonposinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Slider.posinputsdef" class="name">var <span class="ident">posinputsdef</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.__init__" class="source">
    <pre><code>def __init__(self, *args, **kwargs):
    super().__init__(
        RectangleAsset(1, 1), *args, **kwargs)
    self._val = self.nposinputs.initial()
    self._steps = kwargs.get('steps', 50)
    self._step = (self.nposinputs.maxval()-self.nposinputs.minval())/self._steps
    self._leftctrl = kwargs.get('leftkey', None)
    self._rightctrl = kwargs.get('rightkey', None)
    self._centerctrl = kwargs.get('centerkey', None)
    self.selectable = True  # must be after super init!
    self.strokable = True  # this enables grabbing/slideing the thumb
    self.thumbcaptured = False
    self._thumbwidth = max(self.stdinputs.width()/40, 1)
    self.thumb = Sprite(RectangleAsset(self._thumbwidth, 
        self.stdinputs.size()-2, LineStyle(1, self.stdinputs.color()), self.stdinputs.color()), 
        self.thumbXY())
    self._touchAsset()
    if self._leftctrl:
        MathApp.listenKeyEvent("keydown", self._leftctrl, self.moveLeft)
    if self._rightctrl:
        MathApp.listenKeyEvent("keydown", self._rightctrl, self.moveRight)
    if self._centerctrl:
        MathApp.listenKeyEvent("keydown", self._centerctrl, self.moveCenter)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.Eval">
    <p>def <span class="ident">Eval</span>(</p><p>self, val)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.Eval', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.Eval" class="source">
    <pre><code>def Eval(self, val):
    if callable(val):
        self._setDynamic() # dynamically defined .. must step
        return val
    else:
        return lambda : val  
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.canstroke">
    <p>def <span class="ident">canstroke</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.canstroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.canstroke" class="source">
    <pre><code>def canstroke(self, ppos):
    return self.physicalPointTouchingThumb(ppos)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.circularCollisionModel">
    <p>def <span class="ident">circularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.circularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.circularCollisionModel" class="source">
    <pre><code>def circularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.collidingPolyWithPoly">
    <p>def <span class="ident">collidingPolyWithPoly</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.collidingPolyWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.collidingPolyWithPoly" class="source">
    <pre><code>def collidingPolyWithPoly(self, obj):
    return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.collidingWith">
    <p>def <span class="ident">collidingWith</span>(</p><p>self, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a boolean True if this sprite is currently overlapping the sprite 
referenced by <code>obj</code>. Returns False if checking for collision with 
itself. Returns False if extents of object make it impossible for
collision to occur. Returns True if sprite's <code>edgedef</code> parameter overlaps
with other sprite's <code>edgedef</code> parameter, taking into consideration both
sprites' center, rotation and scale settings.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.collidingWith', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.collidingWith" class="source">
    <pre><code>def collidingWith(self, obj):
    """
    Return a boolean True if this sprite is currently overlapping the sprite 
    referenced by `obj`. Returns False if checking for collision with 
    itself. Returns False if extents of object make it impossible for
    collision to occur. Returns True if sprite's `edgedef` parameter overlaps
    with other sprite's `edgedef` parameter, taking into consideration both
    sprites' center, rotation and scale settings.
    """
    if self is obj:
        return False
    else:
        self._setExtents()
        obj._setExtents()
        # Gross check for overlap will usually rule out a collision
        if (self.xmin > obj.xmax
            or self.xmax < obj.xmin
            or self.ymin > obj.ymax
            or self.ymax < obj.ymin):
            return False
        # Otherwise, perform a careful overlap determination
        elif type(self.asset) is CircleAsset:
            if type(obj.asset) is CircleAsset:
                # two circles .. check distance between
                sx = (self.xmin + self.xmax) / 2
                sy = (self.ymin + self.ymax) / 2
                ox = (obj.xmin + obj.xmax) / 2
                oy = (obj.ymin + obj.ymax) / 2
                d = math.sqrt((sx-ox)**2 + (sy-oy)**2)
                return d <= self.width/2 + obj.width/2
            else:
                return self.collidingCircleWithPoly(self, obj)
        else:
            if type(obj.asset) is CircleAsset:
                return self.collidingCircleWithPoly(obj, self)
            else:
                return self.collidingPolyWithPoly(obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.collidingWithSprites">
    <p>def <span class="ident">collidingWithSprites</span>(</p><p>self, sclass=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a list of sprite objects identified by the <code>sclass</code> parameter
that are currently colliding with (that is, with which the <code>ggame.Sprite.collidingWith</code>
method returns True) this sprite. If <code>sclass</code> is set to <code>None</code> (default), then
all other sprites are checked for collision, otherwise, only sprites whose
class matches <code>sclass</code> are checked.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.collidingWithSprites', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.collidingWithSprites" class="source">
    <pre><code>def collidingWithSprites(self, sclass = None):
    """
    Return a list of sprite objects identified by the `sclass` parameter
    that are currently colliding with (that is, with which the `ggame.Sprite.collidingWith`
    method returns True) this sprite. If `sclass` is set to `None` (default), then
    all other sprites are checked for collision, otherwise, only sprites whose
    class matches `sclass` are checked.
    """
    if sclass is None:
        slist = App.spritelist
    else:
        slist = App.getSpritesbyClass(sclass)
    return list(filter(self.collidingWith, slist))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.destroy">
    <p>def <span class="ident">destroy</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.destroy', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.destroy" class="source">
    <pre><code>def destroy(self):
    MathApp._removeVisual(self)
    MathApp._removeMovable(self)
    MathApp._removeStrokable(self)
    _MathDynamic.destroy(self)
    Sprite.destroy(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.firstImage">
    <p>def <span class="ident">firstImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>first</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.firstImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.firstImage" class="source">
    <pre><code>def firstImage(self):
    """
    Select and display the *first* image used by this sprite.
    """
    self.GFX.texture = self.asset[0]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.increment">
    <p>def <span class="ident">increment</span>(</p><p>self, step)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.increment', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.increment" class="source">
    <pre><code>def increment(self, step):
    self._setval(self._val + step)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.lastImage">
    <p>def <span class="ident">lastImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>last</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.lastImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.lastImage" class="source">
    <pre><code>def lastImage(self):
    """
    Select and display the *last* image used by this sprite.
    """
    self.GFX.texture = self.asset[-1]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.mouseClick">
    <p>def <span class="ident">mouseClick</span>(</p><p>self, event)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.mouseClick', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.mouseClick" class="source">
    <pre><code>def mouseClick(self, event):
    if self.physicalPointTouching((event.x, event.y)):
        if event.x > self.thumb.x + self._thumbwidth:
            self.moveRight(event)
        elif event.x < self.thumb.x:
            self.moveLeft(event)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.mousedown">
    <p>def <span class="ident">mousedown</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.mousedown', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.mousedown" class="source">
    <pre><code>def mousedown(self):
    self.mouseisdown = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.mouseup">
    <p>def <span class="ident">mouseup</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.mouseup', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.mouseup" class="source">
    <pre><code>def mouseup(self):
    self.mouseisdown = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.moveCenter">
    <p>def <span class="ident">moveCenter</span>(</p><p>self, event)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.moveCenter', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.moveCenter" class="source">
    <pre><code>def moveCenter(self, event):
    self._val = (self.snposinputs.minval + self.snposinputs.maxval)/2
    self.setThumb()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.moveLeft">
    <p>def <span class="ident">moveLeft</span>(</p><p>self, event)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.moveLeft', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.moveLeft" class="source">
    <pre><code>def moveLeft(self, event):
    self.increment(-self._step)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.moveRight">
    <p>def <span class="ident">moveRight</span>(</p><p>self, event)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.moveRight', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.moveRight" class="source">
    <pre><code>def moveRight(self, event):
    self.increment(self._step)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.nextImage">
    <p>def <span class="ident">nextImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>next</em> image used by this sprite.
If the current image is already the <em>last</em> image, then
the image is not advanced.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.nextImage</code> on the last image will cause the <em>first</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.nextImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.nextImage" class="source">
    <pre><code>def nextImage(self, wrap = False):
    """
    Select and display the *next* image used by this sprite.
    If the current image is already the *last* image, then
    the image is not advanced.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.nextImage` on the last image will cause the *first*
    image to be loaded.
    """
    self._index += 1
    if self._index >= len(self.asset):
        if wrap:
            self._index = 0
        else:
            self._index = len(self.asset)-1
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.physicalPointTouching">
    <p>def <span class="ident">physicalPointTouching</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.physicalPointTouching', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.physicalPointTouching" class="source">
    <pre><code>def physicalPointTouching(self, ppos):
    _ppos = self.spposinputs.pos
    return (ppos[0] >= _ppos[0] and 
        ppos[0] <= _ppos[0] + self.sstdinputs.width and
        ppos[1] >= _ppos[1] and 
        ppos[1] <= _ppos[1] + self.sstdinputs.size)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.physicalPointTouchingThumb">
    <p>def <span class="ident">physicalPointTouchingThumb</span>(</p><p>self, ppos)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.physicalPointTouchingThumb', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.physicalPointTouchingThumb" class="source">
    <pre><code>def physicalPointTouchingThumb(self, ppos):
    thumbpos = self.thumbXY()
    return (ppos[0] >= thumbpos[0] and 
        ppos[0] <= thumbpos[0] + self._thumbwidth + 2 and
        ppos[1] >= thumbpos[1] and 
        ppos[1] <= thumbpos[1] + self.sstdinputs.size - 2)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.prevImage">
    <p>def <span class="ident">prevImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>previous</em> image used by this sprite.
If the current image is already the <em>first</em> image, then
the image is not changed.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<code>ggame.Sprite.prevImage</code> on the first image will cause the <em>last</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.prevImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.prevImage" class="source">
    <pre><code>def prevImage(self, wrap = False):
    """
    Select and display the *previous* image used by this sprite.
    If the current image is already the *first* image, then
    the image is not changed.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.prevImage` on the first image will cause the *last*
    image to be loaded.
    """
    self._index -= 1
    if self._index < 0:
        if wrap:
            self._index = len(self.asset)-1
        else:
            self._index = 0
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.processEvent">
    <p>def <span class="ident">processEvent</span>(</p><p>self, event)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.processEvent', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.processEvent" class="source">
    <pre><code>def processEvent(self, event):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.rectangularCollisionModel">
    <p>def <span class="ident">rectangularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.rectangularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.rectangularCollisionModel" class="source">
    <pre><code>def rectangularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.select">
    <p>def <span class="ident">select</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.select', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.select" class="source">
    <pre><code>def select(self):
    super().select()
    if not self._leftctrl:
        MathApp.listenKeyEvent("keydown", "left arrow", self.moveLeft)
    if not self._rightctrl:
        MathApp.listenKeyEvent("keydown", "right arrow", self.moveRight)
    MathApp.listenMouseEvent("click", self.mouseClick)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.setImage">
    <p>def <span class="ident">setImage</span>(</p><p>self, index=0)</p>
    </div>
    

    
  
    <div class="desc"><p>Select the image to display by giving its <code>index</code>, where an index
of zero represents the <em>first</em> image in the asset.</p>
<p>This is equivalent to setting the <code>ggame.Sprite.index</code> property
directly.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.setImage', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.setImage" class="source">
    <pre><code>def setImage(self, index=0):
    """
    Select the image to display by giving its `index`, where an index
    of zero represents the *first* image in the asset.
    This is equivalent to setting the `ggame.Sprite.index` property
    directly.
    """
    self.index = index
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.setThumb">
    <p>def <span class="ident">setThumb</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.setThumb', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.setThumb" class="source">
    <pre><code>def setThumb(self):
    self.thumb.position = self.thumbXY()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.step">
    <p>def <span class="ident">step</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.step', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.step" class="source">
    <pre><code>def step(self):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.stroke">
    <p>def <span class="ident">stroke</span>(</p><p>self, ppos, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.stroke', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.stroke" class="source">
    <pre><code>def stroke(self, ppos, pdisp):
    _ppos = self.spposinputs.pos
    minval = self.snposinputs.minval
    maxval = self.snposinputs.maxval
    xpos = ppos[0] + pdisp[0]
    self.value = (xpos - _ppos[0])*(maxval-minval)/self.sstdinputs.width + minval
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.thumbXY">
    <p>def <span class="ident">thumbXY</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.thumbXY', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.thumbXY" class="source">
    <pre><code>def thumbXY(self):
    minval = self.nposinputs.minval()
    maxval = self.nposinputs.maxval()
    return (self.spposinputs.pos[0]+(self._val-minval)*
            (self.sstdinputs.width-self._thumbwidth)/(maxval-minval),
            self.spposinputs.pos[1]+1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.translate">
    <p>def <span class="ident">translate</span>(</p><p>self, pdisp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.translate', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.translate" class="source">
    <pre><code>def translate(self, pdisp):
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.unselect">
    <p>def <span class="ident">unselect</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.unselect', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.unselect" class="source">
    <pre><code>def unselect(self):
    super().unselect()
    try:
        if not self._leftctrl:
            MathApp.unlistenKeyEvent("keydown", "left arrow", self.moveLeft)
        if not self._rightctrl:
            MathApp.unlistenKeyEvent("keydown", "right arrow", self.moveRight)
        MathApp.unlistenMouseEvent("click", self.mouseClick)
    except ValueError:
        pass
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggmath.Slider.center" class="name">var <span class="ident">center</span></p>
            

            
  
    <div class="desc"><p>This attribute represents the horizontal and vertical position of the 
sprite "center" as a tuple of floating point numbers. See the 
descriptions for <code>ggame.Sprite.fxcenter</code> and <code>ggame.Sprite.fycenter</code> for 
more details.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Slider.fxcenter" class="name">var <span class="ident">fxcenter</span></p>
            

            
  
    <div class="desc"><p>This represents the horizontal position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its left hand edge. A value of 1.0 refers to its 
right hand edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Slider.fycenter" class="name">var <span class="ident">fycenter</span></p>
            

            
  
    <div class="desc"><p>This represents the vertical position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its top edge. A value of 1.0 refers to its 
bottom edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Slider.height" class="name">var <span class="ident">height</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display height of the sprite.
Assigning a value to the height will scale the image vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Slider.index" class="name">var <span class="ident">index</span></p>
            

            
  
    <div class="desc"><p>This is an integer index in to the list of images available for this sprite.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Slider.movable" class="name">var <span class="ident">movable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Slider.position" class="name">var <span class="ident">position</span></p>
            

            
  
    <div class="desc"><p>This represents the (x,y) coordinates of the sprite on the screen. Assigning
a value to this attribute will move the sprite to the new coordinates.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Slider.rotation" class="name">var <span class="ident">rotation</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the rotation of the sprite on the screen.
Value may be a floating point number. A value of 0.0 means no rotation. A value 
of 1.0 means  a rotation of 1 radian in a counter-clockwise direction. One radian
is 180/pi or approximately 57.3 degrees.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Slider.scale" class="name">var <span class="ident">scale</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the size of the sprite ('scale' it) on the 
screen. Value may be a floating point number. A value of 1.0 means that the sprite
image will keep its original size. A value of 2.0 would double it, etc.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Slider.selectable" class="name">var <span class="ident">selectable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Slider.strokable" class="name">var <span class="ident">strokable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Slider.thumb" class="name">var <span class="ident">thumb</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Slider.thumbcaptured" class="name">var <span class="ident">thumbcaptured</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Slider.value" class="name">var <span class="ident">value</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Slider.visible" class="name">var <span class="ident">visible</span></p>
            

            
  
    <div class="desc"><p>This boolean attribute may be used to change the visibility of the sprite. Setting
<code>ggame.Sprite.visible</code> to <code>False</code> will prevent the sprite from rendering on the 
screen.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Slider.width" class="name">var <span class="ident">width</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display width of the sprite.
Assigning a value to the width will scale the image horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Slider.x" class="name">var <span class="ident">x</span></p>
            

            
  
    <div class="desc"><p>This represents the x-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Slider.y" class="name">var <span class="ident">y</span></p>
            

            
  
    <div class="desc"><p>This represents the y-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.Slider.collidingCircleWithPoly">
    <p>def <span class="ident">collidingCircleWithPoly</span>(</p><p>cls, circ, poly)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Slider.collidingCircleWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Slider.collidingCircleWithPoly" class="source">
    <pre><code>@classmethod
def collidingCircleWithPoly(cls, circ, poly):
    return True
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ggmath.Timer" class="name">class <span class="ident">Timer</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Timer', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Timer" class="source">
    <pre><code>class Timer(_MathDynamic):
    
    def __init__(self):
        super().__init__()
        self.once = []
        self.callbacks = {}
        self.reset()
        self.step()
        self._start = self._reset  #first time
        self.next = None
        MathApp._addDynamic(self)  # always dynamically defined
        
    def reset(self):
        self._reset = MathApp.time
        
    def step(self):
        nexttimers = []
        calllist = []
        self.time = MathApp.time - self._reset
        while self.once and self.once[0][0] <= MathApp.time:
            tickinfo = self.once.pop(0)
            if tickinfo[1]:  # periodic?
                nexttimers.append((tickinfo[1], self.callbacks[tickinfo][0]))  # delay, callback
            calllist.append(self.callbacks[tickinfo].pop(0)) # remove callback and queue it
            if not self.callbacks[tickinfo]: # if the callback list is empty
                del self.callbacks[tickinfo] # remove the dictionary entry altogether
        for tickadd in nexttimers:
            self.callAfter(tickadd[0], tickadd[1], True)  # keep it going
        for call in calllist:
            call(self)

    def callAfter(self, delay, callback, periodic=False):
        key = (MathApp.time + delay, delay if periodic else 0)
        self.once.append(key)
        callbacklist = self.callbacks.get(key, [])
        callbacklist.append(callback)
        self.callbacks[key] = callbacklist
        self.once.sort()
        
    def callAt(self, time, callback):
        self.callAfter(time-self.time, callback)
        
    def callEvery(self, period, callback):
        self.callAfter(period, callback, True)

    def __call__(self):
        return self.time
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggmath.Timer">Timer</a></li>
          <li>__pdoc_file_module__._MathDynamic</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggmath.Timer.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Timer.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Timer.__init__" class="source">
    <pre><code>def __init__(self):
    super().__init__()
    self.once = []
    self.callbacks = {}
    self.reset()
    self.step()
    self._start = self._reset  #first time
    self.next = None
    MathApp._addDynamic(self)  # always dynamically defined
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Timer.Eval">
    <p>def <span class="ident">Eval</span>(</p><p>self, val)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Timer.Eval', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Timer.Eval" class="source">
    <pre><code>def Eval(self, val):
    if callable(val):
        self._setDynamic() # dynamically defined .. must step
        return val
    else:
        return lambda : val  
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Timer.callAfter">
    <p>def <span class="ident">callAfter</span>(</p><p>self, delay, callback, periodic=False)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Timer.callAfter', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Timer.callAfter" class="source">
    <pre><code>def callAfter(self, delay, callback, periodic=False):
    key = (MathApp.time + delay, delay if periodic else 0)
    self.once.append(key)
    callbacklist = self.callbacks.get(key, [])
    callbacklist.append(callback)
    self.callbacks[key] = callbacklist
    self.once.sort()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Timer.callAt">
    <p>def <span class="ident">callAt</span>(</p><p>self, time, callback)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Timer.callAt', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Timer.callAt" class="source">
    <pre><code>def callAt(self, time, callback):
    self.callAfter(time-self.time, callback)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Timer.callEvery">
    <p>def <span class="ident">callEvery</span>(</p><p>self, period, callback)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Timer.callEvery', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Timer.callEvery" class="source">
    <pre><code>def callEvery(self, period, callback):
    self.callAfter(period, callback, True)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Timer.destroy">
    <p>def <span class="ident">destroy</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Timer.destroy', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Timer.destroy" class="source">
    <pre><code>def destroy(self):
    MathApp._removeDynamic(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Timer.reset">
    <p>def <span class="ident">reset</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Timer.reset', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Timer.reset" class="source">
    <pre><code>def reset(self):
    self._reset = MathApp.time
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggmath.Timer.step">
    <p>def <span class="ident">step</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggmath.Timer.step', this);">Show source &equiv;</a></p>
  <div id="source-ggmath.Timer.step" class="source">
    <pre><code>def step(self):
    nexttimers = []
    calllist = []
    self.time = MathApp.time - self._reset
    while self.once and self.once[0][0] <= MathApp.time:
        tickinfo = self.once.pop(0)
        if tickinfo[1]:  # periodic?
            nexttimers.append((tickinfo[1], self.callbacks[tickinfo][0]))  # delay, callback
        calllist.append(self.callbacks[tickinfo].pop(0)) # remove callback and queue it
        if not self.callbacks[tickinfo]: # if the callback list is empty
            del self.callbacks[tickinfo] # remove the dictionary entry altogether
    for tickadd in nexttimers:
        self.callAfter(tickadd[0], tickadd[1], True)  # keep it going
    for call in calllist:
        call(self)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggmath.Timer.callbacks" class="name">var <span class="ident">callbacks</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Timer.next" class="name">var <span class="ident">next</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggmath.Timer.once" class="name">var <span class="ident">once</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.1</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
