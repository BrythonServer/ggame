<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>ggame API documentation</title>
    <meta name="description" content="# ggame
The simple cross-platform sprite and game platform for Brython Server (Pygame, Tkinter to fo..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#ggame.black">black</a></li>
    <li class="mono"><a href="#ggame.blackline">blackline</a></li>
    <li class="mono"><a href="#ggame.white">white</a></li>
    <li class="mono"><a href="#ggame.whiteline">whiteline</a></li>
  </ul>

    </li>


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#ggame.App">App</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggame.App.__init__">__init__</a></li>
    <li class="mono"><a href="#ggame.App.run">run</a></li>
    <li class="mono"><a href="#ggame.App.step">step</a></li>
    <li class="mono"><a href="#ggame.App.getSpritesbyClass">getSpritesbyClass</a></li>
    <li class="mono"><a href="#ggame.App.listenKeyEvent">listenKeyEvent</a></li>
    <li class="mono"><a href="#ggame.App.listenMouseEvent">listenMouseEvent</a></li>
    <li class="mono"><a href="#ggame.App.unlistenKeyEvent">unlistenKeyEvent</a></li>
    <li class="mono"><a href="#ggame.App.unlistenMouseEvent">unlistenMouseEvent</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggame.CircleAsset">CircleAsset</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggame.CircleAsset.__init__">__init__</a></li>
    <li class="mono"><a href="#ggame.CircleAsset.destroy">destroy</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggame.Color">Color</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggame.Color.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggame.EllipseAsset">EllipseAsset</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggame.EllipseAsset.__init__">__init__</a></li>
    <li class="mono"><a href="#ggame.EllipseAsset.destroy">destroy</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggame.Frame">Frame</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggame.Frame.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggame.ImageAsset">ImageAsset</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggame.ImageAsset.__init__">__init__</a></li>
    <li class="mono"><a href="#ggame.ImageAsset.append">append</a></li>
    <li class="mono"><a href="#ggame.ImageAsset.destroy">destroy</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggame.KeyEvent">KeyEvent</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggame.KeyEvent.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggame.LineAsset">LineAsset</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggame.LineAsset.__init__">__init__</a></li>
    <li class="mono"><a href="#ggame.LineAsset.destroy">destroy</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggame.LineStyle">LineStyle</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggame.LineStyle.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggame.MouseEvent">MouseEvent</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggame.MouseEvent.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggame.PolygonAsset">PolygonAsset</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggame.PolygonAsset.__init__">__init__</a></li>
    <li class="mono"><a href="#ggame.PolygonAsset.destroy">destroy</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggame.RectangleAsset">RectangleAsset</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggame.RectangleAsset.__init__">__init__</a></li>
    <li class="mono"><a href="#ggame.RectangleAsset.destroy">destroy</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggame.Sound">Sound</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggame.Sound.__init__">__init__</a></li>
    <li class="mono"><a href="#ggame.Sound.loop">loop</a></li>
    <li class="mono"><a href="#ggame.Sound.play">play</a></li>
    <li class="mono"><a href="#ggame.Sound.stop">stop</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggame.SoundAsset">SoundAsset</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggame.SoundAsset.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggame.Sprite">Sprite</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggame.Sprite.__init__">__init__</a></li>
    <li class="mono"><a href="#ggame.Sprite.circularCollisionModel">circularCollisionModel</a></li>
    <li class="mono"><a href="#ggame.Sprite.collidingPolyWithPoly">collidingPolyWithPoly</a></li>
    <li class="mono"><a href="#ggame.Sprite.collidingWith">collidingWith</a></li>
    <li class="mono"><a href="#ggame.Sprite.collidingWithSprites">collidingWithSprites</a></li>
    <li class="mono"><a href="#ggame.Sprite.destroy">destroy</a></li>
    <li class="mono"><a href="#ggame.Sprite.firstImage">firstImage</a></li>
    <li class="mono"><a href="#ggame.Sprite.lastImage">lastImage</a></li>
    <li class="mono"><a href="#ggame.Sprite.nextImage">nextImage</a></li>
    <li class="mono"><a href="#ggame.Sprite.prevImage">prevImage</a></li>
    <li class="mono"><a href="#ggame.Sprite.rectangularCollisionModel">rectangularCollisionModel</a></li>
    <li class="mono"><a href="#ggame.Sprite.setImage">setImage</a></li>
    <li class="mono"><a href="#ggame.Sprite.collidingCircleWithPoly">collidingCircleWithPoly</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ggame.TextAsset">TextAsset</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ggame.TextAsset.__init__">__init__</a></li>
    <li class="mono"><a href="#ggame.TextAsset.destroy">destroy</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">ggame</span> module</h1>
  <h1>ggame</h1>
<p>The simple cross-platform sprite and game platform for Brython Server (Pygame, Tkinter to follow?).</p>
<p>Ggame stands for a couple of things: "good game" (of course!) and also "git game" or "github game" 
because it is designed to operate with <a href="http://runpython.com">Brython Server</a> in concert with
Github as a backend file store.</p>
<p>Ggame is <strong>not</strong> intended to be a full-featured gaming API, with every bell and whistle. Ggame is
designed primarily as a tool for teaching computer programming, recognizing that the ability
to create engaging and interactive games is a powerful motivator for many progamming students.
Accordingly, any functional or performance enhancements that <em>can</em> be reasonably implemented 
by the user are left as an exercise. </p>
<h2>Functionality Goals</h2>
<p>The ggame library is intended to be trivially easy to use. For example:</p>
<pre><code>from ggame import App, ImageAsset, Sprite

# Create a displayed object at 100,100 using an image asset
Sprite(ImageAsset("ggame/bunny.png"), (100,100))
# Create the app, with a 500x500 pixel stage
app = App(500,500)  
# Run the app
app.run()
</code></pre>
<h2>Extensions</h2>
<p>The <code>ggame</code> library has been extended with <a href="/ggame/ggmath.html">ggmath</a> for geometry
exploration in a manner reminiscent of Geogebra, and <a href="/ggame/ggrocket.html">ggrocket</a>
for tools and classes to use with rocket and orbital simulations.</p>
<h2>Overview</h2>
<p>There are three major components to the <code>ggame</code> system: Assets, Sprites and the App.</p>
<h3>Assets</h3>
<p>Asset objects (i.e. <a href="#ggame.ImageAsset"><code>ImageAsset</code></a>, etc.) typically represent separate files that
are provided by the "art department". These might be background images, user interface
images, or images that represent objects in the game. In addition, <a href="#ggame.SoundAsset"><code>SoundAsset</code></a> 
is used to represent sound files (<code>.wav</code> or <code>.mp3</code> format) that can be played in the 
game.</p>
<p>Ggame also extends the asset concept to include graphics that are generated dynamically
at run-time, such as geometrical objects, e.g. rectangles, lines, etc.</p>
<h3>Sprites</h3>
<p>All of the visual aspects of the game are represented by instances of <a href="#ggame.Sprite"><code>Sprite</code></a> or
subclasses of it. </p>
<h3>App</h3>
<p>Every ggame application must create a single instance of the <a href="#ggame.App"><code>App</code></a> class (or 
a sub-class of it). Creating an instance of the <a href="#ggame.App"><code>App</code></a> class will initiate 
creation of a pop-up window on your browser. Executing the app's <code>run</code> method will
begin the process of refreshing the visual assets on the screen. </p>
<h3>Events</h3>
<p>No game is complete without a player and players produce events. Your code handles user
input by registering to receive keyboard and mouse events using <a href="#ggame.App.listenKeyEvent"><code>listenKeyEvent</code></a> and
<a href="#ggame.App.listenMouseEvent"><code>listenMouseEvent</code></a> methods.</p>
<h2>Execution Environment</h2>
<p>Ggame is designed to be executed in a web browser using <a href="http://brython.info/">Brython</a>,
<a href="http://www.pixijs.com/">Pixi.js</a> and <a href="http://buzz.jaysalvat.com/">Buzz</a>. The easiest
way to do this is by executing from <a href="http://runpython.com">runpython</a>, with source
code residing on <a href="http://github.com">github</a>.</p>
<p>To use Ggame in your own application, you may create a folder called
<code>ggame</code> in your project. Within <code>ggame</code>, copy the <code>ggame.py</code>, <code>sysdeps.py</code> and 
<code>__init__.py</code> files from the <a href="https://github.com/BrythonServer/ggame">ggame project</a>.</p>
<p>When using <code>ggame</code> from within <a href="http://runpython.com">runpython</a>, the Github
<code>ggame</code> repository is automatically placed on the import search path.</p>
<h2>Geometry</h2>
<p>When referring to screen coordinates, note that the x-axis of the computer screen
is <em>horizontal</em> with the zero position on the left hand side of the screen. The 
y-axis is <em>vertical</em> with the zero position at the <strong>top</strong> of the screen.</p>
<p>Increasing positive y-coordinates correspond to the downward direction on the 
computer screen. Note that this is <strong>different</strong> from the way you may have learned
about x and y coordinates in math class!</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame', this);">Show source &equiv;</a></p>
  <div id="source-ggame" class="source">
    <pre><code>"""
# ggame
The simple cross-platform sprite and game platform for Brython Server (Pygame, Tkinter to follow?).

Ggame stands for a couple of things: "good game" (of course!) and also "git game" or "github game" 
because it is designed to operate with [Brython Server](http://runpython.com) in concert with
Github as a backend file store.

Ggame is **not** intended to be a full-featured gaming API, with every bell and whistle. Ggame is
designed primarily as a tool for teaching computer programming, recognizing that the ability
to create engaging and interactive games is a powerful motivator for many progamming students.
Accordingly, any functional or performance enhancements that *can* be reasonably implemented 
by the user are left as an exercise. 

## Functionality Goals

The ggame library is intended to be trivially easy to use. For example:

    from ggame import App, ImageAsset, Sprite
  
    # Create a displayed object at 100,100 using an image asset
    Sprite(ImageAsset("ggame/bunny.png"), (100,100))
    # Create the app, with a 500x500 pixel stage
    app = App(500,500)  
    # Run the app
    app.run()
    
## Extensions

The `ggame` library has been extended with [ggmath](/ggame/ggmath.html) for geometry
exploration in a manner reminiscent of Geogebra, and [ggrocket](/ggame/ggrocket.html)
for tools and classes to use with rocket and orbital simulations.

## Overview

There are three major components to the `ggame` system: Assets, Sprites and the App.

### Assets

Asset objects (i.e. `ggame.ImageAsset`, etc.) typically represent separate files that
are provided by the "art department". These might be background images, user interface
images, or images that represent objects in the game. In addition, `ggame.SoundAsset` 
is used to represent sound files (`.wav` or `.mp3` format) that can be played in the 
game.

Ggame also extends the asset concept to include graphics that are generated dynamically
at run-time, such as geometrical objects, e.g. rectangles, lines, etc.

### Sprites

All of the visual aspects of the game are represented by instances of `ggame.Sprite` or
subclasses of it. 

### App

Every ggame application must create a single instance of the `ggame.App` class (or 
a sub-class of it). Creating an instance of the `ggame.App` class will initiate 
creation of a pop-up window on your browser. Executing the app's `run` method will
begin the process of refreshing the visual assets on the screen. 

### Events

No game is complete without a player and players produce events. Your code handles user
input by registering to receive keyboard and mouse events using `ggame.App.listenKeyEvent` and
`ggame.App.listenMouseEvent` methods.

## Execution Environment

Ggame is designed to be executed in a web browser using [Brython](http://brython.info/),
[Pixi.js](http://www.pixijs.com/) and [Buzz](http://buzz.jaysalvat.com/). The easiest
way to do this is by executing from [runpython](http://runpython.com), with source
code residing on [github](http://github.com).

To use Ggame in your own application, you may create a folder called
`ggame` in your project. Within `ggame`, copy the `ggame.py`, `sysdeps.py` and 
`__init__.py` files from the [ggame project](https://github.com/BrythonServer/ggame).

When using `ggame` from within [runpython](http://runpython.com), the Github
`ggame` repository is automatically placed on the import search path.

## Geometry

When referring to screen coordinates, note that the x-axis of the computer screen
is *horizontal* with the zero position on the left hand side of the screen. The 
y-axis is *vertical* with the zero position at the **top** of the screen.

Increasing positive y-coordinates correspond to the downward direction on the 
computer screen. Note that this is **different** from the way you may have learned
about x and y coordinates in math class!

"""

import math

try:
    from ggame.sysdeps import *
except:
    from sysdeps import *

class Frame(object):
    """
    Frame is a utility class for expressing the idea of a rectangular region.
    """
    
    def __init__(self, x, y, w, h):
        """
        Initialization for the `ggame.Frame` objects.

        `x` and `y` are coordinates of the upper left hand corner of the frame.
 
        `w` and `h` are the width and height of the frame rectangle.
        """

        self.GFX = GFX_Rectangle(x,y,w,h)
        """
        `GFX` is a reference to the underlying object provided by the system.
        """
        self.x = x
        """
        X-coordinate of the upper left hand corner of this `ggame.Frame`.
        """
        self.y = y
        """
        Y-coordinate of the upper left hand corner of this `ggame.Frame`.
        """
        self.w = w
        """
        Width of the `ggame.Frame`.
        """
        self.h = h
        """
        Height of the `ggame.Frame`.
        """
    
    @property
    def x(self):
        return self.GFX.x
    
    @x.setter
    def x(self, value):
        self.GFX.x = value
        
    @property
    def y(self):
        return self.GFX.y
    
    @y.setter
    def y(self, value):
        self.GFX.y = value
    
    @property
    def w(self):
        return self.GFX.width
    
    @w.setter
    def w(self, value):
        self.GFX.width = value
        
    @property
    def h(self):
        return self.GFX.height
        
    @h.setter
    def h(self, value):
        self.GFX.height = value
    
    @property
    def center(self):
        """
        `center` property computes a coordinate pair (tuple) for the 
        center of the frame.

        The `center` property, when set, redefines the `x` and `y` properties
        of the frame in order to make the center agree with the coordinates
        (tuple) assigned to it.
        """

        return (self.x + self.w//2, self.y + self.h//2)
    
    @center.setter
    def center(self, value):
        c = self.center
        self.x += value[0] - c[0]
        self.y += value[1] - c[1]

class _Asset(object):
    """
    Base class for all game asset objects.
    
    The `ggame.Asset` class is set up to understand the concept
    of multiple instances of an asset. This is currently only used for image-based
    assets.
    """

    def __init__(self):
        self.GFXlist = [None,]
        """A list of the underlying system objects used to represent this asset."""

    @property
    def GFX(self):
        """
        `GFX` property represents the underlying system object used to represent
        this asset. If this asset is composed of multiple assets, then the **first**
        asset is referenced by `GFX`.
        """
        return self.GFXlist[0]
        
    @GFX.setter
    def GFX(self, value):
        self.GFXlist[0] = value
        
    def __len__(self):
        return len(self.GFXlist)
        
    def __getitem__(self, key):
        return self.GFXlist[key]
        
    def __setitem__(self, key, value):
        self.GFXlist[key] = value
        
    def __iter__(self):
        class Iter():
            def __init__(self, image):
                self.obj = image
                self.n = len(image.GFXlist)
                self.i = 0
                
            def __iter__(self):
                return self
                
            def __next__(self):
                if self.i ==self.n:
                    raise StopIteration
                self.i += 1
                return self.obj.GFXlist[self.i]
        return Iter(self)

    def destroy(self):
        if hasattr(self, 'GFX'):
            try:
                for gfx in self.GFXlist:
                    try:
                        gfx.destroy(True)
                    except:
                        pass
            except:
                pass
        
        
class ImageAsset(_Asset):
    """
    The `ImageAsset` class connects ggame to a specific image **file**.
    """

    def __init__(self, url, frame=None, qty=1, direction='horizontal', margin=0):
        """
        All `ggame.ImageAsset` instances must specify a file name or url with
        the `url` parameter.

        If the desired sprite image exists in only a smaller sub-section of the 
        original image, then the are can be specified by providing the
        `frame` parameter, which must be a valid `ggame.Frame` object.

        If image file actually is a *collection* of images, such as a so-called
        *sprite sheet*, then the `ImageAsset` class supports defining a list
        of images, provided they exist in the original image as a **row**
        of evenly spaced images or a **column** of images. To specify this,
        provide the `qty` (quantity) of images in the row or column, the
        `direction` of the list ('horizontal' or 'vertical' are supported),
        and an optional `margin`, if there is a gap between successive 
        images. When used in this way, the `frame` parameter must define the
        area of the **first** image in the collection; all subsequent images
        in the list are assumed to be the same size.
        """
        super().__init__()
        self.url = url
        """
        A string that represents the path or url of the original file.
        """
        del self.GFXlist[0]
        self.width = self.height = 0
        self.append(url, frame, qty, direction, margin)

    def _subframe(self, texture, frame):
        return GFX_Texture(texture, frame.GFX)
        
    def append(self, url, frame=None, qty=1, direction='horizontal', margin=0):
        """
        Append a texture asset from a new image file (or url). This method
        allows you to build a collection of images into an asset (such as you
        might need for an animated sprite), but without using a single 
        sprite sheet image.

        The parameters for the `append` method are identical to those 
        supplied to the `ggame.ImageAsset` initialization method. 

        This method allows you to build up an asset that consists of 
        multiple rows or columns of images in a sprite sheet or sheets.
        """
        GFX = GFX_Texture_fromImage(url, False)
        dx = 0
        dy = 0
        for i in range(qty):
            if not frame is None:
                self.width = frame.w
                self.height = frame.h
                if direction == 'horizontal':
                    dx = frame.w + margin
                elif direction == 'vertical':
                    dy = frame.h + margin
                f = Frame(frame.x + dx * i, frame.y + dy * i, frame.w, frame.h)
                GFX = self._subframe(GFX, f)
            else:
                self.width = GFX.width
                self.height = GFX.height
            self.GFXlist.append(GFX)


class Color(object):
    """
    The `ggame.Color` class is used to represent colors and/or colors with
    transparency.
    """

    def __init__(self, color, alpha):
        """
        A `ggame.Color` instance must specify both a `color` as an integer
        in the conventional format (usually as a hexadecimal literal, e.g.
        0xffbb33 that represents the three color components, red, green 
        and blue), and a transparency value, or `alpha` as a floating
        point number in the range of 0.0 to 1.0 where 0.0 represents 
        completely transparent and 1.0 represents completely solid.

        Example: `red = Color(0xff0000, 1.0)`

        """
        self.color = color
        self.alpha = alpha
        
    def __eq__(self, other):
        return type(self) is type(other) and self.color == other.color and self.alpha == other.alpha
        
black = Color(0, 1.0)
"""
Default black color
"""
white = Color(0xffffff, 1.0)
"""
Default white color
"""

class LineStyle(object):
    """
    The `ggame.LineStyle` class is used to represent line style when
    drawing geometrical objects such as rectangles, ellipses, etc.
    """
    
    def __init__(self, width, color):
        """
        When creating a `ggame.LineStyle` instances you must specify 
        the `width` of the line in pixels and the `color` as a valid
        `ggame.Color` instance.

        Example: `line = LineStyle(3, Color(0x00ff00, 1.0))` will define
        a 3 pixel wide green line.
        """
        self.width = width
        self.color = color

    def __eq__(self, other):
        return type(self) is type(other) and self.width == other.width and self.color == other.color

blackline = LineStyle(1, black)
"""
Default thin black line
"""
whiteline = LineStyle(1, white)
"""
Default thin white line
"""

class _GraphicsAsset(_Asset):
    
    def __init__(self):
        super().__init__()
        GFX_Graphics.clear()
        

class _CurveAsset(_GraphicsAsset):

    def __init__(self, line):
        super().__init__()
        GFX_Graphics.lineStyle(line.width, line.color.color, line.color.alpha)

class _ShapeAsset(_CurveAsset):

    def __init__(self, line, fill):
        super().__init__(line)
        GFX_Graphics.beginFill(fill.color, fill.alpha)
    

class RectangleAsset(_ShapeAsset):
    """
    The `ggame.RectangleAsset` is a "virtual" asset that is created on the
    fly without requiring creation of an image file.
    """

    def __init__(self, width, height, line=blackline, fill=black):
        """
        Creation of a `ggame.RectangleAsset` requires specification of the 
        rectangle `width` and `height` in pixels, the `line` (as a proper
        `ggame.LineStyle` instance) and fill properties (as a `ggame.Color`
        instance).
        """
        super().__init__(line, fill)
        self.width = width
        self.height = height
        self.GFX = GFX_Graphics.drawRect(0, 0, self.width, self.height).clone()
        """The `GFX` property represents the underlying system object."""
        self.GFX.visible = False
        

class CircleAsset(_ShapeAsset):
    """
    The `ggame.CircleAsset` is a "virtual" asset that is created on the
    fly without requiring creation of an image file.
    """    

    def __init__(self, radius, line=blackline, fill=black):
        """
        Creation of a `ggame.CircleAsset` requires specification of the circle
        `radius` in pixels, the `line` (as a proper `ggame.LineStyle` instance)
        and fill properties (as a `ggame.Color` instance).
        """
        super().__init__(line, fill)
        self.radius = radius
        self.GFX = GFX_Graphics.drawCircle(0, 0, self.radius).clone()
        """The `GFX` property represents the underlying system object."""
        self.GFX.visible = False
        
class EllipseAsset(_ShapeAsset):
    """
    The `ggame.EllipseAsset` is a "virtual" asset that is created on the 
    fly without requiring creation of an image file.
    """

    def __init__(self, halfw, halfh, line=blackline, fill=black):
        """
        Creation of a `ggame.EllipseAsset` requires specification of the ellipse
        `halfw`, or semi-axis length in the horizontal direction (half of the
        ellipse width) and the `halfh`, or semi-axis length in the vertical direction.
        `line` (as `ggame.LineStyle` instance) and `fill` (as `ggame.Color` instance)
        must also be provided.
        """
        super().__init__(line, fill)
        self.halfw = halfw
        self.halfh = halfh
        self.GFX = GFX_Graphics.drawEllipse(0, 0, self.halfw, self.halfh).clone()
        """The `GFX` property represents the underlying system object."""
        self.GFX.visible = False
        
class PolygonAsset(_ShapeAsset):
    """
    The `ggame.PolygonAsset` is a "virtual" asset that is created on the
    fly without requiring creation of an image file.
    """

    def __init__(self, path, line=blackline, fill=black):
        """
        Creation of a `ggame.PolygonAsset` requires specification of a 
        `path` consisting of a list of coordinate tuples. `line` and 
        `fill` arguments (instances of `ggame.LineStyle` and `ggame.Color`,
        respectively) must also be supplied. The final coordinate in the 
        list must be the same as the first.

        Example: `poly = PolygonAsset([(0,0), (50,50), (50,100), (0,0)], linesty, fcolor)`
        """
        super().__init__(line, fill)
        self.path = path
        jpath = []
        for point in self.path:
            jpath.extend(point)
        self.GFX = GFX_Graphics.drawPolygon(jpath).clone()
        """The `GFX` property represents the underlying system object."""
        self.GFX.visible = False
    

class LineAsset(_CurveAsset):
    """
    The `ggame.LineAsset` is a "virtual" asset that is created on the
    fly without requiring creation of an image file. A `LineAsset` instance
    represents a single line segment.
    """

    def __init__(self, x, y, line=blackline):
        """
        Creation of a `ggame.LineAsset` requires specification of an `x` and
        `y` coordinate for the endpoint of the line. The starting point of the
        line is implied as coordinates (0,0). Note that when this asset is 
        used in a `ggame.Sprite` class, the sprite's `x` and `y` coordinates
        will control the location of the line segment on the screen.

        As the `ggame.LineAsset` does not cover a region, only a `ggame.LineStyle` 
        argument must be supplied (`line`).
        """
        super().__init__(line)
        self.deltaX = x
        """This attribute represents the `x` parameter supplied during instantiation."""
        self.deltaY = y
        """This attribute represents the `y` parameter supplied during instantiation."""
        GFX_Graphics.moveTo(0, 0)
        self.GFX = GFX_Graphics.lineTo(self.deltaX, self.deltaY).clone()
        """The `GFX` property represents the underlying system object."""
        self.GFX.visible = False

class TextAsset(_GraphicsAsset):
    """
    The `ggame.TextAsset` is a "virtual" asset that is created on the fly
    without requiring creation of an image file. A `TextAsset` instance
    represents a block of text, together with its styling (font, color, etc.).
    """
 
    def __init__(self, text, **kwargs):
        """
        The `ggame.TextAsset` must be created with a string as the `text` parameter.
        
        The remaining optional arguments must be supplied as keyword parameters. These
        parameters are described under the class attributes, below:
        """
        super().__init__()
        self.text = text
        self.style = kwargs.get('style', '20px Arial')
        """A string that specifies style, size and typeface (e.g. `'italic 20pt Helvetica'` or `'20px Arial'`)"""
        width = kwargs.get('width', 100)
        """Width of the text block on the screen, in pixels."""
        self.fill = kwargs.get('fill', Color(0, 1))
        """A valid `ggame.Color` instance that specifies the color and transparency of the text."""
        self.align = kwargs.get('align', 'left')
        """The alignment style of the text. One of: `'left'`, `'center'`, or `'right'`."""
        self.GFX = GFX_Text(self.text, 
            {'font': self.style,
                'fill' : self.fill.color,
                'align' : self.align,
                'wordWrap' : True,
                'wordWrapWidth' : width,
                })
        """The `GFX` property represents the underlying system object."""
        self.GFX.alpha = self.fill.alpha
        self.GFX.visible = False
        
    def _clone(self):
        return type(self)(self.text,
            style = self.style,
            width = self.width,
            fill = self.fill,
            align = self.align)
    
    @property
    def width(self):
        return self.GFX.width
        
    @property
    def height(self):
        return self.GFX.height


class Sprite(object):
    """
    The `ggame.Sprite` class combines the idea of a visual/graphical asset, a
    position on the screen, and *behavior*. Although the `ggame.Sprite` can be
    used as-is, it is generally subclassed to give it the desired behavior.

    When subclassing the `ggame.Sprite` class, you may customize the initialization
    code to use a specific asset. A 'step' or 'poll' method may be added
    for handling per-frame actions (e.g. checking for collisions). Step or poll
    functions are not automatically called by the `ggame.App` class, but you
    may subclass the `ggame.App` class in order to do this.

    Furthermore, you may wish to define event callback methods in your customized
    sprite class. With customized creation, event handling, and periodic processing
    you can achieve fully autonomous behavior for your class. 
    """
 
    _rectCollision = "rect"
    _circCollision = "circ"
    
    def __init__(self, asset, pos=(0,0), edgedef=None):
        """
        The `ggame.Sprite` must be created with an existing graphical `asset`.
        
        An optional `pos` or position may be provided, which specifies the 
        starting (x,y) coordinates of the sprite on the screen. By default,
        the position of a sprite defines the location of its upper-left hand
        corner. This behavior can be modified by customizing the `center` of
        the sprite.
        
        An optional `edgedef` or edge definition may be provided, which
        specifies an asset that will be used to define the boundaries of
        the sprite for the purpose of collision detection. If no `edgedef` 
        asset is given, the Sprite asset is used, which will be a rectangular
        asset in the case of an image texture. This option is typically used
        to define a visible image outline for a texture-based sprite that has
        a transparent texture image background.
        
        Example: player = Sprite(ImageAsset("player.png", (100,100), CircleAsset(50))
        
        This creates a sprite using the `player.png` image, positioned with its
        upper left corner at coordinates (100,100) and with a 50 pixel radius 
        circular collision border. 
        """
        self._index = 0
        if type(asset) == ImageAsset:
            self.asset = asset
            try:
                #self.GFX = GFX_Sprite()
                self.GFX = GFX_Sprite(asset.GFX) # GFX is PIXI Sprite
            except:
                self.GFX = None
        elif type(asset) in [RectangleAsset, 
            CircleAsset, 
            EllipseAsset, 
            PolygonAsset,
            LineAsset,
            ]:
            self.asset = asset
            self.GFX = GFX_Sprite(asset.GFX.generateTexture())
            #self.GFX = asset.GFX.clone() # GFX is PIXI Graphics (from Sprite)
            #self.GFX.visible = True
        elif type(asset) in [TextAsset]:
            self.asset = asset._clone()
            self.GFX = self.asset.GFX # GFX is PIXI Text (from Sprite)
            self.GFX.visible = True
        if not edgedef:
            self.edgedef = asset
        else:
            self.edgedef = edgedef
        self.xmin = self.xmax = self.ymin = self.ymax = 0
        self.position = pos
        """Tuple indicates the position of the sprite on the screen."""
        self._extentsdirty = True
        """Boolean indicates if extents must be calculated before collision test"""
        self._createBaseVertices()
        self._setExtents()
        """Initialize the extents (xmax, xmin, etc.) for collision detection"""
        App._add(self)
        
    def _createBaseVertices(self):
        """
        Create sprite-relative list of vertex coordinates for boundary
        """
        self._basevertices = []
        assettype = type(self.edgedef)
        if assettype in [RectangleAsset, ImageAsset, TextAsset]:
            self._basevertices = [(0,0), 
                (0,self.edgedef.height), 
                (self.edgedef.width,self.edgedef.height),
                (self.edgedef.width,0)]
        elif assettype is PolygonAsset:
            self._basevertices = self.edgedef.path[:-1]
        elif assettype is LineAsset:
            self._basevertices = [(0,0), 
                (self.edgedef.deltaX, self.edgedef.deltaY)]
        elif assettype is EllipseAsset:
            w = self.edgedef.halfw * 2
            h = self.edgedef.halfh * 2
            self._basevertices = [(0,0), (0,h), (w,h), (w,0)]

    def _xformVertices(self):
        """
        Create window-relative list of vertex coordinates for boundary
        """
        # find center as sprite-relative points (note sprite may be scaled)
        x = self.width * self.fxcenter / self.scale
        y = self.height * self.fycenter / self.scale
        if self.scale != 1.0:
            sc = self.scale
            # center-relative, scaled coordinates
            crsc = [((xp-x)*sc,(yp-y)*sc) for xp,yp in self._basevertices]
        else:
            crsc = [(xp-x,yp-y) for xp,yp in self._basevertices]
            
        # absolute, rotated coordinates
        c = math.cos(self.rotation)
        s = math.sin(self.rotation)
        self._absolutevertices = [(self.x + x*c + y*s, self.y + -x*s + y*c) 
                                    for x,y in crsc]


    def _setExtents(self):
        """
        update min/max x and y based on position, center, width, height
        """
        if self._extentsdirty:
            if type(self.asset) is CircleAsset:
                th = math.atan2(
                    self.fycenter - 0.5, 0.5 - self.fxcenter) + self.rotation
                D = self.width
                L = math.sqrt(math.pow(self.fxcenter - 0.5, 2) + 
                    math.pow(self.fycenter - 0.5, 2)) * D
                self.xmin = self.x + int(L*math.cos(th)) - D//2
                self.ymin = self.y - int(L*math.sin(th)) - D//2
                self.xmax = self.xmin + D
                self.ymax = self.ymin + D
            else:
                # Build vertex list
                self._xformVertices()
                x, y = zip(*self._absolutevertices)
                self.xmin = min(x)
                self.xmax = max(x)
                self.ymin = min(y)
                self.ymax = max(y)
            self._extentsdirty = False

    def firstImage(self):
        """
        Select and display the *first* image used by this sprite.
        """
        self.GFX.texture = self.asset[0]
    
    def lastImage(self):
        """
        Select and display the *last* image used by this sprite.
        """
        self.GFX.texture = self.asset[-1]
    
    def nextImage(self, wrap = False):
        """
        Select and display the *next* image used by this sprite.
        If the current image is already the *last* image, then
        the image is not advanced.

        If the optional `wrap` parameter is set to `True`, then calling
        `ggame.Sprite.nextImage` on the last image will cause the *first*
        image to be loaded.
        """
        self._index += 1
        if self._index >= len(self.asset):
            if wrap:
                self._index = 0
            else:
                self._index = len(self.asset)-1
        self.GFX.texture = self.asset[self._index]
    
    def prevImage(self, wrap = False):
        """
        Select and display the *previous* image used by this sprite.
        If the current image is already the *first* image, then
        the image is not changed.

        If the optional `wrap` parameter is set to `True`, then calling
        `ggame.Sprite.prevImage` on the first image will cause the *last*
        image to be loaded.
        """
        self._index -= 1
        if self._index < 0:
            if wrap:
                self._index = len(self.asset)-1
            else:
                self._index = 0
        self.GFX.texture = self.asset[self._index]
    
    def setImage(self, index=0):
        """
        Select the image to display by giving its `index`, where an index
        of zero represents the *first* image in the asset.

        This is equivalent to setting the `ggame.Sprite.index` property
        directly.
        """
        self.index = index

    def rectangularCollisionModel(self):
        """
        Obsolete. No op.
        """
        pass
    
    def circularCollisionModel(self):
        """
        Obsolete. No op.
        """
        pass
    
    

    @property
    def index(self):
        """This is an integer index in to the list of images available for this sprite."""
        return self._index
        
    @index.setter
    def index(self, value):
        self._index = value
        try:
            self.GFX.texture = self.asset[self._index]
        except:
            self._index = 0
            self.GFX.texture = self.asset[self._index]

    @property
    def width(self):
        """
        This is an integer representing the display width of the sprite.
        Assigning a value to the width will scale the image horizontally.
        """
        return self.GFX.width
        
    @width.setter
    def width(self, value):
        self.GFX.width = value
        self._extentsdirty = True
    
    @property
    def height(self):
        """
        This is an integer representing the display height of the sprite.
        Assigning a value to the height will scale the image vertically.
        """
        return self.GFX.height
    
    @height.setter
    def height(self, value):
        self.GFX.height = value
        self._extentsdirty = True
        
    @property
    def x(self):
        """
        This represents the x-coordinate of the sprite on the screen. Assigning
        a value to this attribute will move the sprite horizontally.
        """
        return self.GFX.position.x
        
    @x.setter
    def x(self, value):
        deltax = value - self.GFX.position.x
        self.xmax += deltax
        self.xmin += deltax
        """Adjust extents directly with low overhead"""
        self.GFX.position.x = value

    @property
    def y(self):
        """
        This represents the y-coordinate of the sprite on the screen. Assigning
        a value to this attribute will move the sprite vertically.
        """
        return self.GFX.position.y
        
    @y.setter
    def y(self, value):
        deltay = value - self.GFX.position.y
        self.ymax += deltay
        self.ymin += deltay
        """Adjust extents directly with low overhead"""
        self.GFX.position.y = value

    @property
    def position(self):
        """
        This represents the (x,y) coordinates of the sprite on the screen. Assigning
        a value to this attribute will move the sprite to the new coordinates.
        """
        return (self.GFX.position.x, self.GFX.position.y)
        
    @position.setter
    def position(self, value):
        self.x, self.y = value

    @property
    def fxcenter(self):
        """
        This represents the horizontal position of the sprite "center", as a floating
        point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
        of the sprite refers to its left hand edge. A value of 1.0 refers to its 
        right hand edge. Any value in between may be specified. Values may be assigned
        to this attribute. 
        """
        try:
            return self.GFX.anchor.x
            self._extentsdirty = True
        except:
            return 0.0
        
    @fxcenter.setter
    def fxcenter(self, value):
        """
        Float: 0-1
        """
        try:
            self.GFX.anchor.x = value
            self._extentsdirty = True
        except:
            pass
        
    @property
    def fycenter(self):
        """
        This represents the vertical position of the sprite "center", as a floating
        point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
        of the sprite refers to its top edge. A value of 1.0 refers to its 
        bottom edge. Any value in between may be specified. Values may be assigned
        to this attribute. 
        """
        try:
            return self.GFX.anchor.y
        except:
            return 0.0
        
    @fycenter.setter
    def fycenter(self, value):
        """
        Float: 0-1
        """
        try:
            self.GFX.anchor.y = value
            self._extentsdirty = True
        except:
            pass
    
    @property
    def center(self):
        """
        This attribute represents the horizontal and vertical position of the 
        sprite "center" as a tuple of floating point numbers. See the 
        descriptions for `ggame.Sprite.fxcenter` and `ggame.Sprite.fycenter` for 
        more details.
        """
        try:
            return (self.GFX.anchor.x, self.GFX.anchor.y)
        except:
            return (0.0, 0.0)
        
    @center.setter
    def center(self, value):
        try:
            self.GFX.anchor.x = value[0]
            self.GFX.anchor.y = value[1]
            self._extentsdirty = True
        except:
            pass
    
    @property
    def visible(self):
        """
        This boolean attribute may be used to change the visibility of the sprite. Setting
        `ggame.Sprite.visible` to `False` will prevent the sprite from rendering on the 
        screen.
        """
        return self.GFX.visible
    
    @visible.setter
    def visible(self, value):
        self.GFX.visible = value

    @property
    def scale(self):
        """
        This attribute may be used to change the size of the sprite ('scale' it) on the 
        screen. Value may be a floating point number. A value of 1.0 means that the sprite
        image will keep its original size. A value of 2.0 would double it, etc.
        """
        try:
            return self.GFX.scale.x
        except AttributeError:
            return 1.0
        
    @scale.setter
    def scale(self, value):
        self.GFX.scale.x = value
        self.GFX.scale.y = value
        self._extentsdirty = True

    @property
    def rotation(self):
        """
        This attribute may be used to change the rotation of the sprite on the screen.
        Value may be a floating point number. A value of 0.0 means no rotation. A value 
        of 1.0 means  a rotation of 1 radian in a counter-clockwise direction. One radian
        is 180/pi or approximately 57.3 degrees.
        """
        try:
            return -self.GFX.rotation
        except AttributeError:
            return 0.0
        
    @rotation.setter
    def rotation(self, value):
        self.GFX.rotation = -value
        if value:
            self._extentsdirty = True

    @classmethod
    def collidingCircleWithPoly(cls, circ, poly):
        return True
    
    def collidingPolyWithPoly(self, obj):
        return True

    def collidingWith(self, obj):
        """
        Return a boolean True if this sprite is currently overlapping the sprite 
        referenced by `obj`. Returns False if checking for collision with 
        itself. Returns False if extents of object make it impossible for
        collision to occur. Returns True if sprite's `edgedef` parameter overlaps
        with other sprite's `edgedef` parameter, taking into consideration both
        sprites' center, rotation and scale settings.
        """
        if self is obj:
            return False
        else:
            self._setExtents()
            obj._setExtents()
            # Gross check for overlap will usually rule out a collision
            if (self.xmin > obj.xmax
                or self.xmax < obj.xmin
                or self.ymin > obj.ymax
                or self.ymax < obj.ymin):
                return False
            # Otherwise, perform a careful overlap determination
            elif type(self.asset) is CircleAsset:
                if type(obj.asset) is CircleAsset:
                    # two circles .. check distance between
                    sx = (self.xmin + self.xmax) / 2
                    sy = (self.ymin + self.ymax) / 2
                    ox = (obj.xmin + obj.xmax) / 2
                    oy = (obj.ymin + obj.ymax) / 2
                    d = math.sqrt((sx-ox)**2 + (sy-oy)**2)
                    return d <= self.width/2 + obj.width/2
                else:
                    return self.collidingCircleWithPoly(self, obj)
            else:
                if type(obj.asset) is CircleAsset:
                    return self.collidingCircleWithPoly(obj, self)
                else:
                    return self.collidingPolyWithPoly(obj)
                
                

    def collidingWithSprites(self, sclass = None):
        """
        Return a list of sprite objects identified by the `sclass` parameter
        that are currently colliding with (that is, with which the `ggame.Sprite.collidingWith`
        method returns True) this sprite. If `sclass` is set to `None` (default), then
        all other sprites are checked for collision, otherwise, only sprites whose
        class matches `sclass` are checked.
        """
        if sclass is None:
            slist = App.spritelist
        else:
            slist = App.getSpritesbyClass(sclass)
        return list(filter(self.collidingWith, slist))

    def destroy(self):
        """
        Call the `ggame.Sprite.destroy` method to prevent the sprite from being displayed,
        or checked in collision detection. If you only want to prevent a sprite from being
        displayed, set the `ggame.Sprite.visible` attribute to `False`.
        """
        App._remove(self)
        self.GFX.destroy()


class SoundAsset(object):
    """
    Class representing a single sound asset (sound file, such as .mp3 or .wav).
    """    
    def __init__(self, url):
        """
        Create a `ggame.SoundAsset` instance by passing in the URL or file name
        of the desired sound. Sound file formats may include `.wav` or `.mp3`, subject
        to browser compatibility. 
        """
        self.url = url
        """
        A string containing the url or name of the asset file.
        """

        
class Sound(object):
    """
    The `ggame.Sound` class represents a sound, with methods for controlling
    when and how the sound is played in the application.
    """

    def __init__(self, asset):
        """
        Pass a valid `ggame.SoundAsset` instance when creating a `ggame.Sound` object.
        """
        self.asset = asset
        """
        A reference to the `ggame.SoundAsset` instance.
        """
        self.SND = SND_Sound(self.asset.url)
        """
        A reference to the underlying sound object provided by the system.
        """
        self.SND.load()
        
    def play(self):
        """
        Play the sound once.
        """
        self.stop()
        self.SND.play()

    def loop(self):
        """
        Play the sound continuously, looping forever.
        """
        self.stop()
        self.SND.loop()
        self.SND.play()
        
    def stop(self):
        """
        Stop playing the sound.
        """
        self.SND.stop()
        
    @property
    def volume(self):
        """
        The `ggame.Sound.volume` property is a number ranging from 0-100, that 
        represents the volume or intensity of the sound when it is playing.
        """
        return self.SND.getVolume()
        
    @volume.setter
    def volume(self, value):
        self.SND.setVolume(value)
    

class _Event(object):

    def __init__(self, hwevent):
        self.hwevent = hwevent
        """The underlying system event object."""
        self.type = hwevent.type
        """String representing the type of received event."""
        self.consumed = False
        """
        Set the `consumed` member of the event to prevent the event
        from being received by any more handler methods.
        """
        
class MouseEvent(_Event):
    """
    The `ggame.MouseEvent` class encapsulates information regarding a user mouse
    action that is being reported by the system.
    """    

    mousemove = "mousemove"
    """Constant identifying a `mousemove` event."""
    mousedown = "mousedown"
    """Constant identifying a `mousedown` event."""
    mouseup = "mouseup"
    """Constant identifying a `mouseup` event."""
    click = "click"
    """Constant identifying a button `click` event."""
    dblclick = "dblclick"
    """Constant identifying a button `dblclick` event."""
    mousewheel = "wheel"
    """Constant identifying a mouse `wheel` scroll event."""
    
    def __init__(self, hwevent):
        """
        The event is initialized by the system, with a `hwevent` input parameter.
        """
        super().__init__(hwevent)
        self.wheelDelta = 0
        """Integer representing up/down motion of the scroll wheel."""
        if self.type == self.mousewheel:
            self.wheelDelta = hwevent.deltaY
        else:
            self.wheelDelta = 0
        rect = App._win._renderer.view.getBoundingClientRect()
        xscale = App._win.width/rect.width
        yscale = App._win.height/rect.height
        self.x = (hwevent.clientX - rect.left) * xscale
        """The window x-coordinate of the mouse pointer when the event occurred."""
        self.y = (hwevent.clientY - rect.top) * yscale
        """The window y-coordinate of the mouse pointer when the event occurred."""


class KeyEvent(_Event):
    """
    The `ggame.KeyEvent` class encapsulates information regarding a user keyboard
    action that is being reported by the system.
    """    

    no_location = 0
    """Constant indicating no specific location for the key event."""
    right_location = 2
    """Constant indicating the key event was on the right hand side of the keyboard."""
    left_location = 1
    """Constant indicating the key event was on the left hand side of the keyboard."""
    keydown = "keydown"
    """Constant indicating the key was pressed down."""
    keyup = "keyup"
    """Constant indicating the key was released."""
    keypress = "keypress"
    """Constant indicating the combination of keydown, followed by keyup."""
    keys = {8: 'backspace',
        9: 'tab',
        13: 'enter',
        16: 'shift',
        17: 'ctrl',
        18: 'alt',
        19: 'pause/break',
        20: 'caps lock',
        27: 'escape',
        32: 'space',
        33: 'page up',
        34: 'page down',
        35: 'end',
        36: 'home',
        37: 'left arrow',
        38: 'up arrow',
        39: 'right arrow',
        40: 'down arrow',
        45: 'insert',
        46: 'delete',
        48: '0',
        49: '1',
        50: '2',
        51: '3',
        52: '4',
        53: '5',
        54: '6',
        55: '7',
        56: '8',
        57: '9',
        65: 'a',
        66: 'b',
        67: 'c',
        68: 'd',
        69: 'e',
        70: 'f',
        71: 'g',
        72: 'h',
        73: 'i',
        74: 'j',
        75: 'k',
        76: 'l',
        77: 'm',
        78: 'n',
        79: 'o',
        80: 'p',
        81: 'q',
        82: 'r',
        83: 's',
        84: 't',
        85: 'u',
        86: 'v',
        87: 'w',
        88: 'x',
        89: 'y',
        90: 'z',
        91: 'left window key',
        92: 'right window key',
        93: 'select key',
        96: 'numpad 0',
        97: 'numpad 1',
        98: 'numpad 2',
        99: 'numpad 3',
        100: 'numpad 4',
        101: 'numpad 5',
        102: 'numpad 6',
        103: 'numpad 7',
        104: 'numpad 8',
        105: 'numpad 9',
        106: 'multiply',
        107: 'add',
        109: 'subtract',
        110: 'decimal point',
        111: 'divide',
        112: 'f1',
        113: 'f2',
        114: 'f3',
        115: 'f4',
        116: 'f5',
        117: 'f6',
        118: 'f7',
        119: 'f8',
        120: 'f9',
        121: 'f10',
        122: 'f11',
        123: 'f12',
        144: 'num lock',
        145: 'scroll lock',
        186: 'semicolon',
        187: 'equal sign',
        188: 'comma',
        189: 'dash',
        190: 'period',
        191: 'forward slash',
        192: 'grave accent',
        219: 'open bracket',
        220: 'back slash',
        221: 'close bracket',
        222: 'single quote'}    
    """Dictionary mapping key code integers to textual key description."""
    
    def __init__(self, hwevent):
        """
        The event is initialized by the system, with a `hwevent` input parameter.
        """
        super().__init__(hwevent)
        self.keynum = hwevent.keyCode
        """The `keynum` attribute identifies a keycode (number)."""
        self.key = self.keys[hwevent.keyCode]
        """The `key` attribute identifes the key in text form (e.g. 'back slash')."""



class App(object):
    """
    The `ggame.App` class is a (typically subclassed) class that encapsulates
    handling of the display system, and processing user events. The `ggame.App` 
    class also manages lists of all `ggame.Sprite` instances in the application.

    When subclassing `ggame.App` you may elect to instantiate most of your
    sprite objects in the initialization section.

    Processing that must occur on a per-frame basis may be included by overriding
    the `ggame.App.step` method. This is also an appropriate location to call
    similar 'step' methods for your various customized sprite classes.

    Once your application class has been instantiated, begin the frame drawing
    process by calling its `ggame.App.run` method.

    NOTE: Only **one** instance of an `ggame.App` class or subclass may be 
    instantiated at a time.
    """
    spritelist = []
    """List of all sprites currently active in the application."""
    _eventdict = {}
    _spritesdict = {}
    _spritesadded = False
    _win = None

    def __init__(self, *args):
        """
        The `ggame.App` class is called either by specifying the desired app window size
        in pixels, as two parameters (e.g. `myapp = App(640,480)`), or by providing
        no size parameters at all (e.g. `myapp = App()`), in which case, the full browser
        window size is used.
        """
        if App._win == None and (len(args) == 0 or len(args) == 2):
            x = y = 0
            if len(args) == 2:
                x = args[0]
                y = args[1]
            App._win = GFX_Window(x, y, type(self)._destroy)
            self.width = App._win.width
            self.height = App._win.height
            # Add existing sprites to the window
            if not App._spritesadded and len(App.spritelist) > 0:
                App._spritesadded = True
                for sprite in App.spritelist:
                    App._win.add(sprite.GFX)
            App._win.bind(KeyEvent.keydown, self._keyEvent)
            App._win.bind(KeyEvent.keyup, self._keyEvent)
            App._win.bind(KeyEvent.keypress, self._keyEvent)
            App._win.bind(MouseEvent.mousewheel, self._mouseEvent)
            App._win.bind(MouseEvent.mousemove, self._mouseEvent)
            App._win.bind(MouseEvent.mousedown, self._mouseEvent)
            App._win.bind(MouseEvent.mouseup, self._mouseEvent)
            App._win.bind(MouseEvent.click, self._mouseEvent)
            App._win.bind(MouseEvent.dblclick, self._mouseEvent)

        
    def _routeEvent(self, event, evtlist):
        for callback in reversed(evtlist):
            if not event.consumed:
                callback(event)
        
    def _keyEvent(self, hwevent):
        evtlist = App._eventdict.get(
            (hwevent.type, KeyEvent.keys.get(hwevent.keyCode,0)), [])
        evtlist.extend(App._eventdict.get((hwevent.type, '*'), []))
        if len(evtlist) > 0:
            evt = KeyEvent(hwevent)
            self._routeEvent(evt, evtlist)
        return False

    def _mouseEvent(self, hwevent):
        evtlist = App._eventdict.get(hwevent.type, [])
        if len(evtlist) > 0:
            evt = MouseEvent(hwevent)
            self._routeEvent(evt, evtlist)
        return False

    @classmethod
    def _add(cls, obj):
        if App._win != None:
            App._win.add(obj.GFX)
        App.spritelist.append(obj)
        if type(obj) not in App._spritesdict:
            App._spritesdict[type(obj)] = []
        App._spritesdict[type(obj)].append(obj)

    @classmethod
    def _remove(cls, obj):
        if App._win != None:
            App._win.remove(obj.GFX)
        App.spritelist.remove(obj)
        App._spritesdict[type(obj)].remove(obj)
        
    def _animate(self, dummy):
        if self.userfunc:
            self.userfunc()
        else:
            self.step()
        App._win.animate(self._animate)

    @classmethod
    def _destroy(cls, *args):
        """
        This will close the display window/tab, remove all references to 
        sprites and place the `App` class in a state in which a new 
        application could be instantiated.
        """ 
        if App._win:
            App._win.unbind(KeyEvent.keydown)
            App._win.unbind(KeyEvent.keyup)
            App._win.unbind(KeyEvent.keypress)
            App._win.unbind(MouseEvent.mousewheel)
            App._win.unbind(MouseEvent.mousemove)
            App._win.unbind(MouseEvent.mousedown)
            App._win.unbind(MouseEvent.mouseup)
            App._win.unbind(MouseEvent.click)
            App._win.unbind(MouseEvent.dblclick)
            App._win.destroy()
        App._win = None
        for s in list(App.spritelist):
            s.destroy()
        App.spritelist = []
        App._spritesdict = {}
        App._eventdict = {}
        App._spritesadded = False

    @classmethod
    def listenKeyEvent(cls, eventtype, key, callback):
        """
        Register to receive keyboard events. The `eventtype` parameter is a 
        string that indicates what type of key event to receive (value is one
        of: `'keydown'`, `'keyup'` or `'keypress'`). The `key` parameter is a 
        string indicating which key (e.g. `'space'`, `'left arrow'`, etc.) to 
        receive events for. The `callback` parameter is a reference to a 
        function or method that will be called with the `ggame.KeyEvent` object
        when the event occurs.

        See the source for `ggame.KeyEvent.keys` for a list of key names
        to use with the `key` paramter.
        """
        evtlist = App._eventdict.get((eventtype, key), [])
        if not callback in evtlist:
            evtlist.append(callback)
        App._eventdict[(eventtype, key)] = evtlist

    @classmethod
    def listenMouseEvent(cls, eventtype, callback):
        """
        Register to receive mouse events. The `eventtype` parameter is
        a string that indicates what type of mouse event to receive (
        value is one of: `'mousemove'`, `'mousedown'`, `'mouseup'`, `'click'`, 
        `'dblclick'` or `'mousewheel'`). The `callback` parameter is a 
        reference to a function or method that will be called with the 
        `ggame.MouseEvent` object when the event occurs.
        """
        evtlist = App._eventdict.get(eventtype, [])
        if not callback in evtlist:
            evtlist.append(callback)
        App._eventdict[eventtype] = evtlist

    @classmethod
    def unlistenKeyEvent(cls, eventtype, key, callback):
        """
        Use this method to remove a registration to receive a particular
        keyboard event. Arguments must exactly match those used when
        registering for the event.
        """
        App._eventdict[(eventtype,key)].remove(callback)

    @classmethod
    def unlistenMouseEvent(cls, eventtype, callback):
        """
        Use this method to remove a registration to receive a particular
        mouse event. Arguments must exactly match those used when
        registering for the event.
        """
        App._eventdict[eventtype].remove(callback)

    @classmethod
    def getSpritesbyClass(cls, sclass):
        """
        Returns a list of all active sprites of a given class.
        """
        return App._spritesdict.get(sclass, [])
    
    def step(self):
        """
        The `ggame.App.step` method is called once per animation frame. Override
        this method in your own subclass of `ggame.App` to perform periodic 
        calculations, such as checking for sprite collisions, or calling
        'step' functions in your own customized sprite classes.

        The base class `ggame.App.step` method is empty and is intended to be overriden.
        """
        pass
    
    def run(self, userfunc = None):
        """
        Calling the `ggame.App.run` method begins the animation process whereby the 
        `ggame.App.step` method is called once per animation frame. Set `userfunc`
        to any function which shall be called once per animation frame.
        """
        self.userfunc = userfunc
        App._win.animate(self._animate)


        
if __name__ == '__main__':
    

    def test(event):
        print("BOOM")
        x = input("Enter something")
        print(x)

    def testm(event):
        print('squeek!')

    xcenter = 0.0
    xstep = 0.01
    scale = 0.5
    red = Color(0xff0000, 1.0)
    blue = Color(0x0000ff, 1.0)
    line = LineStyle(0, red)
    poly = PolygonAsset([(0,0),(50,75),(100,60),(90,150),(45,100),(0,0)], line, red)
    circ = CircleAsset(75, line, red)
    circ2 = CircleAsset(55, line, blue)
    bun = ImageAsset('bunny.png')
    bun.center = (0.5,0.5)
    rect = RectangleAsset(30,150)
    ell = EllipseAsset(10,3)
    spr = Sprite(bun, (200,300))
    spr2 = Sprite(poly, (375, 255))
    # TRYING to get the extents to initialize!!
    spr2._extentsdirty = True
    spr2._setExtents()
    spr2.rotation = 0.000
    # /\ this does it
    h1 = Sprite(LineAsset(500,0))
    h2 = Sprite(LineAsset(500,0))
    v1 = Sprite(LineAsset(0,500))
    v2 = Sprite(LineAsset(0,500))
    hh1 = Sprite(LineAsset(500,0))
    hh2 = Sprite(LineAsset(500,0))
    vv1 = Sprite(LineAsset(0,500))
    vv2 = Sprite(LineAsset(0,500))

    def step():
        global spr
        global spr2
        global xcenter
        global xstep
        global h1
        global h2
        global v1
        global v2
        global hh1
        global hh2
        global vv1
        global vv2
        global scale
        

        scale = scale + xstep
        spr.fxcenter = xcenter
        spr.fycenter = xcenter
        xcenter = xcenter + xstep
        if xcenter >= 1.0 or xcenter <= 0.0:
            xstep = xstep * -1
        spr.rotation = spr.rotation + 10*xstep
        spr.scale = scale
        spr.x += 1
        spr._setExtents()
        h1.y = spr.ymin
        h2.y = spr.ymax
        v1.x = spr.xmin
        v2.x = spr.xmax
        spr2._setExtents()
        hh1.y = spr2.ymin
        hh2.y = spr2.ymax
        vv1.x = spr2.xmin
        vv2.x = spr2.xmax
        if spr.collidingWith(spr2):
            print("BANG")

    app = App()

    app.listenKeyEvent('keydown', 'e', test)
    app.listenMouseEvent('mousedown', testm)
    app.run(step)


</code></pre>
  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="ggame.black" class="name">var <span class="ident">black</span></p>
      
  
    <div class="desc"><p>Default black color</p></div>
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="ggame.blackline" class="name">var <span class="ident">blackline</span></p>
      
  
    <div class="desc"><p>Default thin black line</p></div>
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="ggame.white" class="name">var <span class="ident">white</span></p>
      
  
    <div class="desc"><p>Default white color</p></div>
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="ggame.whiteline" class="name">var <span class="ident">whiteline</span></p>
      
  
    <div class="desc"><p>Default thin white line</p></div>
  <div class="source_cont">
</div>

      </div>


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="ggame.App" class="name">class <span class="ident">App</span></p>
      
  
    <div class="desc"><p>The <a href="#ggame.App"><code>App</code></a> class is a (typically subclassed) class that encapsulates
handling of the display system, and processing user events. The <a href="#ggame.App"><code>App</code></a> 
class also manages lists of all <a href="#ggame.Sprite"><code>Sprite</code></a> instances in the application.</p>
<p>When subclassing <a href="#ggame.App"><code>App</code></a> you may elect to instantiate most of your
sprite objects in the initialization section.</p>
<p>Processing that must occur on a per-frame basis may be included by overriding
the <a href="#ggame.App.step"><code>step</code></a> method. This is also an appropriate location to call
similar 'step' methods for your various customized sprite classes.</p>
<p>Once your application class has been instantiated, begin the frame drawing
process by calling its <a href="#ggame.App.run"><code>run</code></a> method.</p>
<p>NOTE: Only <strong>one</strong> instance of an <a href="#ggame.App"><code>App</code></a> class or subclass may be 
instantiated at a time.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.App', this);">Show source &equiv;</a></p>
  <div id="source-ggame.App" class="source">
    <pre><code>class App(object):
    """
    The `ggame.App` class is a (typically subclassed) class that encapsulates
    handling of the display system, and processing user events. The `ggame.App` 
    class also manages lists of all `ggame.Sprite` instances in the application.

    When subclassing `ggame.App` you may elect to instantiate most of your
    sprite objects in the initialization section.

    Processing that must occur on a per-frame basis may be included by overriding
    the `ggame.App.step` method. This is also an appropriate location to call
    similar 'step' methods for your various customized sprite classes.

    Once your application class has been instantiated, begin the frame drawing
    process by calling its `ggame.App.run` method.

    NOTE: Only **one** instance of an `ggame.App` class or subclass may be 
    instantiated at a time.
    """
    spritelist = []
    """List of all sprites currently active in the application."""
    _eventdict = {}
    _spritesdict = {}
    _spritesadded = False
    _win = None

    def __init__(self, *args):
        """
        The `ggame.App` class is called either by specifying the desired app window size
        in pixels, as two parameters (e.g. `myapp = App(640,480)`), or by providing
        no size parameters at all (e.g. `myapp = App()`), in which case, the full browser
        window size is used.
        """
        if App._win == None and (len(args) == 0 or len(args) == 2):
            x = y = 0
            if len(args) == 2:
                x = args[0]
                y = args[1]
            App._win = GFX_Window(x, y, type(self)._destroy)
            self.width = App._win.width
            self.height = App._win.height
            # Add existing sprites to the window
            if not App._spritesadded and len(App.spritelist) > 0:
                App._spritesadded = True
                for sprite in App.spritelist:
                    App._win.add(sprite.GFX)
            App._win.bind(KeyEvent.keydown, self._keyEvent)
            App._win.bind(KeyEvent.keyup, self._keyEvent)
            App._win.bind(KeyEvent.keypress, self._keyEvent)
            App._win.bind(MouseEvent.mousewheel, self._mouseEvent)
            App._win.bind(MouseEvent.mousemove, self._mouseEvent)
            App._win.bind(MouseEvent.mousedown, self._mouseEvent)
            App._win.bind(MouseEvent.mouseup, self._mouseEvent)
            App._win.bind(MouseEvent.click, self._mouseEvent)
            App._win.bind(MouseEvent.dblclick, self._mouseEvent)

        
    def _routeEvent(self, event, evtlist):
        for callback in reversed(evtlist):
            if not event.consumed:
                callback(event)
        
    def _keyEvent(self, hwevent):
        evtlist = App._eventdict.get(
            (hwevent.type, KeyEvent.keys.get(hwevent.keyCode,0)), [])
        evtlist.extend(App._eventdict.get((hwevent.type, '*'), []))
        if len(evtlist) > 0:
            evt = KeyEvent(hwevent)
            self._routeEvent(evt, evtlist)
        return False

    def _mouseEvent(self, hwevent):
        evtlist = App._eventdict.get(hwevent.type, [])
        if len(evtlist) > 0:
            evt = MouseEvent(hwevent)
            self._routeEvent(evt, evtlist)
        return False

    @classmethod
    def _add(cls, obj):
        if App._win != None:
            App._win.add(obj.GFX)
        App.spritelist.append(obj)
        if type(obj) not in App._spritesdict:
            App._spritesdict[type(obj)] = []
        App._spritesdict[type(obj)].append(obj)

    @classmethod
    def _remove(cls, obj):
        if App._win != None:
            App._win.remove(obj.GFX)
        App.spritelist.remove(obj)
        App._spritesdict[type(obj)].remove(obj)
        
    def _animate(self, dummy):
        if self.userfunc:
            self.userfunc()
        else:
            self.step()
        App._win.animate(self._animate)

    @classmethod
    def _destroy(cls, *args):
        """
        This will close the display window/tab, remove all references to 
        sprites and place the `App` class in a state in which a new 
        application could be instantiated.
        """ 
        if App._win:
            App._win.unbind(KeyEvent.keydown)
            App._win.unbind(KeyEvent.keyup)
            App._win.unbind(KeyEvent.keypress)
            App._win.unbind(MouseEvent.mousewheel)
            App._win.unbind(MouseEvent.mousemove)
            App._win.unbind(MouseEvent.mousedown)
            App._win.unbind(MouseEvent.mouseup)
            App._win.unbind(MouseEvent.click)
            App._win.unbind(MouseEvent.dblclick)
            App._win.destroy()
        App._win = None
        for s in list(App.spritelist):
            s.destroy()
        App.spritelist = []
        App._spritesdict = {}
        App._eventdict = {}
        App._spritesadded = False

    @classmethod
    def listenKeyEvent(cls, eventtype, key, callback):
        """
        Register to receive keyboard events. The `eventtype` parameter is a 
        string that indicates what type of key event to receive (value is one
        of: `'keydown'`, `'keyup'` or `'keypress'`). The `key` parameter is a 
        string indicating which key (e.g. `'space'`, `'left arrow'`, etc.) to 
        receive events for. The `callback` parameter is a reference to a 
        function or method that will be called with the `ggame.KeyEvent` object
        when the event occurs.

        See the source for `ggame.KeyEvent.keys` for a list of key names
        to use with the `key` paramter.
        """
        evtlist = App._eventdict.get((eventtype, key), [])
        if not callback in evtlist:
            evtlist.append(callback)
        App._eventdict[(eventtype, key)] = evtlist

    @classmethod
    def listenMouseEvent(cls, eventtype, callback):
        """
        Register to receive mouse events. The `eventtype` parameter is
        a string that indicates what type of mouse event to receive (
        value is one of: `'mousemove'`, `'mousedown'`, `'mouseup'`, `'click'`, 
        `'dblclick'` or `'mousewheel'`). The `callback` parameter is a 
        reference to a function or method that will be called with the 
        `ggame.MouseEvent` object when the event occurs.
        """
        evtlist = App._eventdict.get(eventtype, [])
        if not callback in evtlist:
            evtlist.append(callback)
        App._eventdict[eventtype] = evtlist

    @classmethod
    def unlistenKeyEvent(cls, eventtype, key, callback):
        """
        Use this method to remove a registration to receive a particular
        keyboard event. Arguments must exactly match those used when
        registering for the event.
        """
        App._eventdict[(eventtype,key)].remove(callback)

    @classmethod
    def unlistenMouseEvent(cls, eventtype, callback):
        """
        Use this method to remove a registration to receive a particular
        mouse event. Arguments must exactly match those used when
        registering for the event.
        """
        App._eventdict[eventtype].remove(callback)

    @classmethod
    def getSpritesbyClass(cls, sclass):
        """
        Returns a list of all active sprites of a given class.
        """
        return App._spritesdict.get(sclass, [])
    
    def step(self):
        """
        The `ggame.App.step` method is called once per animation frame. Override
        this method in your own subclass of `ggame.App` to perform periodic 
        calculations, such as checking for sprite collisions, or calling
        'step' functions in your own customized sprite classes.

        The base class `ggame.App.step` method is empty and is intended to be overriden.
        """
        pass
    
    def run(self, userfunc = None):
        """
        Calling the `ggame.App.run` method begins the animation process whereby the 
        `ggame.App.step` method is called once per animation frame. Set `userfunc`
        to any function which shall be called once per animation frame.
        """
        self.userfunc = userfunc
        App._win.animate(self._animate)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggame.App">App</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="ggame.App.spritelist" class="name">var <span class="ident">spritelist</span></p>
            

            
  
    <div class="desc"><p>List of all sprites currently active in the application.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggame.App.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, *args)</p>
    </div>
    

    
  
    <div class="desc"><p>The <a href="#ggame.App"><code>App</code></a> class is called either by specifying the desired app window size
in pixels, as two parameters (e.g. <code>myapp = App(640,480)</code>), or by providing
no size parameters at all (e.g. <code>myapp = App()</code>), in which case, the full browser
window size is used.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.App.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggame.App.__init__" class="source">
    <pre><code>def __init__(self, *args):
    """
    The `ggame.App` class is called either by specifying the desired app window size
    in pixels, as two parameters (e.g. `myapp = App(640,480)`), or by providing
    no size parameters at all (e.g. `myapp = App()`), in which case, the full browser
    window size is used.
    """
    if App._win == None and (len(args) == 0 or len(args) == 2):
        x = y = 0
        if len(args) == 2:
            x = args[0]
            y = args[1]
        App._win = GFX_Window(x, y, type(self)._destroy)
        self.width = App._win.width
        self.height = App._win.height
        # Add existing sprites to the window
        if not App._spritesadded and len(App.spritelist) > 0:
            App._spritesadded = True
            for sprite in App.spritelist:
                App._win.add(sprite.GFX)
        App._win.bind(KeyEvent.keydown, self._keyEvent)
        App._win.bind(KeyEvent.keyup, self._keyEvent)
        App._win.bind(KeyEvent.keypress, self._keyEvent)
        App._win.bind(MouseEvent.mousewheel, self._mouseEvent)
        App._win.bind(MouseEvent.mousemove, self._mouseEvent)
        App._win.bind(MouseEvent.mousedown, self._mouseEvent)
        App._win.bind(MouseEvent.mouseup, self._mouseEvent)
        App._win.bind(MouseEvent.click, self._mouseEvent)
        App._win.bind(MouseEvent.dblclick, self._mouseEvent)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.App.run">
    <p>def <span class="ident">run</span>(</p><p>self, userfunc=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Calling the <a href="#ggame.App.run"><code>run</code></a> method begins the animation process whereby the 
<a href="#ggame.App.step"><code>step</code></a> method is called once per animation frame. Set <code>userfunc</code>
to any function which shall be called once per animation frame.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.App.run', this);">Show source &equiv;</a></p>
  <div id="source-ggame.App.run" class="source">
    <pre><code>def run(self, userfunc = None):
    """
    Calling the `ggame.App.run` method begins the animation process whereby the 
    `ggame.App.step` method is called once per animation frame. Set `userfunc`
    to any function which shall be called once per animation frame.
    """
    self.userfunc = userfunc
    App._win.animate(self._animate)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.App.step">
    <p>def <span class="ident">step</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>The <a href="#ggame.App.step"><code>step</code></a> method is called once per animation frame. Override
this method in your own subclass of <a href="#ggame.App"><code>App</code></a> to perform periodic 
calculations, such as checking for sprite collisions, or calling
'step' functions in your own customized sprite classes.</p>
<p>The base class <a href="#ggame.App.step"><code>step</code></a> method is empty and is intended to be overriden.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.App.step', this);">Show source &equiv;</a></p>
  <div id="source-ggame.App.step" class="source">
    <pre><code>def step(self):
    """
    The `ggame.App.step` method is called once per animation frame. Override
    this method in your own subclass of `ggame.App` to perform periodic 
    calculations, such as checking for sprite collisions, or calling
    'step' functions in your own customized sprite classes.
    The base class `ggame.App.step` method is empty and is intended to be overriden.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="ggame.App.getSpritesbyClass">
    <p>def <span class="ident">getSpritesbyClass</span>(</p><p>cls, sclass)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a list of all active sprites of a given class.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.App.getSpritesbyClass', this);">Show source &equiv;</a></p>
  <div id="source-ggame.App.getSpritesbyClass" class="source">
    <pre><code>@classmethod
def getSpritesbyClass(cls, sclass):
    """
    Returns a list of all active sprites of a given class.
    """
    return App._spritesdict.get(sclass, [])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.App.listenKeyEvent">
    <p>def <span class="ident">listenKeyEvent</span>(</p><p>cls, eventtype, key, callback)</p>
    </div>
    

    
  
    <div class="desc"><p>Register to receive keyboard events. The <code>eventtype</code> parameter is a 
string that indicates what type of key event to receive (value is one
of: <code>'keydown'</code>, <code>'keyup'</code> or <code>'keypress'</code>). The <code>key</code> parameter is a 
string indicating which key (e.g. <code>'space'</code>, <code>'left arrow'</code>, etc.) to 
receive events for. The <code>callback</code> parameter is a reference to a 
function or method that will be called with the <a href="#ggame.KeyEvent"><code>KeyEvent</code></a> object
when the event occurs.</p>
<p>See the source for <a href="#ggame.KeyEvent.keys"><code>keys</code></a> for a list of key names
to use with the <code>key</code> paramter.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.App.listenKeyEvent', this);">Show source &equiv;</a></p>
  <div id="source-ggame.App.listenKeyEvent" class="source">
    <pre><code>@classmethod
def listenKeyEvent(cls, eventtype, key, callback):
    """
    Register to receive keyboard events. The `eventtype` parameter is a 
    string that indicates what type of key event to receive (value is one
    of: `'keydown'`, `'keyup'` or `'keypress'`). The `key` parameter is a 
    string indicating which key (e.g. `'space'`, `'left arrow'`, etc.) to 
    receive events for. The `callback` parameter is a reference to a 
    function or method that will be called with the `ggame.KeyEvent` object
    when the event occurs.
    See the source for `ggame.KeyEvent.keys` for a list of key names
    to use with the `key` paramter.
    """
    evtlist = App._eventdict.get((eventtype, key), [])
    if not callback in evtlist:
        evtlist.append(callback)
    App._eventdict[(eventtype, key)] = evtlist
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.App.listenMouseEvent">
    <p>def <span class="ident">listenMouseEvent</span>(</p><p>cls, eventtype, callback)</p>
    </div>
    

    
  
    <div class="desc"><p>Register to receive mouse events. The <code>eventtype</code> parameter is
a string that indicates what type of mouse event to receive (
value is one of: <code>'mousemove'</code>, <code>'mousedown'</code>, <code>'mouseup'</code>, <code>'click'</code>, 
<code>'dblclick'</code> or <code>'mousewheel'</code>). The <code>callback</code> parameter is a 
reference to a function or method that will be called with the 
<a href="#ggame.MouseEvent"><code>MouseEvent</code></a> object when the event occurs.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.App.listenMouseEvent', this);">Show source &equiv;</a></p>
  <div id="source-ggame.App.listenMouseEvent" class="source">
    <pre><code>@classmethod
def listenMouseEvent(cls, eventtype, callback):
    """
    Register to receive mouse events. The `eventtype` parameter is
    a string that indicates what type of mouse event to receive (
    value is one of: `'mousemove'`, `'mousedown'`, `'mouseup'`, `'click'`, 
    `'dblclick'` or `'mousewheel'`). The `callback` parameter is a 
    reference to a function or method that will be called with the 
    `ggame.MouseEvent` object when the event occurs.
    """
    evtlist = App._eventdict.get(eventtype, [])
    if not callback in evtlist:
        evtlist.append(callback)
    App._eventdict[eventtype] = evtlist
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.App.unlistenKeyEvent">
    <p>def <span class="ident">unlistenKeyEvent</span>(</p><p>cls, eventtype, key, callback)</p>
    </div>
    

    
  
    <div class="desc"><p>Use this method to remove a registration to receive a particular
keyboard event. Arguments must exactly match those used when
registering for the event.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.App.unlistenKeyEvent', this);">Show source &equiv;</a></p>
  <div id="source-ggame.App.unlistenKeyEvent" class="source">
    <pre><code>@classmethod
def unlistenKeyEvent(cls, eventtype, key, callback):
    """
    Use this method to remove a registration to receive a particular
    keyboard event. Arguments must exactly match those used when
    registering for the event.
    """
    App._eventdict[(eventtype,key)].remove(callback)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.App.unlistenMouseEvent">
    <p>def <span class="ident">unlistenMouseEvent</span>(</p><p>cls, eventtype, callback)</p>
    </div>
    

    
  
    <div class="desc"><p>Use this method to remove a registration to receive a particular
mouse event. Arguments must exactly match those used when
registering for the event.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.App.unlistenMouseEvent', this);">Show source &equiv;</a></p>
  <div id="source-ggame.App.unlistenMouseEvent" class="source">
    <pre><code>@classmethod
def unlistenMouseEvent(cls, eventtype, callback):
    """
    Use this method to remove a registration to receive a particular
    mouse event. Arguments must exactly match those used when
    registering for the event.
    """
    App._eventdict[eventtype].remove(callback)
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ggame.CircleAsset" class="name">class <span class="ident">CircleAsset</span></p>
      
  
    <div class="desc"><p>The <a href="#ggame.CircleAsset"><code>CircleAsset</code></a> is a "virtual" asset that is created on the
fly without requiring creation of an image file.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.CircleAsset', this);">Show source &equiv;</a></p>
  <div id="source-ggame.CircleAsset" class="source">
    <pre><code>class CircleAsset(_ShapeAsset):
    """
    The `ggame.CircleAsset` is a "virtual" asset that is created on the
    fly without requiring creation of an image file.
    """    

    def __init__(self, radius, line=blackline, fill=black):
        """
        Creation of a `ggame.CircleAsset` requires specification of the circle
        `radius` in pixels, the `line` (as a proper `ggame.LineStyle` instance)
        and fill properties (as a `ggame.Color` instance).
        """
        super().__init__(line, fill)
        self.radius = radius
        self.GFX = GFX_Graphics.drawCircle(0, 0, self.radius).clone()
        """The `GFX` property represents the underlying system object."""
        self.GFX.visible = False
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggame.CircleAsset">CircleAsset</a></li>
          <li>__pdoc_file_module__._ShapeAsset</li>
          <li>__pdoc_file_module__._CurveAsset</li>
          <li>__pdoc_file_module__._GraphicsAsset</li>
          <li>__pdoc_file_module__._Asset</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggame.CircleAsset.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, radius, line=&lt;__pdoc_file_module__.LineStyle object at 0x7f8eacdd9eb8&gt;, fill=&lt;__pdoc_file_module__.Color object at 0x7f8eacdd9d30&gt;)</p>
    </div>
    

    
  
    <div class="desc"><p>Creation of a <a href="#ggame.CircleAsset"><code>CircleAsset</code></a> requires specification of the circle
<code>radius</code> in pixels, the <code>line</code> (as a proper <a href="#ggame.LineStyle"><code>LineStyle</code></a> instance)
and fill properties (as a <a href="#ggame.Color"><code>Color</code></a> instance).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.CircleAsset.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggame.CircleAsset.__init__" class="source">
    <pre><code>def __init__(self, radius, line=blackline, fill=black):
    """
    Creation of a `ggame.CircleAsset` requires specification of the circle
    `radius` in pixels, the `line` (as a proper `ggame.LineStyle` instance)
    and fill properties (as a `ggame.Color` instance).
    """
    super().__init__(line, fill)
    self.radius = radius
    self.GFX = GFX_Graphics.drawCircle(0, 0, self.radius).clone()
    """The `GFX` property represents the underlying system object."""
    self.GFX.visible = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.CircleAsset.destroy">
    <p>def <span class="ident">destroy</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.CircleAsset.destroy', this);">Show source &equiv;</a></p>
  <div id="source-ggame.CircleAsset.destroy" class="source">
    <pre><code>def destroy(self):
    if hasattr(self, 'GFX'):
        try:
            for gfx in self.GFXlist:
                try:
                    gfx.destroy(True)
                except:
                    pass
        except:
            pass
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggame.CircleAsset.GFX" class="name">var <span class="ident">GFX</span></p>
            

            
  
    <div class="desc"><p>The <code>GFX</code> property represents the underlying system object.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.CircleAsset.radius" class="name">var <span class="ident">radius</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="ggame.Color" class="name">class <span class="ident">Color</span></p>
      
  
    <div class="desc"><p>The <a href="#ggame.Color"><code>Color</code></a> class is used to represent colors and/or colors with
transparency.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.Color', this);">Show source &equiv;</a></p>
  <div id="source-ggame.Color" class="source">
    <pre><code>class Color(object):
    """
    The `ggame.Color` class is used to represent colors and/or colors with
    transparency.
    """

    def __init__(self, color, alpha):
        """
        A `ggame.Color` instance must specify both a `color` as an integer
        in the conventional format (usually as a hexadecimal literal, e.g.
        0xffbb33 that represents the three color components, red, green 
        and blue), and a transparency value, or `alpha` as a floating
        point number in the range of 0.0 to 1.0 where 0.0 represents 
        completely transparent and 1.0 represents completely solid.

        Example: `red = Color(0xff0000, 1.0)`

        """
        self.color = color
        self.alpha = alpha
        
    def __eq__(self, other):
        return type(self) is type(other) and self.color == other.color and self.alpha == other.alpha
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggame.Color">Color</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggame.Color.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, color, alpha)</p>
    </div>
    

    
  
    <div class="desc"><p>A <a href="#ggame.Color"><code>Color</code></a> instance must specify both a <code>color</code> as an integer
in the conventional format (usually as a hexadecimal literal, e.g.
0xffbb33 that represents the three color components, red, green 
and blue), and a transparency value, or <code>alpha</code> as a floating
point number in the range of 0.0 to 1.0 where 0.0 represents 
completely transparent and 1.0 represents completely solid.</p>
<p>Example: <code>red = Color(0xff0000, 1.0)</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.Color.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggame.Color.__init__" class="source">
    <pre><code>def __init__(self, color, alpha):
    """
    A `ggame.Color` instance must specify both a `color` as an integer
    in the conventional format (usually as a hexadecimal literal, e.g.
    0xffbb33 that represents the three color components, red, green 
    and blue), and a transparency value, or `alpha` as a floating
    point number in the range of 0.0 to 1.0 where 0.0 represents 
    completely transparent and 1.0 represents completely solid.
    Example: `red = Color(0xff0000, 1.0)`
    """
    self.color = color
    self.alpha = alpha
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggame.Color.alpha" class="name">var <span class="ident">alpha</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.Color.color" class="name">var <span class="ident">color</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="ggame.EllipseAsset" class="name">class <span class="ident">EllipseAsset</span></p>
      
  
    <div class="desc"><p>The <a href="#ggame.EllipseAsset"><code>EllipseAsset</code></a> is a "virtual" asset that is created on the 
fly without requiring creation of an image file.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.EllipseAsset', this);">Show source &equiv;</a></p>
  <div id="source-ggame.EllipseAsset" class="source">
    <pre><code>class EllipseAsset(_ShapeAsset):
    """
    The `ggame.EllipseAsset` is a "virtual" asset that is created on the 
    fly without requiring creation of an image file.
    """

    def __init__(self, halfw, halfh, line=blackline, fill=black):
        """
        Creation of a `ggame.EllipseAsset` requires specification of the ellipse
        `halfw`, or semi-axis length in the horizontal direction (half of the
        ellipse width) and the `halfh`, or semi-axis length in the vertical direction.
        `line` (as `ggame.LineStyle` instance) and `fill` (as `ggame.Color` instance)
        must also be provided.
        """
        super().__init__(line, fill)
        self.halfw = halfw
        self.halfh = halfh
        self.GFX = GFX_Graphics.drawEllipse(0, 0, self.halfw, self.halfh).clone()
        """The `GFX` property represents the underlying system object."""
        self.GFX.visible = False
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggame.EllipseAsset">EllipseAsset</a></li>
          <li>__pdoc_file_module__._ShapeAsset</li>
          <li>__pdoc_file_module__._CurveAsset</li>
          <li>__pdoc_file_module__._GraphicsAsset</li>
          <li>__pdoc_file_module__._Asset</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggame.EllipseAsset.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, halfw, halfh, line=&lt;__pdoc_file_module__.LineStyle object at 0x7f8eacdd9eb8&gt;, fill=&lt;__pdoc_file_module__.Color object at 0x7f8eacdd9d30&gt;)</p>
    </div>
    

    
  
    <div class="desc"><p>Creation of a <a href="#ggame.EllipseAsset"><code>EllipseAsset</code></a> requires specification of the ellipse
<code>halfw</code>, or semi-axis length in the horizontal direction (half of the
ellipse width) and the <code>halfh</code>, or semi-axis length in the vertical direction.
<code>line</code> (as <a href="#ggame.LineStyle"><code>LineStyle</code></a> instance) and <code>fill</code> (as <a href="#ggame.Color"><code>Color</code></a> instance)
must also be provided.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.EllipseAsset.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggame.EllipseAsset.__init__" class="source">
    <pre><code>def __init__(self, halfw, halfh, line=blackline, fill=black):
    """
    Creation of a `ggame.EllipseAsset` requires specification of the ellipse
    `halfw`, or semi-axis length in the horizontal direction (half of the
    ellipse width) and the `halfh`, or semi-axis length in the vertical direction.
    `line` (as `ggame.LineStyle` instance) and `fill` (as `ggame.Color` instance)
    must also be provided.
    """
    super().__init__(line, fill)
    self.halfw = halfw
    self.halfh = halfh
    self.GFX = GFX_Graphics.drawEllipse(0, 0, self.halfw, self.halfh).clone()
    """The `GFX` property represents the underlying system object."""
    self.GFX.visible = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.EllipseAsset.destroy">
    <p>def <span class="ident">destroy</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.EllipseAsset.destroy', this);">Show source &equiv;</a></p>
  <div id="source-ggame.EllipseAsset.destroy" class="source">
    <pre><code>def destroy(self):
    if hasattr(self, 'GFX'):
        try:
            for gfx in self.GFXlist:
                try:
                    gfx.destroy(True)
                except:
                    pass
        except:
            pass
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggame.EllipseAsset.GFX" class="name">var <span class="ident">GFX</span></p>
            

            
  
    <div class="desc"><p>The <code>GFX</code> property represents the underlying system object.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.EllipseAsset.halfh" class="name">var <span class="ident">halfh</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.EllipseAsset.halfw" class="name">var <span class="ident">halfw</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="ggame.Frame" class="name">class <span class="ident">Frame</span></p>
      
  
    <div class="desc"><p>Frame is a utility class for expressing the idea of a rectangular region.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.Frame', this);">Show source &equiv;</a></p>
  <div id="source-ggame.Frame" class="source">
    <pre><code>class Frame(object):
    """
    Frame is a utility class for expressing the idea of a rectangular region.
    """
    
    def __init__(self, x, y, w, h):
        """
        Initialization for the `ggame.Frame` objects.

        `x` and `y` are coordinates of the upper left hand corner of the frame.
 
        `w` and `h` are the width and height of the frame rectangle.
        """

        self.GFX = GFX_Rectangle(x,y,w,h)
        """
        `GFX` is a reference to the underlying object provided by the system.
        """
        self.x = x
        """
        X-coordinate of the upper left hand corner of this `ggame.Frame`.
        """
        self.y = y
        """
        Y-coordinate of the upper left hand corner of this `ggame.Frame`.
        """
        self.w = w
        """
        Width of the `ggame.Frame`.
        """
        self.h = h
        """
        Height of the `ggame.Frame`.
        """
    
    @property
    def x(self):
        return self.GFX.x
    
    @x.setter
    def x(self, value):
        self.GFX.x = value
        
    @property
    def y(self):
        return self.GFX.y
    
    @y.setter
    def y(self, value):
        self.GFX.y = value
    
    @property
    def w(self):
        return self.GFX.width
    
    @w.setter
    def w(self, value):
        self.GFX.width = value
        
    @property
    def h(self):
        return self.GFX.height
        
    @h.setter
    def h(self, value):
        self.GFX.height = value
    
    @property
    def center(self):
        """
        `center` property computes a coordinate pair (tuple) for the 
        center of the frame.

        The `center` property, when set, redefines the `x` and `y` properties
        of the frame in order to make the center agree with the coordinates
        (tuple) assigned to it.
        """

        return (self.x + self.w//2, self.y + self.h//2)
    
    @center.setter
    def center(self, value):
        c = self.center
        self.x += value[0] - c[0]
        self.y += value[1] - c[1]
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggame.Frame">Frame</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggame.Frame.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, x, y, w, h)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialization for the <a href="#ggame.Frame"><code>Frame</code></a> objects.</p>
<p><code>x</code> and <code>y</code> are coordinates of the upper left hand corner of the frame.</p>
<p><code>w</code> and <code>h</code> are the width and height of the frame rectangle.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.Frame.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggame.Frame.__init__" class="source">
    <pre><code>def __init__(self, x, y, w, h):
    """
    Initialization for the `ggame.Frame` objects.
    `x` and `y` are coordinates of the upper left hand corner of the frame.
    `w` and `h` are the width and height of the frame rectangle.
    """
    self.GFX = GFX_Rectangle(x,y,w,h)
    """
    `GFX` is a reference to the underlying object provided by the system.
    """
    self.x = x
    """
    X-coordinate of the upper left hand corner of this `ggame.Frame`.
    """
    self.y = y
    """
    Y-coordinate of the upper left hand corner of this `ggame.Frame`.
    """
    self.w = w
    """
    Width of the `ggame.Frame`.
    """
    self.h = h
    """
    Height of the `ggame.Frame`.
    """
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggame.Frame.GFX" class="name">var <span class="ident">GFX</span></p>
            

            
  
    <div class="desc"><p><code>GFX</code> is a reference to the underlying object provided by the system.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.Frame.center" class="name">var <span class="ident">center</span></p>
            

            
  
    <div class="desc"><p><code>center</code> property computes a coordinate pair (tuple) for the 
center of the frame.</p>
<p>The <code>center</code> property, when set, redefines the <code>x</code> and <code>y</code> properties
of the frame in order to make the center agree with the coordinates
(tuple) assigned to it.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.Frame.h" class="name">var <span class="ident">h</span></p>
            

            
  
    <div class="desc"><p>Height of the <a href="#ggame.Frame"><code>Frame</code></a>.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.Frame.w" class="name">var <span class="ident">w</span></p>
            

            
  
    <div class="desc"><p>Width of the <a href="#ggame.Frame"><code>Frame</code></a>.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.Frame.x" class="name">var <span class="ident">x</span></p>
            

            
  
    <div class="desc"><p>X-coordinate of the upper left hand corner of this <a href="#ggame.Frame"><code>Frame</code></a>.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.Frame.y" class="name">var <span class="ident">y</span></p>
            

            
  
    <div class="desc"><p>Y-coordinate of the upper left hand corner of this <a href="#ggame.Frame"><code>Frame</code></a>.</p></div>
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="ggame.ImageAsset" class="name">class <span class="ident">ImageAsset</span></p>
      
  
    <div class="desc"><p>The <code>ImageAsset</code> class connects ggame to a specific image <strong>file</strong>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.ImageAsset', this);">Show source &equiv;</a></p>
  <div id="source-ggame.ImageAsset" class="source">
    <pre><code>class ImageAsset(_Asset):
    """
    The `ImageAsset` class connects ggame to a specific image **file**.
    """

    def __init__(self, url, frame=None, qty=1, direction='horizontal', margin=0):
        """
        All `ggame.ImageAsset` instances must specify a file name or url with
        the `url` parameter.

        If the desired sprite image exists in only a smaller sub-section of the 
        original image, then the are can be specified by providing the
        `frame` parameter, which must be a valid `ggame.Frame` object.

        If image file actually is a *collection* of images, such as a so-called
        *sprite sheet*, then the `ImageAsset` class supports defining a list
        of images, provided they exist in the original image as a **row**
        of evenly spaced images or a **column** of images. To specify this,
        provide the `qty` (quantity) of images in the row or column, the
        `direction` of the list ('horizontal' or 'vertical' are supported),
        and an optional `margin`, if there is a gap between successive 
        images. When used in this way, the `frame` parameter must define the
        area of the **first** image in the collection; all subsequent images
        in the list are assumed to be the same size.
        """
        super().__init__()
        self.url = url
        """
        A string that represents the path or url of the original file.
        """
        del self.GFXlist[0]
        self.width = self.height = 0
        self.append(url, frame, qty, direction, margin)

    def _subframe(self, texture, frame):
        return GFX_Texture(texture, frame.GFX)
        
    def append(self, url, frame=None, qty=1, direction='horizontal', margin=0):
        """
        Append a texture asset from a new image file (or url). This method
        allows you to build a collection of images into an asset (such as you
        might need for an animated sprite), but without using a single 
        sprite sheet image.

        The parameters for the `append` method are identical to those 
        supplied to the `ggame.ImageAsset` initialization method. 

        This method allows you to build up an asset that consists of 
        multiple rows or columns of images in a sprite sheet or sheets.
        """
        GFX = GFX_Texture_fromImage(url, False)
        dx = 0
        dy = 0
        for i in range(qty):
            if not frame is None:
                self.width = frame.w
                self.height = frame.h
                if direction == 'horizontal':
                    dx = frame.w + margin
                elif direction == 'vertical':
                    dy = frame.h + margin
                f = Frame(frame.x + dx * i, frame.y + dy * i, frame.w, frame.h)
                GFX = self._subframe(GFX, f)
            else:
                self.width = GFX.width
                self.height = GFX.height
            self.GFXlist.append(GFX)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggame.ImageAsset">ImageAsset</a></li>
          <li>__pdoc_file_module__._Asset</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggame.ImageAsset.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, url, frame=None, qty=1, direction=&#39;horizontal&#39;, margin=0)</p>
    </div>
    

    
  
    <div class="desc"><p>All <a href="#ggame.ImageAsset"><code>ImageAsset</code></a> instances must specify a file name or url with
the <code>url</code> parameter.</p>
<p>If the desired sprite image exists in only a smaller sub-section of the 
original image, then the are can be specified by providing the
<code>frame</code> parameter, which must be a valid <a href="#ggame.Frame"><code>Frame</code></a> object.</p>
<p>If image file actually is a <em>collection</em> of images, such as a so-called
<em>sprite sheet</em>, then the <code>ImageAsset</code> class supports defining a list
of images, provided they exist in the original image as a <strong>row</strong>
of evenly spaced images or a <strong>column</strong> of images. To specify this,
provide the <code>qty</code> (quantity) of images in the row or column, the
<code>direction</code> of the list ('horizontal' or 'vertical' are supported),
and an optional <code>margin</code>, if there is a gap between successive 
images. When used in this way, the <code>frame</code> parameter must define the
area of the <strong>first</strong> image in the collection; all subsequent images
in the list are assumed to be the same size.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.ImageAsset.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggame.ImageAsset.__init__" class="source">
    <pre><code>def __init__(self, url, frame=None, qty=1, direction='horizontal', margin=0):
    """
    All `ggame.ImageAsset` instances must specify a file name or url with
    the `url` parameter.
    If the desired sprite image exists in only a smaller sub-section of the 
    original image, then the are can be specified by providing the
    `frame` parameter, which must be a valid `ggame.Frame` object.
    If image file actually is a *collection* of images, such as a so-called
    *sprite sheet*, then the `ImageAsset` class supports defining a list
    of images, provided they exist in the original image as a **row**
    of evenly spaced images or a **column** of images. To specify this,
    provide the `qty` (quantity) of images in the row or column, the
    `direction` of the list ('horizontal' or 'vertical' are supported),
    and an optional `margin`, if there is a gap between successive 
    images. When used in this way, the `frame` parameter must define the
    area of the **first** image in the collection; all subsequent images
    in the list are assumed to be the same size.
    """
    super().__init__()
    self.url = url
    """
    A string that represents the path or url of the original file.
    """
    del self.GFXlist[0]
    self.width = self.height = 0
    self.append(url, frame, qty, direction, margin)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.ImageAsset.append">
    <p>def <span class="ident">append</span>(</p><p>self, url, frame=None, qty=1, direction=&#39;horizontal&#39;, margin=0)</p>
    </div>
    

    
  
    <div class="desc"><p>Append a texture asset from a new image file (or url). This method
allows you to build a collection of images into an asset (such as you
might need for an animated sprite), but without using a single 
sprite sheet image.</p>
<p>The parameters for the <code>append</code> method are identical to those 
supplied to the <a href="#ggame.ImageAsset"><code>ImageAsset</code></a> initialization method. </p>
<p>This method allows you to build up an asset that consists of 
multiple rows or columns of images in a sprite sheet or sheets.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.ImageAsset.append', this);">Show source &equiv;</a></p>
  <div id="source-ggame.ImageAsset.append" class="source">
    <pre><code>def append(self, url, frame=None, qty=1, direction='horizontal', margin=0):
    """
    Append a texture asset from a new image file (or url). This method
    allows you to build a collection of images into an asset (such as you
    might need for an animated sprite), but without using a single 
    sprite sheet image.
    The parameters for the `append` method are identical to those 
    supplied to the `ggame.ImageAsset` initialization method. 
    This method allows you to build up an asset that consists of 
    multiple rows or columns of images in a sprite sheet or sheets.
    """
    GFX = GFX_Texture_fromImage(url, False)
    dx = 0
    dy = 0
    for i in range(qty):
        if not frame is None:
            self.width = frame.w
            self.height = frame.h
            if direction == 'horizontal':
                dx = frame.w + margin
            elif direction == 'vertical':
                dy = frame.h + margin
            f = Frame(frame.x + dx * i, frame.y + dy * i, frame.w, frame.h)
            GFX = self._subframe(GFX, f)
        else:
            self.width = GFX.width
            self.height = GFX.height
        self.GFXlist.append(GFX)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.ImageAsset.destroy">
    <p>def <span class="ident">destroy</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.ImageAsset.destroy', this);">Show source &equiv;</a></p>
  <div id="source-ggame.ImageAsset.destroy" class="source">
    <pre><code>def destroy(self):
    if hasattr(self, 'GFX'):
        try:
            for gfx in self.GFXlist:
                try:
                    gfx.destroy(True)
                except:
                    pass
        except:
            pass
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggame.ImageAsset.GFX" class="name">var <span class="ident">GFX</span></p>
            

            
  
    <div class="desc"><p><code>GFX</code> property represents the underlying system object used to represent
this asset. If this asset is composed of multiple assets, then the <strong>first</strong>
asset is referenced by <code>GFX</code>.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.ImageAsset.url" class="name">var <span class="ident">url</span></p>
            

            
  
    <div class="desc"><p>A string that represents the path or url of the original file.</p></div>
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="ggame.KeyEvent" class="name">class <span class="ident">KeyEvent</span></p>
      
  
    <div class="desc"><p>The <a href="#ggame.KeyEvent"><code>KeyEvent</code></a> class encapsulates information regarding a user keyboard
action that is being reported by the system.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.KeyEvent', this);">Show source &equiv;</a></p>
  <div id="source-ggame.KeyEvent" class="source">
    <pre><code>class KeyEvent(_Event):
    """
    The `ggame.KeyEvent` class encapsulates information regarding a user keyboard
    action that is being reported by the system.
    """    

    no_location = 0
    """Constant indicating no specific location for the key event."""
    right_location = 2
    """Constant indicating the key event was on the right hand side of the keyboard."""
    left_location = 1
    """Constant indicating the key event was on the left hand side of the keyboard."""
    keydown = "keydown"
    """Constant indicating the key was pressed down."""
    keyup = "keyup"
    """Constant indicating the key was released."""
    keypress = "keypress"
    """Constant indicating the combination of keydown, followed by keyup."""
    keys = {8: 'backspace',
        9: 'tab',
        13: 'enter',
        16: 'shift',
        17: 'ctrl',
        18: 'alt',
        19: 'pause/break',
        20: 'caps lock',
        27: 'escape',
        32: 'space',
        33: 'page up',
        34: 'page down',
        35: 'end',
        36: 'home',
        37: 'left arrow',
        38: 'up arrow',
        39: 'right arrow',
        40: 'down arrow',
        45: 'insert',
        46: 'delete',
        48: '0',
        49: '1',
        50: '2',
        51: '3',
        52: '4',
        53: '5',
        54: '6',
        55: '7',
        56: '8',
        57: '9',
        65: 'a',
        66: 'b',
        67: 'c',
        68: 'd',
        69: 'e',
        70: 'f',
        71: 'g',
        72: 'h',
        73: 'i',
        74: 'j',
        75: 'k',
        76: 'l',
        77: 'm',
        78: 'n',
        79: 'o',
        80: 'p',
        81: 'q',
        82: 'r',
        83: 's',
        84: 't',
        85: 'u',
        86: 'v',
        87: 'w',
        88: 'x',
        89: 'y',
        90: 'z',
        91: 'left window key',
        92: 'right window key',
        93: 'select key',
        96: 'numpad 0',
        97: 'numpad 1',
        98: 'numpad 2',
        99: 'numpad 3',
        100: 'numpad 4',
        101: 'numpad 5',
        102: 'numpad 6',
        103: 'numpad 7',
        104: 'numpad 8',
        105: 'numpad 9',
        106: 'multiply',
        107: 'add',
        109: 'subtract',
        110: 'decimal point',
        111: 'divide',
        112: 'f1',
        113: 'f2',
        114: 'f3',
        115: 'f4',
        116: 'f5',
        117: 'f6',
        118: 'f7',
        119: 'f8',
        120: 'f9',
        121: 'f10',
        122: 'f11',
        123: 'f12',
        144: 'num lock',
        145: 'scroll lock',
        186: 'semicolon',
        187: 'equal sign',
        188: 'comma',
        189: 'dash',
        190: 'period',
        191: 'forward slash',
        192: 'grave accent',
        219: 'open bracket',
        220: 'back slash',
        221: 'close bracket',
        222: 'single quote'}    
    """Dictionary mapping key code integers to textual key description."""
    
    def __init__(self, hwevent):
        """
        The event is initialized by the system, with a `hwevent` input parameter.
        """
        super().__init__(hwevent)
        self.keynum = hwevent.keyCode
        """The `keynum` attribute identifies a keycode (number)."""
        self.key = self.keys[hwevent.keyCode]
        """The `key` attribute identifes the key in text form (e.g. 'back slash')."""
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggame.KeyEvent">KeyEvent</a></li>
          <li>__pdoc_file_module__._Event</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="ggame.KeyEvent.keydown" class="name">var <span class="ident">keydown</span></p>
            

            
  
    <div class="desc"><p>Constant indicating the key was pressed down.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.KeyEvent.keypress" class="name">var <span class="ident">keypress</span></p>
            

            
  
    <div class="desc"><p>Constant indicating the combination of keydown, followed by keyup.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.KeyEvent.keys" class="name">var <span class="ident">keys</span></p>
            

            
  
    <div class="desc"><p>Dictionary mapping key code integers to textual key description.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.KeyEvent.keyup" class="name">var <span class="ident">keyup</span></p>
            

            
  
    <div class="desc"><p>Constant indicating the key was released.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.KeyEvent.left_location" class="name">var <span class="ident">left_location</span></p>
            

            
  
    <div class="desc"><p>Constant indicating the key event was on the left hand side of the keyboard.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.KeyEvent.no_location" class="name">var <span class="ident">no_location</span></p>
            

            
  
    <div class="desc"><p>Constant indicating no specific location for the key event.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.KeyEvent.right_location" class="name">var <span class="ident">right_location</span></p>
            

            
  
    <div class="desc"><p>Constant indicating the key event was on the right hand side of the keyboard.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggame.KeyEvent.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, hwevent)</p>
    </div>
    

    
  
    <div class="desc"><p>The event is initialized by the system, with a <code>hwevent</code> input parameter.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.KeyEvent.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggame.KeyEvent.__init__" class="source">
    <pre><code>def __init__(self, hwevent):
    """
    The event is initialized by the system, with a `hwevent` input parameter.
    """
    super().__init__(hwevent)
    self.keynum = hwevent.keyCode
    """The `keynum` attribute identifies a keycode (number)."""
    self.key = self.keys[hwevent.keyCode]
    """The `key` attribute identifes the key in text form (e.g. 'back slash')."""
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggame.KeyEvent.key" class="name">var <span class="ident">key</span></p>
            

            
  
    <div class="desc"><p>The <code>key</code> attribute identifes the key in text form (e.g. 'back slash').</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.KeyEvent.keynum" class="name">var <span class="ident">keynum</span></p>
            

            
  
    <div class="desc"><p>The <code>keynum</code> attribute identifies a keycode (number).</p></div>
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="ggame.LineAsset" class="name">class <span class="ident">LineAsset</span></p>
      
  
    <div class="desc"><p>The <a href="#ggame.LineAsset"><code>LineAsset</code></a> is a "virtual" asset that is created on the
fly without requiring creation of an image file. A <code>LineAsset</code> instance
represents a single line segment.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.LineAsset', this);">Show source &equiv;</a></p>
  <div id="source-ggame.LineAsset" class="source">
    <pre><code>class LineAsset(_CurveAsset):
    """
    The `ggame.LineAsset` is a "virtual" asset that is created on the
    fly without requiring creation of an image file. A `LineAsset` instance
    represents a single line segment.
    """

    def __init__(self, x, y, line=blackline):
        """
        Creation of a `ggame.LineAsset` requires specification of an `x` and
        `y` coordinate for the endpoint of the line. The starting point of the
        line is implied as coordinates (0,0). Note that when this asset is 
        used in a `ggame.Sprite` class, the sprite's `x` and `y` coordinates
        will control the location of the line segment on the screen.

        As the `ggame.LineAsset` does not cover a region, only a `ggame.LineStyle` 
        argument must be supplied (`line`).
        """
        super().__init__(line)
        self.deltaX = x
        """This attribute represents the `x` parameter supplied during instantiation."""
        self.deltaY = y
        """This attribute represents the `y` parameter supplied during instantiation."""
        GFX_Graphics.moveTo(0, 0)
        self.GFX = GFX_Graphics.lineTo(self.deltaX, self.deltaY).clone()
        """The `GFX` property represents the underlying system object."""
        self.GFX.visible = False
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggame.LineAsset">LineAsset</a></li>
          <li>__pdoc_file_module__._CurveAsset</li>
          <li>__pdoc_file_module__._GraphicsAsset</li>
          <li>__pdoc_file_module__._Asset</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggame.LineAsset.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, x, y, line=&lt;__pdoc_file_module__.LineStyle object at 0x7f8eacdd9eb8&gt;)</p>
    </div>
    

    
  
    <div class="desc"><p>Creation of a <a href="#ggame.LineAsset"><code>LineAsset</code></a> requires specification of an <code>x</code> and
<code>y</code> coordinate for the endpoint of the line. The starting point of the
line is implied as coordinates (0,0). Note that when this asset is 
used in a <a href="#ggame.Sprite"><code>Sprite</code></a> class, the sprite's <code>x</code> and <code>y</code> coordinates
will control the location of the line segment on the screen.</p>
<p>As the <a href="#ggame.LineAsset"><code>LineAsset</code></a> does not cover a region, only a <a href="#ggame.LineStyle"><code>LineStyle</code></a> 
argument must be supplied (<code>line</code>).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.LineAsset.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggame.LineAsset.__init__" class="source">
    <pre><code>def __init__(self, x, y, line=blackline):
    """
    Creation of a `ggame.LineAsset` requires specification of an `x` and
    `y` coordinate for the endpoint of the line. The starting point of the
    line is implied as coordinates (0,0). Note that when this asset is 
    used in a `ggame.Sprite` class, the sprite's `x` and `y` coordinates
    will control the location of the line segment on the screen.
    As the `ggame.LineAsset` does not cover a region, only a `ggame.LineStyle` 
    argument must be supplied (`line`).
    """
    super().__init__(line)
    self.deltaX = x
    """This attribute represents the `x` parameter supplied during instantiation."""
    self.deltaY = y
    """This attribute represents the `y` parameter supplied during instantiation."""
    GFX_Graphics.moveTo(0, 0)
    self.GFX = GFX_Graphics.lineTo(self.deltaX, self.deltaY).clone()
    """The `GFX` property represents the underlying system object."""
    self.GFX.visible = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.LineAsset.destroy">
    <p>def <span class="ident">destroy</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.LineAsset.destroy', this);">Show source &equiv;</a></p>
  <div id="source-ggame.LineAsset.destroy" class="source">
    <pre><code>def destroy(self):
    if hasattr(self, 'GFX'):
        try:
            for gfx in self.GFXlist:
                try:
                    gfx.destroy(True)
                except:
                    pass
        except:
            pass
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggame.LineAsset.GFX" class="name">var <span class="ident">GFX</span></p>
            

            
  
    <div class="desc"><p>The <code>GFX</code> property represents the underlying system object.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.LineAsset.deltaX" class="name">var <span class="ident">deltaX</span></p>
            

            
  
    <div class="desc"><p>This attribute represents the <code>x</code> parameter supplied during instantiation.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.LineAsset.deltaY" class="name">var <span class="ident">deltaY</span></p>
            

            
  
    <div class="desc"><p>This attribute represents the <code>y</code> parameter supplied during instantiation.</p></div>
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="ggame.LineStyle" class="name">class <span class="ident">LineStyle</span></p>
      
  
    <div class="desc"><p>The <a href="#ggame.LineStyle"><code>LineStyle</code></a> class is used to represent line style when
drawing geometrical objects such as rectangles, ellipses, etc.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.LineStyle', this);">Show source &equiv;</a></p>
  <div id="source-ggame.LineStyle" class="source">
    <pre><code>class LineStyle(object):
    """
    The `ggame.LineStyle` class is used to represent line style when
    drawing geometrical objects such as rectangles, ellipses, etc.
    """
    
    def __init__(self, width, color):
        """
        When creating a `ggame.LineStyle` instances you must specify 
        the `width` of the line in pixels and the `color` as a valid
        `ggame.Color` instance.

        Example: `line = LineStyle(3, Color(0x00ff00, 1.0))` will define
        a 3 pixel wide green line.
        """
        self.width = width
        self.color = color

    def __eq__(self, other):
        return type(self) is type(other) and self.width == other.width and self.color == other.color
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggame.LineStyle">LineStyle</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggame.LineStyle.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, width, color)</p>
    </div>
    

    
  
    <div class="desc"><p>When creating a <a href="#ggame.LineStyle"><code>LineStyle</code></a> instances you must specify 
the <code>width</code> of the line in pixels and the <code>color</code> as a valid
<a href="#ggame.Color"><code>Color</code></a> instance.</p>
<p>Example: <code>line = LineStyle(3, Color(0x00ff00, 1.0))</code> will define
a 3 pixel wide green line.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.LineStyle.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggame.LineStyle.__init__" class="source">
    <pre><code>def __init__(self, width, color):
    """
    When creating a `ggame.LineStyle` instances you must specify 
    the `width` of the line in pixels and the `color` as a valid
    `ggame.Color` instance.
    Example: `line = LineStyle(3, Color(0x00ff00, 1.0))` will define
    a 3 pixel wide green line.
    """
    self.width = width
    self.color = color
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggame.LineStyle.color" class="name">var <span class="ident">color</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.LineStyle.width" class="name">var <span class="ident">width</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="ggame.MouseEvent" class="name">class <span class="ident">MouseEvent</span></p>
      
  
    <div class="desc"><p>The <a href="#ggame.MouseEvent"><code>MouseEvent</code></a> class encapsulates information regarding a user mouse
action that is being reported by the system.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.MouseEvent', this);">Show source &equiv;</a></p>
  <div id="source-ggame.MouseEvent" class="source">
    <pre><code>class MouseEvent(_Event):
    """
    The `ggame.MouseEvent` class encapsulates information regarding a user mouse
    action that is being reported by the system.
    """    

    mousemove = "mousemove"
    """Constant identifying a `mousemove` event."""
    mousedown = "mousedown"
    """Constant identifying a `mousedown` event."""
    mouseup = "mouseup"
    """Constant identifying a `mouseup` event."""
    click = "click"
    """Constant identifying a button `click` event."""
    dblclick = "dblclick"
    """Constant identifying a button `dblclick` event."""
    mousewheel = "wheel"
    """Constant identifying a mouse `wheel` scroll event."""
    
    def __init__(self, hwevent):
        """
        The event is initialized by the system, with a `hwevent` input parameter.
        """
        super().__init__(hwevent)
        self.wheelDelta = 0
        """Integer representing up/down motion of the scroll wheel."""
        if self.type == self.mousewheel:
            self.wheelDelta = hwevent.deltaY
        else:
            self.wheelDelta = 0
        rect = App._win._renderer.view.getBoundingClientRect()
        xscale = App._win.width/rect.width
        yscale = App._win.height/rect.height
        self.x = (hwevent.clientX - rect.left) * xscale
        """The window x-coordinate of the mouse pointer when the event occurred."""
        self.y = (hwevent.clientY - rect.top) * yscale
        """The window y-coordinate of the mouse pointer when the event occurred."""
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggame.MouseEvent">MouseEvent</a></li>
          <li>__pdoc_file_module__._Event</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="ggame.MouseEvent.click" class="name">var <span class="ident">click</span></p>
            

            
  
    <div class="desc"><p>Constant identifying a button <code>click</code> event.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.MouseEvent.dblclick" class="name">var <span class="ident">dblclick</span></p>
            

            
  
    <div class="desc"><p>Constant identifying a button <code>dblclick</code> event.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.MouseEvent.mousedown" class="name">var <span class="ident">mousedown</span></p>
            

            
  
    <div class="desc"><p>Constant identifying a <code>mousedown</code> event.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.MouseEvent.mousemove" class="name">var <span class="ident">mousemove</span></p>
            

            
  
    <div class="desc"><p>Constant identifying a <code>mousemove</code> event.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.MouseEvent.mouseup" class="name">var <span class="ident">mouseup</span></p>
            

            
  
    <div class="desc"><p>Constant identifying a <code>mouseup</code> event.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.MouseEvent.mousewheel" class="name">var <span class="ident">mousewheel</span></p>
            

            
  
    <div class="desc"><p>Constant identifying a mouse <code>wheel</code> scroll event.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggame.MouseEvent.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, hwevent)</p>
    </div>
    

    
  
    <div class="desc"><p>The event is initialized by the system, with a <code>hwevent</code> input parameter.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.MouseEvent.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggame.MouseEvent.__init__" class="source">
    <pre><code>def __init__(self, hwevent):
    """
    The event is initialized by the system, with a `hwevent` input parameter.
    """
    super().__init__(hwevent)
    self.wheelDelta = 0
    """Integer representing up/down motion of the scroll wheel."""
    if self.type == self.mousewheel:
        self.wheelDelta = hwevent.deltaY
    else:
        self.wheelDelta = 0
    rect = App._win._renderer.view.getBoundingClientRect()
    xscale = App._win.width/rect.width
    yscale = App._win.height/rect.height
    self.x = (hwevent.clientX - rect.left) * xscale
    """The window x-coordinate of the mouse pointer when the event occurred."""
    self.y = (hwevent.clientY - rect.top) * yscale
    """The window y-coordinate of the mouse pointer when the event occurred."""
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggame.MouseEvent.wheelDelta" class="name">var <span class="ident">wheelDelta</span></p>
            

            
  
    <div class="desc"><p>Integer representing up/down motion of the scroll wheel.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.MouseEvent.x" class="name">var <span class="ident">x</span></p>
            

            
  
    <div class="desc"><p>The window x-coordinate of the mouse pointer when the event occurred.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.MouseEvent.y" class="name">var <span class="ident">y</span></p>
            

            
  
    <div class="desc"><p>The window y-coordinate of the mouse pointer when the event occurred.</p></div>
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="ggame.PolygonAsset" class="name">class <span class="ident">PolygonAsset</span></p>
      
  
    <div class="desc"><p>The <a href="#ggame.PolygonAsset"><code>PolygonAsset</code></a> is a "virtual" asset that is created on the
fly without requiring creation of an image file.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.PolygonAsset', this);">Show source &equiv;</a></p>
  <div id="source-ggame.PolygonAsset" class="source">
    <pre><code>class PolygonAsset(_ShapeAsset):
    """
    The `ggame.PolygonAsset` is a "virtual" asset that is created on the
    fly without requiring creation of an image file.
    """

    def __init__(self, path, line=blackline, fill=black):
        """
        Creation of a `ggame.PolygonAsset` requires specification of a 
        `path` consisting of a list of coordinate tuples. `line` and 
        `fill` arguments (instances of `ggame.LineStyle` and `ggame.Color`,
        respectively) must also be supplied. The final coordinate in the 
        list must be the same as the first.

        Example: `poly = PolygonAsset([(0,0), (50,50), (50,100), (0,0)], linesty, fcolor)`
        """
        super().__init__(line, fill)
        self.path = path
        jpath = []
        for point in self.path:
            jpath.extend(point)
        self.GFX = GFX_Graphics.drawPolygon(jpath).clone()
        """The `GFX` property represents the underlying system object."""
        self.GFX.visible = False
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggame.PolygonAsset">PolygonAsset</a></li>
          <li>__pdoc_file_module__._ShapeAsset</li>
          <li>__pdoc_file_module__._CurveAsset</li>
          <li>__pdoc_file_module__._GraphicsAsset</li>
          <li>__pdoc_file_module__._Asset</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggame.PolygonAsset.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, path, line=&lt;__pdoc_file_module__.LineStyle object at 0x7f8eacdd9eb8&gt;, fill=&lt;__pdoc_file_module__.Color object at 0x7f8eacdd9d30&gt;)</p>
    </div>
    

    
  
    <div class="desc"><p>Creation of a <a href="#ggame.PolygonAsset"><code>PolygonAsset</code></a> requires specification of a 
<code>path</code> consisting of a list of coordinate tuples. <code>line</code> and 
<code>fill</code> arguments (instances of <a href="#ggame.LineStyle"><code>LineStyle</code></a> and <a href="#ggame.Color"><code>Color</code></a>,
respectively) must also be supplied. The final coordinate in the 
list must be the same as the first.</p>
<p>Example: <code>poly = PolygonAsset([(0,0), (50,50), (50,100), (0,0)], linesty, fcolor)</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.PolygonAsset.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggame.PolygonAsset.__init__" class="source">
    <pre><code>def __init__(self, path, line=blackline, fill=black):
    """
    Creation of a `ggame.PolygonAsset` requires specification of a 
    `path` consisting of a list of coordinate tuples. `line` and 
    `fill` arguments (instances of `ggame.LineStyle` and `ggame.Color`,
    respectively) must also be supplied. The final coordinate in the 
    list must be the same as the first.
    Example: `poly = PolygonAsset([(0,0), (50,50), (50,100), (0,0)], linesty, fcolor)`
    """
    super().__init__(line, fill)
    self.path = path
    jpath = []
    for point in self.path:
        jpath.extend(point)
    self.GFX = GFX_Graphics.drawPolygon(jpath).clone()
    """The `GFX` property represents the underlying system object."""
    self.GFX.visible = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.PolygonAsset.destroy">
    <p>def <span class="ident">destroy</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.PolygonAsset.destroy', this);">Show source &equiv;</a></p>
  <div id="source-ggame.PolygonAsset.destroy" class="source">
    <pre><code>def destroy(self):
    if hasattr(self, 'GFX'):
        try:
            for gfx in self.GFXlist:
                try:
                    gfx.destroy(True)
                except:
                    pass
        except:
            pass
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggame.PolygonAsset.GFX" class="name">var <span class="ident">GFX</span></p>
            

            
  
    <div class="desc"><p>The <code>GFX</code> property represents the underlying system object.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.PolygonAsset.path" class="name">var <span class="ident">path</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="ggame.RectangleAsset" class="name">class <span class="ident">RectangleAsset</span></p>
      
  
    <div class="desc"><p>The <a href="#ggame.RectangleAsset"><code>RectangleAsset</code></a> is a "virtual" asset that is created on the
fly without requiring creation of an image file.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.RectangleAsset', this);">Show source &equiv;</a></p>
  <div id="source-ggame.RectangleAsset" class="source">
    <pre><code>class RectangleAsset(_ShapeAsset):
    """
    The `ggame.RectangleAsset` is a "virtual" asset that is created on the
    fly without requiring creation of an image file.
    """

    def __init__(self, width, height, line=blackline, fill=black):
        """
        Creation of a `ggame.RectangleAsset` requires specification of the 
        rectangle `width` and `height` in pixels, the `line` (as a proper
        `ggame.LineStyle` instance) and fill properties (as a `ggame.Color`
        instance).
        """
        super().__init__(line, fill)
        self.width = width
        self.height = height
        self.GFX = GFX_Graphics.drawRect(0, 0, self.width, self.height).clone()
        """The `GFX` property represents the underlying system object."""
        self.GFX.visible = False
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggame.RectangleAsset">RectangleAsset</a></li>
          <li>__pdoc_file_module__._ShapeAsset</li>
          <li>__pdoc_file_module__._CurveAsset</li>
          <li>__pdoc_file_module__._GraphicsAsset</li>
          <li>__pdoc_file_module__._Asset</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggame.RectangleAsset.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, width, height, line=&lt;__pdoc_file_module__.LineStyle object at 0x7f8eacdd9eb8&gt;, fill=&lt;__pdoc_file_module__.Color object at 0x7f8eacdd9d30&gt;)</p>
    </div>
    

    
  
    <div class="desc"><p>Creation of a <a href="#ggame.RectangleAsset"><code>RectangleAsset</code></a> requires specification of the 
rectangle <code>width</code> and <code>height</code> in pixels, the <code>line</code> (as a proper
<a href="#ggame.LineStyle"><code>LineStyle</code></a> instance) and fill properties (as a <a href="#ggame.Color"><code>Color</code></a>
instance).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.RectangleAsset.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggame.RectangleAsset.__init__" class="source">
    <pre><code>def __init__(self, width, height, line=blackline, fill=black):
    """
    Creation of a `ggame.RectangleAsset` requires specification of the 
    rectangle `width` and `height` in pixels, the `line` (as a proper
    `ggame.LineStyle` instance) and fill properties (as a `ggame.Color`
    instance).
    """
    super().__init__(line, fill)
    self.width = width
    self.height = height
    self.GFX = GFX_Graphics.drawRect(0, 0, self.width, self.height).clone()
    """The `GFX` property represents the underlying system object."""
    self.GFX.visible = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.RectangleAsset.destroy">
    <p>def <span class="ident">destroy</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.RectangleAsset.destroy', this);">Show source &equiv;</a></p>
  <div id="source-ggame.RectangleAsset.destroy" class="source">
    <pre><code>def destroy(self):
    if hasattr(self, 'GFX'):
        try:
            for gfx in self.GFXlist:
                try:
                    gfx.destroy(True)
                except:
                    pass
        except:
            pass
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggame.RectangleAsset.GFX" class="name">var <span class="ident">GFX</span></p>
            

            
  
    <div class="desc"><p>The <code>GFX</code> property represents the underlying system object.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.RectangleAsset.height" class="name">var <span class="ident">height</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.RectangleAsset.width" class="name">var <span class="ident">width</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="ggame.Sound" class="name">class <span class="ident">Sound</span></p>
      
  
    <div class="desc"><p>The <a href="#ggame.Sound"><code>Sound</code></a> class represents a sound, with methods for controlling
when and how the sound is played in the application.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.Sound', this);">Show source &equiv;</a></p>
  <div id="source-ggame.Sound" class="source">
    <pre><code>class Sound(object):
    """
    The `ggame.Sound` class represents a sound, with methods for controlling
    when and how the sound is played in the application.
    """

    def __init__(self, asset):
        """
        Pass a valid `ggame.SoundAsset` instance when creating a `ggame.Sound` object.
        """
        self.asset = asset
        """
        A reference to the `ggame.SoundAsset` instance.
        """
        self.SND = SND_Sound(self.asset.url)
        """
        A reference to the underlying sound object provided by the system.
        """
        self.SND.load()
        
    def play(self):
        """
        Play the sound once.
        """
        self.stop()
        self.SND.play()

    def loop(self):
        """
        Play the sound continuously, looping forever.
        """
        self.stop()
        self.SND.loop()
        self.SND.play()
        
    def stop(self):
        """
        Stop playing the sound.
        """
        self.SND.stop()
        
    @property
    def volume(self):
        """
        The `ggame.Sound.volume` property is a number ranging from 0-100, that 
        represents the volume or intensity of the sound when it is playing.
        """
        return self.SND.getVolume()
        
    @volume.setter
    def volume(self, value):
        self.SND.setVolume(value)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggame.Sound">Sound</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggame.Sound.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, asset)</p>
    </div>
    

    
  
    <div class="desc"><p>Pass a valid <a href="#ggame.SoundAsset"><code>SoundAsset</code></a> instance when creating a <a href="#ggame.Sound"><code>Sound</code></a> object.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.Sound.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggame.Sound.__init__" class="source">
    <pre><code>def __init__(self, asset):
    """
    Pass a valid `ggame.SoundAsset` instance when creating a `ggame.Sound` object.
    """
    self.asset = asset
    """
    A reference to the `ggame.SoundAsset` instance.
    """
    self.SND = SND_Sound(self.asset.url)
    """
    A reference to the underlying sound object provided by the system.
    """
    self.SND.load()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.Sound.loop">
    <p>def <span class="ident">loop</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Play the sound continuously, looping forever.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.Sound.loop', this);">Show source &equiv;</a></p>
  <div id="source-ggame.Sound.loop" class="source">
    <pre><code>def loop(self):
    """
    Play the sound continuously, looping forever.
    """
    self.stop()
    self.SND.loop()
    self.SND.play()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.Sound.play">
    <p>def <span class="ident">play</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Play the sound once.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.Sound.play', this);">Show source &equiv;</a></p>
  <div id="source-ggame.Sound.play" class="source">
    <pre><code>def play(self):
    """
    Play the sound once.
    """
    self.stop()
    self.SND.play()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.Sound.stop">
    <p>def <span class="ident">stop</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Stop playing the sound.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.Sound.stop', this);">Show source &equiv;</a></p>
  <div id="source-ggame.Sound.stop" class="source">
    <pre><code>def stop(self):
    """
    Stop playing the sound.
    """
    self.SND.stop()
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggame.Sound.SND" class="name">var <span class="ident">SND</span></p>
            

            
  
    <div class="desc"><p>A reference to the underlying sound object provided by the system.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.Sound.asset" class="name">var <span class="ident">asset</span></p>
            

            
  
    <div class="desc"><p>A reference to the <a href="#ggame.SoundAsset"><code>SoundAsset</code></a> instance.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.Sound.volume" class="name">var <span class="ident">volume</span></p>
            

            
  
    <div class="desc"><p>The <a href="#ggame.Sound.volume"><code>volume</code></a> property is a number ranging from 0-100, that 
represents the volume or intensity of the sound when it is playing.</p></div>
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="ggame.SoundAsset" class="name">class <span class="ident">SoundAsset</span></p>
      
  
    <div class="desc"><p>Class representing a single sound asset (sound file, such as .mp3 or .wav).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.SoundAsset', this);">Show source &equiv;</a></p>
  <div id="source-ggame.SoundAsset" class="source">
    <pre><code>class SoundAsset(object):
    """
    Class representing a single sound asset (sound file, such as .mp3 or .wav).
    """    
    def __init__(self, url):
        """
        Create a `ggame.SoundAsset` instance by passing in the URL or file name
        of the desired sound. Sound file formats may include `.wav` or `.mp3`, subject
        to browser compatibility. 
        """
        self.url = url
        """
        A string containing the url or name of the asset file.
        """
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggame.SoundAsset">SoundAsset</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggame.SoundAsset.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, url)</p>
    </div>
    

    
  
    <div class="desc"><p>Create a <a href="#ggame.SoundAsset"><code>SoundAsset</code></a> instance by passing in the URL or file name
of the desired sound. Sound file formats may include <code>.wav</code> or <code>.mp3</code>, subject
to browser compatibility.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.SoundAsset.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggame.SoundAsset.__init__" class="source">
    <pre><code>def __init__(self, url):
    """
    Create a `ggame.SoundAsset` instance by passing in the URL or file name
    of the desired sound. Sound file formats may include `.wav` or `.mp3`, subject
    to browser compatibility. 
    """
    self.url = url
    """
    A string containing the url or name of the asset file.
    """
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggame.SoundAsset.url" class="name">var <span class="ident">url</span></p>
            

            
  
    <div class="desc"><p>A string containing the url or name of the asset file.</p></div>
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="ggame.Sprite" class="name">class <span class="ident">Sprite</span></p>
      
  
    <div class="desc"><p>The <a href="#ggame.Sprite"><code>Sprite</code></a> class combines the idea of a visual/graphical asset, a
position on the screen, and <em>behavior</em>. Although the <a href="#ggame.Sprite"><code>Sprite</code></a> can be
used as-is, it is generally subclassed to give it the desired behavior.</p>
<p>When subclassing the <a href="#ggame.Sprite"><code>Sprite</code></a> class, you may customize the initialization
code to use a specific asset. A 'step' or 'poll' method may be added
for handling per-frame actions (e.g. checking for collisions). Step or poll
functions are not automatically called by the <a href="#ggame.App"><code>App</code></a> class, but you
may subclass the <a href="#ggame.App"><code>App</code></a> class in order to do this.</p>
<p>Furthermore, you may wish to define event callback methods in your customized
sprite class. With customized creation, event handling, and periodic processing
you can achieve fully autonomous behavior for your class.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.Sprite', this);">Show source &equiv;</a></p>
  <div id="source-ggame.Sprite" class="source">
    <pre><code>class Sprite(object):
    """
    The `ggame.Sprite` class combines the idea of a visual/graphical asset, a
    position on the screen, and *behavior*. Although the `ggame.Sprite` can be
    used as-is, it is generally subclassed to give it the desired behavior.

    When subclassing the `ggame.Sprite` class, you may customize the initialization
    code to use a specific asset. A 'step' or 'poll' method may be added
    for handling per-frame actions (e.g. checking for collisions). Step or poll
    functions are not automatically called by the `ggame.App` class, but you
    may subclass the `ggame.App` class in order to do this.

    Furthermore, you may wish to define event callback methods in your customized
    sprite class. With customized creation, event handling, and periodic processing
    you can achieve fully autonomous behavior for your class. 
    """
 
    _rectCollision = "rect"
    _circCollision = "circ"
    
    def __init__(self, asset, pos=(0,0), edgedef=None):
        """
        The `ggame.Sprite` must be created with an existing graphical `asset`.
        
        An optional `pos` or position may be provided, which specifies the 
        starting (x,y) coordinates of the sprite on the screen. By default,
        the position of a sprite defines the location of its upper-left hand
        corner. This behavior can be modified by customizing the `center` of
        the sprite.
        
        An optional `edgedef` or edge definition may be provided, which
        specifies an asset that will be used to define the boundaries of
        the sprite for the purpose of collision detection. If no `edgedef` 
        asset is given, the Sprite asset is used, which will be a rectangular
        asset in the case of an image texture. This option is typically used
        to define a visible image outline for a texture-based sprite that has
        a transparent texture image background.
        
        Example: player = Sprite(ImageAsset("player.png", (100,100), CircleAsset(50))
        
        This creates a sprite using the `player.png` image, positioned with its
        upper left corner at coordinates (100,100) and with a 50 pixel radius 
        circular collision border. 
        """
        self._index = 0
        if type(asset) == ImageAsset:
            self.asset = asset
            try:
                #self.GFX = GFX_Sprite()
                self.GFX = GFX_Sprite(asset.GFX) # GFX is PIXI Sprite
            except:
                self.GFX = None
        elif type(asset) in [RectangleAsset, 
            CircleAsset, 
            EllipseAsset, 
            PolygonAsset,
            LineAsset,
            ]:
            self.asset = asset
            self.GFX = GFX_Sprite(asset.GFX.generateTexture())
            #self.GFX = asset.GFX.clone() # GFX is PIXI Graphics (from Sprite)
            #self.GFX.visible = True
        elif type(asset) in [TextAsset]:
            self.asset = asset._clone()
            self.GFX = self.asset.GFX # GFX is PIXI Text (from Sprite)
            self.GFX.visible = True
        if not edgedef:
            self.edgedef = asset
        else:
            self.edgedef = edgedef
        self.xmin = self.xmax = self.ymin = self.ymax = 0
        self.position = pos
        """Tuple indicates the position of the sprite on the screen."""
        self._extentsdirty = True
        """Boolean indicates if extents must be calculated before collision test"""
        self._createBaseVertices()
        self._setExtents()
        """Initialize the extents (xmax, xmin, etc.) for collision detection"""
        App._add(self)
        
    def _createBaseVertices(self):
        """
        Create sprite-relative list of vertex coordinates for boundary
        """
        self._basevertices = []
        assettype = type(self.edgedef)
        if assettype in [RectangleAsset, ImageAsset, TextAsset]:
            self._basevertices = [(0,0), 
                (0,self.edgedef.height), 
                (self.edgedef.width,self.edgedef.height),
                (self.edgedef.width,0)]
        elif assettype is PolygonAsset:
            self._basevertices = self.edgedef.path[:-1]
        elif assettype is LineAsset:
            self._basevertices = [(0,0), 
                (self.edgedef.deltaX, self.edgedef.deltaY)]
        elif assettype is EllipseAsset:
            w = self.edgedef.halfw * 2
            h = self.edgedef.halfh * 2
            self._basevertices = [(0,0), (0,h), (w,h), (w,0)]

    def _xformVertices(self):
        """
        Create window-relative list of vertex coordinates for boundary
        """
        # find center as sprite-relative points (note sprite may be scaled)
        x = self.width * self.fxcenter / self.scale
        y = self.height * self.fycenter / self.scale
        if self.scale != 1.0:
            sc = self.scale
            # center-relative, scaled coordinates
            crsc = [((xp-x)*sc,(yp-y)*sc) for xp,yp in self._basevertices]
        else:
            crsc = [(xp-x,yp-y) for xp,yp in self._basevertices]
            
        # absolute, rotated coordinates
        c = math.cos(self.rotation)
        s = math.sin(self.rotation)
        self._absolutevertices = [(self.x + x*c + y*s, self.y + -x*s + y*c) 
                                    for x,y in crsc]


    def _setExtents(self):
        """
        update min/max x and y based on position, center, width, height
        """
        if self._extentsdirty:
            if type(self.asset) is CircleAsset:
                th = math.atan2(
                    self.fycenter - 0.5, 0.5 - self.fxcenter) + self.rotation
                D = self.width
                L = math.sqrt(math.pow(self.fxcenter - 0.5, 2) + 
                    math.pow(self.fycenter - 0.5, 2)) * D
                self.xmin = self.x + int(L*math.cos(th)) - D//2
                self.ymin = self.y - int(L*math.sin(th)) - D//2
                self.xmax = self.xmin + D
                self.ymax = self.ymin + D
            else:
                # Build vertex list
                self._xformVertices()
                x, y = zip(*self._absolutevertices)
                self.xmin = min(x)
                self.xmax = max(x)
                self.ymin = min(y)
                self.ymax = max(y)
            self._extentsdirty = False

    def firstImage(self):
        """
        Select and display the *first* image used by this sprite.
        """
        self.GFX.texture = self.asset[0]
    
    def lastImage(self):
        """
        Select and display the *last* image used by this sprite.
        """
        self.GFX.texture = self.asset[-1]
    
    def nextImage(self, wrap = False):
        """
        Select and display the *next* image used by this sprite.
        If the current image is already the *last* image, then
        the image is not advanced.

        If the optional `wrap` parameter is set to `True`, then calling
        `ggame.Sprite.nextImage` on the last image will cause the *first*
        image to be loaded.
        """
        self._index += 1
        if self._index >= len(self.asset):
            if wrap:
                self._index = 0
            else:
                self._index = len(self.asset)-1
        self.GFX.texture = self.asset[self._index]
    
    def prevImage(self, wrap = False):
        """
        Select and display the *previous* image used by this sprite.
        If the current image is already the *first* image, then
        the image is not changed.

        If the optional `wrap` parameter is set to `True`, then calling
        `ggame.Sprite.prevImage` on the first image will cause the *last*
        image to be loaded.
        """
        self._index -= 1
        if self._index < 0:
            if wrap:
                self._index = len(self.asset)-1
            else:
                self._index = 0
        self.GFX.texture = self.asset[self._index]
    
    def setImage(self, index=0):
        """
        Select the image to display by giving its `index`, where an index
        of zero represents the *first* image in the asset.

        This is equivalent to setting the `ggame.Sprite.index` property
        directly.
        """
        self.index = index

    def rectangularCollisionModel(self):
        """
        Obsolete. No op.
        """
        pass
    
    def circularCollisionModel(self):
        """
        Obsolete. No op.
        """
        pass
    
    

    @property
    def index(self):
        """This is an integer index in to the list of images available for this sprite."""
        return self._index
        
    @index.setter
    def index(self, value):
        self._index = value
        try:
            self.GFX.texture = self.asset[self._index]
        except:
            self._index = 0
            self.GFX.texture = self.asset[self._index]

    @property
    def width(self):
        """
        This is an integer representing the display width of the sprite.
        Assigning a value to the width will scale the image horizontally.
        """
        return self.GFX.width
        
    @width.setter
    def width(self, value):
        self.GFX.width = value
        self._extentsdirty = True
    
    @property
    def height(self):
        """
        This is an integer representing the display height of the sprite.
        Assigning a value to the height will scale the image vertically.
        """
        return self.GFX.height
    
    @height.setter
    def height(self, value):
        self.GFX.height = value
        self._extentsdirty = True
        
    @property
    def x(self):
        """
        This represents the x-coordinate of the sprite on the screen. Assigning
        a value to this attribute will move the sprite horizontally.
        """
        return self.GFX.position.x
        
    @x.setter
    def x(self, value):
        deltax = value - self.GFX.position.x
        self.xmax += deltax
        self.xmin += deltax
        """Adjust extents directly with low overhead"""
        self.GFX.position.x = value

    @property
    def y(self):
        """
        This represents the y-coordinate of the sprite on the screen. Assigning
        a value to this attribute will move the sprite vertically.
        """
        return self.GFX.position.y
        
    @y.setter
    def y(self, value):
        deltay = value - self.GFX.position.y
        self.ymax += deltay
        self.ymin += deltay
        """Adjust extents directly with low overhead"""
        self.GFX.position.y = value

    @property
    def position(self):
        """
        This represents the (x,y) coordinates of the sprite on the screen. Assigning
        a value to this attribute will move the sprite to the new coordinates.
        """
        return (self.GFX.position.x, self.GFX.position.y)
        
    @position.setter
    def position(self, value):
        self.x, self.y = value

    @property
    def fxcenter(self):
        """
        This represents the horizontal position of the sprite "center", as a floating
        point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
        of the sprite refers to its left hand edge. A value of 1.0 refers to its 
        right hand edge. Any value in between may be specified. Values may be assigned
        to this attribute. 
        """
        try:
            return self.GFX.anchor.x
            self._extentsdirty = True
        except:
            return 0.0
        
    @fxcenter.setter
    def fxcenter(self, value):
        """
        Float: 0-1
        """
        try:
            self.GFX.anchor.x = value
            self._extentsdirty = True
        except:
            pass
        
    @property
    def fycenter(self):
        """
        This represents the vertical position of the sprite "center", as a floating
        point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
        of the sprite refers to its top edge. A value of 1.0 refers to its 
        bottom edge. Any value in between may be specified. Values may be assigned
        to this attribute. 
        """
        try:
            return self.GFX.anchor.y
        except:
            return 0.0
        
    @fycenter.setter
    def fycenter(self, value):
        """
        Float: 0-1
        """
        try:
            self.GFX.anchor.y = value
            self._extentsdirty = True
        except:
            pass
    
    @property
    def center(self):
        """
        This attribute represents the horizontal and vertical position of the 
        sprite "center" as a tuple of floating point numbers. See the 
        descriptions for `ggame.Sprite.fxcenter` and `ggame.Sprite.fycenter` for 
        more details.
        """
        try:
            return (self.GFX.anchor.x, self.GFX.anchor.y)
        except:
            return (0.0, 0.0)
        
    @center.setter
    def center(self, value):
        try:
            self.GFX.anchor.x = value[0]
            self.GFX.anchor.y = value[1]
            self._extentsdirty = True
        except:
            pass
    
    @property
    def visible(self):
        """
        This boolean attribute may be used to change the visibility of the sprite. Setting
        `ggame.Sprite.visible` to `False` will prevent the sprite from rendering on the 
        screen.
        """
        return self.GFX.visible
    
    @visible.setter
    def visible(self, value):
        self.GFX.visible = value

    @property
    def scale(self):
        """
        This attribute may be used to change the size of the sprite ('scale' it) on the 
        screen. Value may be a floating point number. A value of 1.0 means that the sprite
        image will keep its original size. A value of 2.0 would double it, etc.
        """
        try:
            return self.GFX.scale.x
        except AttributeError:
            return 1.0
        
    @scale.setter
    def scale(self, value):
        self.GFX.scale.x = value
        self.GFX.scale.y = value
        self._extentsdirty = True

    @property
    def rotation(self):
        """
        This attribute may be used to change the rotation of the sprite on the screen.
        Value may be a floating point number. A value of 0.0 means no rotation. A value 
        of 1.0 means  a rotation of 1 radian in a counter-clockwise direction. One radian
        is 180/pi or approximately 57.3 degrees.
        """
        try:
            return -self.GFX.rotation
        except AttributeError:
            return 0.0
        
    @rotation.setter
    def rotation(self, value):
        self.GFX.rotation = -value
        if value:
            self._extentsdirty = True

    @classmethod
    def collidingCircleWithPoly(cls, circ, poly):
        return True
    
    def collidingPolyWithPoly(self, obj):
        return True

    def collidingWith(self, obj):
        """
        Return a boolean True if this sprite is currently overlapping the sprite 
        referenced by `obj`. Returns False if checking for collision with 
        itself. Returns False if extents of object make it impossible for
        collision to occur. Returns True if sprite's `edgedef` parameter overlaps
        with other sprite's `edgedef` parameter, taking into consideration both
        sprites' center, rotation and scale settings.
        """
        if self is obj:
            return False
        else:
            self._setExtents()
            obj._setExtents()
            # Gross check for overlap will usually rule out a collision
            if (self.xmin > obj.xmax
                or self.xmax < obj.xmin
                or self.ymin > obj.ymax
                or self.ymax < obj.ymin):
                return False
            # Otherwise, perform a careful overlap determination
            elif type(self.asset) is CircleAsset:
                if type(obj.asset) is CircleAsset:
                    # two circles .. check distance between
                    sx = (self.xmin + self.xmax) / 2
                    sy = (self.ymin + self.ymax) / 2
                    ox = (obj.xmin + obj.xmax) / 2
                    oy = (obj.ymin + obj.ymax) / 2
                    d = math.sqrt((sx-ox)**2 + (sy-oy)**2)
                    return d <= self.width/2 + obj.width/2
                else:
                    return self.collidingCircleWithPoly(self, obj)
            else:
                if type(obj.asset) is CircleAsset:
                    return self.collidingCircleWithPoly(obj, self)
                else:
                    return self.collidingPolyWithPoly(obj)
                
                

    def collidingWithSprites(self, sclass = None):
        """
        Return a list of sprite objects identified by the `sclass` parameter
        that are currently colliding with (that is, with which the `ggame.Sprite.collidingWith`
        method returns True) this sprite. If `sclass` is set to `None` (default), then
        all other sprites are checked for collision, otherwise, only sprites whose
        class matches `sclass` are checked.
        """
        if sclass is None:
            slist = App.spritelist
        else:
            slist = App.getSpritesbyClass(sclass)
        return list(filter(self.collidingWith, slist))

    def destroy(self):
        """
        Call the `ggame.Sprite.destroy` method to prevent the sprite from being displayed,
        or checked in collision detection. If you only want to prevent a sprite from being
        displayed, set the `ggame.Sprite.visible` attribute to `False`.
        """
        App._remove(self)
        self.GFX.destroy()
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggame.Sprite">Sprite</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggame.Sprite.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, asset, pos=(0, 0), edgedef=None)</p>
    </div>
    

    
  
    <div class="desc"><p>The <a href="#ggame.Sprite"><code>Sprite</code></a> must be created with an existing graphical <code>asset</code>.</p>
<p>An optional <code>pos</code> or position may be provided, which specifies the 
starting (x,y) coordinates of the sprite on the screen. By default,
the position of a sprite defines the location of its upper-left hand
corner. This behavior can be modified by customizing the <code>center</code> of
the sprite.</p>
<p>An optional <code>edgedef</code> or edge definition may be provided, which
specifies an asset that will be used to define the boundaries of
the sprite for the purpose of collision detection. If no <code>edgedef</code> 
asset is given, the Sprite asset is used, which will be a rectangular
asset in the case of an image texture. This option is typically used
to define a visible image outline for a texture-based sprite that has
a transparent texture image background.</p>
<p>Example: player = Sprite(ImageAsset("player.png", (100,100), CircleAsset(50))</p>
<p>This creates a sprite using the <code>player.png</code> image, positioned with its
upper left corner at coordinates (100,100) and with a 50 pixel radius 
circular collision border.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.Sprite.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggame.Sprite.__init__" class="source">
    <pre><code>def __init__(self, asset, pos=(0,0), edgedef=None):
    """
    The `ggame.Sprite` must be created with an existing graphical `asset`.
    
    An optional `pos` or position may be provided, which specifies the 
    starting (x,y) coordinates of the sprite on the screen. By default,
    the position of a sprite defines the location of its upper-left hand
    corner. This behavior can be modified by customizing the `center` of
    the sprite.
    
    An optional `edgedef` or edge definition may be provided, which
    specifies an asset that will be used to define the boundaries of
    the sprite for the purpose of collision detection. If no `edgedef` 
    asset is given, the Sprite asset is used, which will be a rectangular
    asset in the case of an image texture. This option is typically used
    to define a visible image outline for a texture-based sprite that has
    a transparent texture image background.
    
    Example: player = Sprite(ImageAsset("player.png", (100,100), CircleAsset(50))
    
    This creates a sprite using the `player.png` image, positioned with its
    upper left corner at coordinates (100,100) and with a 50 pixel radius 
    circular collision border. 
    """
    self._index = 0
    if type(asset) == ImageAsset:
        self.asset = asset
        try:
            #self.GFX = GFX_Sprite()
            self.GFX = GFX_Sprite(asset.GFX) # GFX is PIXI Sprite
        except:
            self.GFX = None
    elif type(asset) in [RectangleAsset, 
        CircleAsset, 
        EllipseAsset, 
        PolygonAsset,
        LineAsset,
        ]:
        self.asset = asset
        self.GFX = GFX_Sprite(asset.GFX.generateTexture())
        #self.GFX = asset.GFX.clone() # GFX is PIXI Graphics (from Sprite)
        #self.GFX.visible = True
    elif type(asset) in [TextAsset]:
        self.asset = asset._clone()
        self.GFX = self.asset.GFX # GFX is PIXI Text (from Sprite)
        self.GFX.visible = True
    if not edgedef:
        self.edgedef = asset
    else:
        self.edgedef = edgedef
    self.xmin = self.xmax = self.ymin = self.ymax = 0
    self.position = pos
    """Tuple indicates the position of the sprite on the screen."""
    self._extentsdirty = True
    """Boolean indicates if extents must be calculated before collision test"""
    self._createBaseVertices()
    self._setExtents()
    """Initialize the extents (xmax, xmin, etc.) for collision detection"""
    App._add(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.Sprite.circularCollisionModel">
    <p>def <span class="ident">circularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.Sprite.circularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggame.Sprite.circularCollisionModel" class="source">
    <pre><code>def circularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.Sprite.collidingPolyWithPoly">
    <p>def <span class="ident">collidingPolyWithPoly</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.Sprite.collidingPolyWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggame.Sprite.collidingPolyWithPoly" class="source">
    <pre><code>def collidingPolyWithPoly(self, obj):
    return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.Sprite.collidingWith">
    <p>def <span class="ident">collidingWith</span>(</p><p>self, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a boolean True if this sprite is currently overlapping the sprite 
referenced by <code>obj</code>. Returns False if checking for collision with 
itself. Returns False if extents of object make it impossible for
collision to occur. Returns True if sprite's <code>edgedef</code> parameter overlaps
with other sprite's <code>edgedef</code> parameter, taking into consideration both
sprites' center, rotation and scale settings.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.Sprite.collidingWith', this);">Show source &equiv;</a></p>
  <div id="source-ggame.Sprite.collidingWith" class="source">
    <pre><code>def collidingWith(self, obj):
    """
    Return a boolean True if this sprite is currently overlapping the sprite 
    referenced by `obj`. Returns False if checking for collision with 
    itself. Returns False if extents of object make it impossible for
    collision to occur. Returns True if sprite's `edgedef` parameter overlaps
    with other sprite's `edgedef` parameter, taking into consideration both
    sprites' center, rotation and scale settings.
    """
    if self is obj:
        return False
    else:
        self._setExtents()
        obj._setExtents()
        # Gross check for overlap will usually rule out a collision
        if (self.xmin > obj.xmax
            or self.xmax < obj.xmin
            or self.ymin > obj.ymax
            or self.ymax < obj.ymin):
            return False
        # Otherwise, perform a careful overlap determination
        elif type(self.asset) is CircleAsset:
            if type(obj.asset) is CircleAsset:
                # two circles .. check distance between
                sx = (self.xmin + self.xmax) / 2
                sy = (self.ymin + self.ymax) / 2
                ox = (obj.xmin + obj.xmax) / 2
                oy = (obj.ymin + obj.ymax) / 2
                d = math.sqrt((sx-ox)**2 + (sy-oy)**2)
                return d <= self.width/2 + obj.width/2
            else:
                return self.collidingCircleWithPoly(self, obj)
        else:
            if type(obj.asset) is CircleAsset:
                return self.collidingCircleWithPoly(obj, self)
            else:
                return self.collidingPolyWithPoly(obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.Sprite.collidingWithSprites">
    <p>def <span class="ident">collidingWithSprites</span>(</p><p>self, sclass=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a list of sprite objects identified by the <code>sclass</code> parameter
that are currently colliding with (that is, with which the <a href="#ggame.Sprite.collidingWith"><code>collidingWith</code></a>
method returns True) this sprite. If <code>sclass</code> is set to <code>None</code> (default), then
all other sprites are checked for collision, otherwise, only sprites whose
class matches <code>sclass</code> are checked.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.Sprite.collidingWithSprites', this);">Show source &equiv;</a></p>
  <div id="source-ggame.Sprite.collidingWithSprites" class="source">
    <pre><code>def collidingWithSprites(self, sclass = None):
    """
    Return a list of sprite objects identified by the `sclass` parameter
    that are currently colliding with (that is, with which the `ggame.Sprite.collidingWith`
    method returns True) this sprite. If `sclass` is set to `None` (default), then
    all other sprites are checked for collision, otherwise, only sprites whose
    class matches `sclass` are checked.
    """
    if sclass is None:
        slist = App.spritelist
    else:
        slist = App.getSpritesbyClass(sclass)
    return list(filter(self.collidingWith, slist))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.Sprite.destroy">
    <p>def <span class="ident">destroy</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Call the <a href="#ggame.Sprite.destroy"><code>destroy</code></a> method to prevent the sprite from being displayed,
or checked in collision detection. If you only want to prevent a sprite from being
displayed, set the <a href="#ggame.Sprite.visible"><code>visible</code></a> attribute to <code>False</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.Sprite.destroy', this);">Show source &equiv;</a></p>
  <div id="source-ggame.Sprite.destroy" class="source">
    <pre><code>def destroy(self):
    """
    Call the `ggame.Sprite.destroy` method to prevent the sprite from being displayed,
    or checked in collision detection. If you only want to prevent a sprite from being
    displayed, set the `ggame.Sprite.visible` attribute to `False`.
    """
    App._remove(self)
    self.GFX.destroy()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.Sprite.firstImage">
    <p>def <span class="ident">firstImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>first</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.Sprite.firstImage', this);">Show source &equiv;</a></p>
  <div id="source-ggame.Sprite.firstImage" class="source">
    <pre><code>def firstImage(self):
    """
    Select and display the *first* image used by this sprite.
    """
    self.GFX.texture = self.asset[0]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.Sprite.lastImage">
    <p>def <span class="ident">lastImage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>last</em> image used by this sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.Sprite.lastImage', this);">Show source &equiv;</a></p>
  <div id="source-ggame.Sprite.lastImage" class="source">
    <pre><code>def lastImage(self):
    """
    Select and display the *last* image used by this sprite.
    """
    self.GFX.texture = self.asset[-1]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.Sprite.nextImage">
    <p>def <span class="ident">nextImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>next</em> image used by this sprite.
If the current image is already the <em>last</em> image, then
the image is not advanced.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<a href="#ggame.Sprite.nextImage"><code>nextImage</code></a> on the last image will cause the <em>first</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.Sprite.nextImage', this);">Show source &equiv;</a></p>
  <div id="source-ggame.Sprite.nextImage" class="source">
    <pre><code>def nextImage(self, wrap = False):
    """
    Select and display the *next* image used by this sprite.
    If the current image is already the *last* image, then
    the image is not advanced.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.nextImage` on the last image will cause the *first*
    image to be loaded.
    """
    self._index += 1
    if self._index >= len(self.asset):
        if wrap:
            self._index = 0
        else:
            self._index = len(self.asset)-1
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.Sprite.prevImage">
    <p>def <span class="ident">prevImage</span>(</p><p>self, wrap=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Select and display the <em>previous</em> image used by this sprite.
If the current image is already the <em>first</em> image, then
the image is not changed.</p>
<p>If the optional <code>wrap</code> parameter is set to <code>True</code>, then calling
<a href="#ggame.Sprite.prevImage"><code>prevImage</code></a> on the first image will cause the <em>last</em>
image to be loaded.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.Sprite.prevImage', this);">Show source &equiv;</a></p>
  <div id="source-ggame.Sprite.prevImage" class="source">
    <pre><code>def prevImage(self, wrap = False):
    """
    Select and display the *previous* image used by this sprite.
    If the current image is already the *first* image, then
    the image is not changed.
    If the optional `wrap` parameter is set to `True`, then calling
    `ggame.Sprite.prevImage` on the first image will cause the *last*
    image to be loaded.
    """
    self._index -= 1
    if self._index < 0:
        if wrap:
            self._index = len(self.asset)-1
        else:
            self._index = 0
    self.GFX.texture = self.asset[self._index]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.Sprite.rectangularCollisionModel">
    <p>def <span class="ident">rectangularCollisionModel</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Obsolete. No op.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.Sprite.rectangularCollisionModel', this);">Show source &equiv;</a></p>
  <div id="source-ggame.Sprite.rectangularCollisionModel" class="source">
    <pre><code>def rectangularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.Sprite.setImage">
    <p>def <span class="ident">setImage</span>(</p><p>self, index=0)</p>
    </div>
    

    
  
    <div class="desc"><p>Select the image to display by giving its <code>index</code>, where an index
of zero represents the <em>first</em> image in the asset.</p>
<p>This is equivalent to setting the <a href="#ggame.Sprite.index"><code>index</code></a> property
directly.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.Sprite.setImage', this);">Show source &equiv;</a></p>
  <div id="source-ggame.Sprite.setImage" class="source">
    <pre><code>def setImage(self, index=0):
    """
    Select the image to display by giving its `index`, where an index
    of zero represents the *first* image in the asset.
    This is equivalent to setting the `ggame.Sprite.index` property
    directly.
    """
    self.index = index
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggame.Sprite.center" class="name">var <span class="ident">center</span></p>
            

            
  
    <div class="desc"><p>This attribute represents the horizontal and vertical position of the 
sprite "center" as a tuple of floating point numbers. See the 
descriptions for <a href="#ggame.Sprite.fxcenter"><code>fxcenter</code></a> and <a href="#ggame.Sprite.fycenter"><code>fycenter</code></a> for 
more details.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.Sprite.fxcenter" class="name">var <span class="ident">fxcenter</span></p>
            

            
  
    <div class="desc"><p>This represents the horizontal position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its left hand edge. A value of 1.0 refers to its 
right hand edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.Sprite.fycenter" class="name">var <span class="ident">fycenter</span></p>
            

            
  
    <div class="desc"><p>This represents the vertical position of the sprite "center", as a floating
point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
of the sprite refers to its top edge. A value of 1.0 refers to its 
bottom edge. Any value in between may be specified. Values may be assigned
to this attribute.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.Sprite.height" class="name">var <span class="ident">height</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display height of the sprite.
Assigning a value to the height will scale the image vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.Sprite.index" class="name">var <span class="ident">index</span></p>
            

            
  
    <div class="desc"><p>This is an integer index in to the list of images available for this sprite.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.Sprite.position" class="name">var <span class="ident">position</span></p>
            

            
  
    <div class="desc"><p>Tuple indicates the position of the sprite on the screen.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.Sprite.rotation" class="name">var <span class="ident">rotation</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the rotation of the sprite on the screen.
Value may be a floating point number. A value of 0.0 means no rotation. A value 
of 1.0 means  a rotation of 1 radian in a counter-clockwise direction. One radian
is 180/pi or approximately 57.3 degrees.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.Sprite.scale" class="name">var <span class="ident">scale</span></p>
            

            
  
    <div class="desc"><p>This attribute may be used to change the size of the sprite ('scale' it) on the 
screen. Value may be a floating point number. A value of 1.0 means that the sprite
image will keep its original size. A value of 2.0 would double it, etc.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.Sprite.visible" class="name">var <span class="ident">visible</span></p>
            

            
  
    <div class="desc"><p>This boolean attribute may be used to change the visibility of the sprite. Setting
<a href="#ggame.Sprite.visible"><code>visible</code></a> to <code>False</code> will prevent the sprite from rendering on the 
screen.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.Sprite.width" class="name">var <span class="ident">width</span></p>
            

            
  
    <div class="desc"><p>This is an integer representing the display width of the sprite.
Assigning a value to the width will scale the image horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.Sprite.x" class="name">var <span class="ident">x</span></p>
            

            
  
    <div class="desc"><p>This represents the x-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite horizontally.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.Sprite.y" class="name">var <span class="ident">y</span></p>
            

            
  
    <div class="desc"><p>This represents the y-coordinate of the sprite on the screen. Assigning
a value to this attribute will move the sprite vertically.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="ggame.Sprite.collidingCircleWithPoly">
    <p>def <span class="ident">collidingCircleWithPoly</span>(</p><p>cls, circ, poly)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.Sprite.collidingCircleWithPoly', this);">Show source &equiv;</a></p>
  <div id="source-ggame.Sprite.collidingCircleWithPoly" class="source">
    <pre><code>@classmethod
def collidingCircleWithPoly(cls, circ, poly):
    return True
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ggame.TextAsset" class="name">class <span class="ident">TextAsset</span></p>
      
  
    <div class="desc"><p>The <a href="#ggame.TextAsset"><code>TextAsset</code></a> is a "virtual" asset that is created on the fly
without requiring creation of an image file. A <code>TextAsset</code> instance
represents a block of text, together with its styling (font, color, etc.).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.TextAsset', this);">Show source &equiv;</a></p>
  <div id="source-ggame.TextAsset" class="source">
    <pre><code>class TextAsset(_GraphicsAsset):
    """
    The `ggame.TextAsset` is a "virtual" asset that is created on the fly
    without requiring creation of an image file. A `TextAsset` instance
    represents a block of text, together with its styling (font, color, etc.).
    """
 
    def __init__(self, text, **kwargs):
        """
        The `ggame.TextAsset` must be created with a string as the `text` parameter.
        
        The remaining optional arguments must be supplied as keyword parameters. These
        parameters are described under the class attributes, below:
        """
        super().__init__()
        self.text = text
        self.style = kwargs.get('style', '20px Arial')
        """A string that specifies style, size and typeface (e.g. `'italic 20pt Helvetica'` or `'20px Arial'`)"""
        width = kwargs.get('width', 100)
        """Width of the text block on the screen, in pixels."""
        self.fill = kwargs.get('fill', Color(0, 1))
        """A valid `ggame.Color` instance that specifies the color and transparency of the text."""
        self.align = kwargs.get('align', 'left')
        """The alignment style of the text. One of: `'left'`, `'center'`, or `'right'`."""
        self.GFX = GFX_Text(self.text, 
            {'font': self.style,
                'fill' : self.fill.color,
                'align' : self.align,
                'wordWrap' : True,
                'wordWrapWidth' : width,
                })
        """The `GFX` property represents the underlying system object."""
        self.GFX.alpha = self.fill.alpha
        self.GFX.visible = False
        
    def _clone(self):
        return type(self)(self.text,
            style = self.style,
            width = self.width,
            fill = self.fill,
            align = self.align)
    
    @property
    def width(self):
        return self.GFX.width
        
    @property
    def height(self):
        return self.GFX.height
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ggame.TextAsset">TextAsset</a></li>
          <li>__pdoc_file_module__._GraphicsAsset</li>
          <li>__pdoc_file_module__._Asset</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ggame.TextAsset.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, text, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>The <a href="#ggame.TextAsset"><code>TextAsset</code></a> must be created with a string as the <code>text</code> parameter.</p>
<p>The remaining optional arguments must be supplied as keyword parameters. These
parameters are described under the class attributes, below:</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.TextAsset.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ggame.TextAsset.__init__" class="source">
    <pre><code>def __init__(self, text, **kwargs):
    """
    The `ggame.TextAsset` must be created with a string as the `text` parameter.
    
    The remaining optional arguments must be supplied as keyword parameters. These
    parameters are described under the class attributes, below:
    """
    super().__init__()
    self.text = text
    self.style = kwargs.get('style', '20px Arial')
    """A string that specifies style, size and typeface (e.g. `'italic 20pt Helvetica'` or `'20px Arial'`)"""
    width = kwargs.get('width', 100)
    """Width of the text block on the screen, in pixels."""
    self.fill = kwargs.get('fill', Color(0, 1))
    """A valid `ggame.Color` instance that specifies the color and transparency of the text."""
    self.align = kwargs.get('align', 'left')
    """The alignment style of the text. One of: `'left'`, `'center'`, or `'right'`."""
    self.GFX = GFX_Text(self.text, 
        {'font': self.style,
            'fill' : self.fill.color,
            'align' : self.align,
            'wordWrap' : True,
            'wordWrapWidth' : width,
            })
    """The `GFX` property represents the underlying system object."""
    self.GFX.alpha = self.fill.alpha
    self.GFX.visible = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ggame.TextAsset.destroy">
    <p>def <span class="ident">destroy</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ggame.TextAsset.destroy', this);">Show source &equiv;</a></p>
  <div id="source-ggame.TextAsset.destroy" class="source">
    <pre><code>def destroy(self):
    if hasattr(self, 'GFX'):
        try:
            for gfx in self.GFXlist:
                try:
                    gfx.destroy(True)
                except:
                    pass
        except:
            pass
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ggame.TextAsset.GFX" class="name">var <span class="ident">GFX</span></p>
            

            
  
    <div class="desc"><p>The <code>GFX</code> property represents the underlying system object.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.TextAsset.align" class="name">var <span class="ident">align</span></p>
            

            
  
    <div class="desc"><p>The alignment style of the text. One of: <code>'left'</code>, <code>'center'</code>, or <code>'right'</code>.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.TextAsset.fill" class="name">var <span class="ident">fill</span></p>
            

            
  
    <div class="desc"><p>A valid <a href="#ggame.Color"><code>Color</code></a> instance that specifies the color and transparency of the text.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.TextAsset.height" class="name">var <span class="ident">height</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.TextAsset.style" class="name">var <span class="ident">style</span></p>
            

            
  
    <div class="desc"><p>A string that specifies style, size and typeface (e.g. <code>'italic 20pt Helvetica'</code> or <code>'20px Arial'</code>)</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.TextAsset.text" class="name">var <span class="ident">text</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ggame.TextAsset.width" class="name">var <span class="ident">width</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.1</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
